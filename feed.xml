<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>è®°å½•</title>
    <description></description>
    <link>https://zwt.io/</link>
    <atom:link href="https://zwt.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 17 Aug 2020 23:58:00 +0000</pubDate>
    <lastBuildDate>Mon, 17 Aug 2020 23:58:00 +0000</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>DS-ch15 Memory Management and B-Trees</title>
        <description>&lt;h1 id=&quot;155-exercises&quot;&gt;15.5 Exercises&lt;/h1&gt;

&lt;h3 id=&quot;reinforcement&quot;&gt;Reinforcement&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;R-15.1&lt;/strong&gt; Julia just bought a new computer that uses 64-bit integers to address memory cells. Argue why Julia will never in her life be able to upgrade the main memory of her computer so that it is the maximum-size possible, assuming that you have to have distinct atoms to represent different bits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.2&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. How many page misses does the LRU algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.3&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. How many page misses does the FIFO algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.4&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. What is the maximum number of page misses that the random algorithm incurs on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)? Show all of the random choices the algorithm made in this case.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.5&lt;/strong&gt; Describe, in detail, algorithms for adding an item to, or deleting an item from, an $(a,b)$ tree.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.6&lt;/strong&gt; Suppose &lt;em&gt;T&lt;/em&gt; is a multiway tree in which each internal node has at least five and at most eight children. For what values of &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; is $T$ a valid $(a,b)$ tree?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.7&lt;/strong&gt; For what values of d is the tree $T$ of the previous exercise an order-&lt;em&gt;d&lt;/em&gt; B-tree?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.8&lt;/strong&gt; Draw the result of inserting, into an initially empty order-7 B-tree, entries with keys (4,40,23,50,11,34,62,78,66,22,90,59,25,72,64,77,39,12), in this order.&lt;/p&gt;

&lt;h3 id=&quot;creativity&quot;&gt;Creativity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;C-15.9&lt;/strong&gt; Describe an efficient external-memory algorithm for removing all the duplicate entries in an array list of size &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.10&lt;/strong&gt; Describe an external-memory data structure to implement the stack ADT so that the total number of disk transfers needed to process a sequence of &lt;em&gt;k&lt;/em&gt; push and pop operations is $O(k/B)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.11&lt;/strong&gt; Describe an external-memory data structure to implement the queue ADT so that the total number of disk transfers needed to process a sequence of &lt;em&gt;k&lt;/em&gt; enqueue and dequeue operations is $O(k/B)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.12&lt;/strong&gt; Describe an external-memory version of the &lt;code&gt;PositionalList&lt;/code&gt; ADT (Section 7.3), with block size &lt;em&gt;B&lt;/em&gt;, such that an iteration of a list of length n is completed using $O(n/B)$ transfers in the worst case, and all other methods of the ADT require only $O(1)$ transfers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.13&lt;/strong&gt; Change the rules that define red-black trees so that each red-black tree &lt;em&gt;T&lt;/em&gt; has a corresponding $(4,8)$ tree, and vice versa.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.14&lt;/strong&gt; Describe a modified version of the B-tree insertion algorithm so that each time we create an overflow because of a split of a node &lt;em&gt;w&lt;/em&gt;, we redistribute keys among all of &lt;em&gt;w&lt;/em&gt;â€™s siblings, so that each sibling holds roughly the same number of keys (possibly cascading the split up to the parent of &lt;em&gt;w&lt;/em&gt;). What is the minimum fraction of each block that will always be filled using this scheme?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.15&lt;/strong&gt; Another possible external-memory map implementation is to use a skip list, but to collect consecutive groups of $O(B)$ nodes, in individual blocks, on any level in the skip list. In particular, we define an &lt;strong&gt;&lt;em&gt;order-d B-skip list&lt;/em&gt;&lt;/strong&gt; to be such a representation
of a skip list structure, where each block contains at least $âŒˆd/2âŒ‰$ list nodes and at most &lt;em&gt;d&lt;/em&gt; list nodes. Let us also choose &lt;em&gt;d&lt;/em&gt; in this case to be the maximum number of list nodes from a level of a skip list that can fit into one block. Describe how we should modify the skip-list insertion and removal algorithms for a &lt;em&gt;B&lt;/em&gt;-skip list so that the expected height of the structure is $O(logn/logB)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.16&lt;/strong&gt; Describe how to use a B-tree to implement the Partition ADT (Section 14.7.3) so that the union and find operations each use at most $O(logn/logB)$ disk transfers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.17&lt;/strong&gt; Suppose we are given a sequence &lt;em&gt;S&lt;/em&gt; of &lt;em&gt;n&lt;/em&gt; elements with integer keys such that some elements in &lt;em&gt;S&lt;/em&gt; are colored â€œblueâ€ and some elements in &lt;em&gt;S&lt;/em&gt; are colored â€œred.â€ In addition, say that a red element &lt;em&gt;e&lt;/em&gt; &lt;strong&gt;&lt;em&gt;pairs&lt;/em&gt;&lt;/strong&gt; with a blue element &lt;em&gt;f&lt;/em&gt; if they have the same key value. Describe an efficient external-memory algorithm for finding all the red-blue pairs in &lt;em&gt;S&lt;/em&gt;. How many disk transfers does your algorithm perform?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.18&lt;/strong&gt; Consider the page caching problem where the memory cache can hold &lt;em&gt;m&lt;/em&gt; pages, and we are given a sequence &lt;em&gt;P&lt;/em&gt; of &lt;em&gt;n&lt;/em&gt; requests taken from a pool of $m + 1$ possible pages. Describe the optimal strategy for the offline algorithm and show that it
causes at most $m + n/m$ page misses in total, starting from an empty cache.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.19&lt;/strong&gt; Describe an efficient external-memory algorithm that determines whether an array of &lt;em&gt;n&lt;/em&gt; integers contains a value occurring more than &lt;em&gt;n/2&lt;/em&gt; times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.20&lt;/strong&gt; Consider the page caching strategy based on the &lt;strong&gt;&lt;em&gt;least frequently used&lt;/em&gt;&lt;/strong&gt; (LFU) rule, where the page in the cache that has been accessed the least often is the one that is evicted when a new page is requested. If there are ties, LFU evicts the least frequently used page that has been in the cache the longest. Show that there is a sequence P of n requests that causes LFU to miss $â„¦(n)$ times for a cache of m pages, whereas the optimal algorithm will miss only $O(m)$ times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.21&lt;/strong&gt; Suppose that instead of having the node-search function $f (d) = 1$ in an order-&lt;em&gt;d&lt;/em&gt; B-tree &lt;em&gt;T&lt;/em&gt; , we have $f (d) = logd$. What does the asymptotic running time of performing a search in &lt;em&gt;T&lt;/em&gt; now become?&lt;/p&gt;

&lt;h3 id=&quot;projects&quot;&gt;Projects&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;P-15.22&lt;/strong&gt; Write a Java class that simulates the best-fit, worst-fit, first-fit, and next-fit algorithms for memory management. Determine experimentally which method is the best under various sequences of memory requests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-15.23&lt;/strong&gt; Write a Java class that implements all the methods of the sorted map ADT by means of an $(a,b)$ tree, where &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are integer constants passed as parameters to a constructor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-15.24&lt;/strong&gt; Implement the B-tree data structure, assuming a block size of 1024 and integer keys. Test the number of â€œdisk transfersâ€ needed to process a sequence of map operations.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Aug 2020 02:36:00 +0000</pubDate>
        <link>https://zwt.io/2020/08/16/ds-ch15/</link>
        <guid isPermaLink="true">https://zwt.io/2020/08/16/ds-ch15/</guid>
        
        <category>Data Structure</category>
        
        
      </item>
    
      <item>
        <title>DS-ch01</title>
        <description>&lt;h1 id=&quot;110-exercises&quot;&gt;1.10 Exercises&lt;/h1&gt;

&lt;h3 id=&quot;reinforcement&quot;&gt;Reinforcement&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;R-1.1&lt;/strong&gt; Write a short Java method, &lt;code&gt;inputAllBaseTypes&lt;/code&gt;, that inputs a different value of each base type from the standard 
input device and prints it back to the standard output device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.2&lt;/strong&gt; Suppose that we create an array &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;GameEntry&lt;/code&gt; objects, which has an integer &lt;code&gt;scores&lt;/code&gt; field, and we clone &lt;code&gt;A&lt;/code&gt; and 
store the result in an array &lt;code&gt;B&lt;/code&gt;. If we then immediately set &lt;code&gt;A[4].scores&lt;/code&gt; equal to 550, what is the score value of the 
&lt;code&gt;GameEntry&lt;/code&gt; object referenced by &lt;code&gt;B[4]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.3&lt;/strong&gt; Write a short Java method, &lt;code&gt;isMultiple&lt;/code&gt;, that takes two &lt;code&gt;long&lt;/code&gt; values, &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;m&lt;/em&gt;, and returns true if and only if &lt;em&gt;n&lt;/em&gt; is a multiple of &lt;em&gt;m&lt;/em&gt;, that is, $n = mi$ for some integer &lt;em&gt;i&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.4&lt;/strong&gt; Write a short Java method, &lt;code&gt;isEven&lt;/code&gt;, that takes an int i and returns true if and only if i is even. Your method cannot use the multiplication, modulus, or division operators, however.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.5&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of all positive integers less than or equal to n.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.6&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of  all the odd positive integers less than or equal to n.&lt;br /&gt;
&lt;strong&gt;R-1.7&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of the squares of all positive integers less than or equal to n.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.8&lt;/strong&gt; Write a short Java method that counts the number of vowel in a given character string.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.9&lt;/strong&gt; Write a short Java method that uses a &lt;code&gt;StringBuilder&lt;/code&gt; instance to remove all the punctuation from a string s storing a sentence, for example, transforming the string â€œLetâ€™s try, Mike!â€ to â€œLets try Mikeâ€.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.10&lt;/strong&gt; Write a Java class, Flower, that has three instance variables of type &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;float&lt;/code&gt;, which respectively represent the name of the flower, its number of petals, and price. Your class must include a constructor method that initializes each variable to an appropriate value, and your class should include methods for setting the value of each type, and getting the value of each type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.11&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 to include a method that updates the credit limit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.12&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 so that it ignores any request to process a negative payment amount.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.13&lt;/strong&gt; Modify the declaration of the first for loop in the main method in Code Fragment 1.6 so that its charges will cause exactly one of the three credit cards to attempt to go over its credit limit. Which credit card is it?&lt;/p&gt;

&lt;h3 id=&quot;creativity&quot;&gt;Creativity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;C-1.14&lt;/strong&gt; Write a pseudocode description of a method that reverses an array of n integers, so that the numbers are listed in the opposite order than they were before, and compare this method to an equivalent Java method for doing the same thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.15&lt;/strong&gt; Write a pseudocode description of a method for finding the smallest and largest numbers in an array of integers and compare that to a Java method that would do the same thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.16&lt;/strong&gt; Write a short program that takes as input three integers, a, b, and c, from the Java console and determines if they can be used in a correct arithmetic formula (in the given order), like â€œa+b = c,â€ â€œa = b - c,â€ or â€œa âˆ— b = c.â€&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.17&lt;/strong&gt; Write a short Java method that takes an array of int values and determines if there is a pair of distinct elements of the array whose product is even.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.18&lt;/strong&gt; The p-norm of a vector v = (v1,v2,â€¦,vn) in n-dimensional space is defined as kvk = qp v1p +v2p +Â·Â·Â·+vnp. For the special case of p = 2, this results in the traditional Euclidean norm, which represents the length of the vector. For example, the Euclidean norm of a two-dimensional vector with coordinates (4,3) has a Euclidean norm of âˆš42 +32 = âˆš16+9 = âˆš25 = 5. Give an implementation of a method named norm such that norm(v, p) returns the p-norm value of v and norm(v) returns the Euclidean norm of v, where v is represented as an array of coordinates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.19&lt;/strong&gt; Write a Java program that can take a positive integer greater than 2 as input and write out the number of times one must repeatedly divide this number by 2 before getting a value less than 2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.20&lt;/strong&gt; Write a Java method that takes an array of float values and determines if all the numbers are different from each other (that is, they are distinct).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.21&lt;/strong&gt; Write a Java method that takes an array containing the set of all integers in the range 1 to 52 and shuffles it into random order. Your method should output each possible order with equal probability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.22&lt;/strong&gt; Write a short Java program that outputs all possible strings formed by using the characters â€˜câ€™, â€˜aâ€™, â€˜tâ€™, â€˜dâ€™, â€˜oâ€™, and â€˜gâ€™ exactly once.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.23&lt;/strong&gt; Write a short Java program that takes two arrays a and b of length n storing int values, and returns the dot product of a and b. That is, it returns an array c of length n such that c[i] = a[i]Â· b[i], for i = 0,â€¦,n - 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.24&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 so that printSummary becomes a nonstatic method, and modify the main method from Code Fragment 1.6 accordingly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.25&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class to add a toString() method that returns a String representation of the card (rather than printing it to the console, as done by printSummary). Modify the main method from Code Fragment 1.6 accordingly to use the standard println command.&lt;/p&gt;

&lt;h3 id=&quot;projects&quot;&gt;Projects&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;P-1.26&lt;/strong&gt; Write a short Java program that takes all the lines input to standard input and writes them to standard output in reverse order. That is, each line is output in the correct order, but the ordering of the lines is reversed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.27&lt;/strong&gt; Write a Java program that can simulate a simple calculator, using the Java console as the exclusive input and output device. That is, each input to the calculator, be it a number, like 12.34 or 1034, or an operator, like + or =, can be done on a
separate line. After each such input, you should output to the Java console what would be displayed on your calculator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.28&lt;/strong&gt; A common punishment for school children is to write out a sentence multiple times. Write a Java stand-alone program that will write out the following sentence one hundred times: â€œI will never spam my friends again.â€ Your program should number each of the sentences and it should make eight different random looking typos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.29&lt;/strong&gt; The birthday paradox says that the probability that two people in a room will have the same birthday is more than half, provided n, the number of people in the room, is more than 23. This property is not really a paradox, but many people find it surprising. Design a Java program that can test this paradox by a series of experiments on randomly generated birthdays, which test this paradox for n = 5,10,15,20,â€¦,100.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.30&lt;/strong&gt; (For those who know Java graphical user interface methods:) Define a &lt;code&gt;GraphicalTest&lt;/code&gt; class that tests the functionality of the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 using text fields and buttons.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://zwt.io/2020/08/15/ds-ch01/</link>
        <guid isPermaLink="true">https://zwt.io/2020/08/15/ds-ch01/</guid>
        
        <category>Data Structure</category>
        
        
      </item>
    
      <item>
        <title>å›é¡¾OCP 1Z0-816è®¤è¯è€ƒè¯•</title>
        <description>&lt;p&gt;I started with OCA Java SE 8 Programmer I exam last year, it took me 12 days to prepare the OCA exam. It was relatively easy to pass the OCA exam, but it was much harder to pass the OCP 11 exam. It took me roughly 3 months to get fully prepared for the ultimate 1Z0-816, namely Java SE 11 Programmer II exam, for which response to the Oracle Certified Professional: Java SE 11 Developer certification. This is by far the most difficult Java certification exam from Oracle/Sun, not just because it covers topics such as modules, functional programming, concurrent programming, IO. But also it includes some new objectives, like Java Secure Coding Guideline. For those who plan on taking the Oracle Java Certification exam, I strongly recommend you take a look at the official exam objectives before you start your study plan. Buy a good book, I think Selikoffâ€™s book is great, I use that book for my exam preparation. Study the book chapter by chapter, or by topic, or whatever you want. Be sure to do the exercises, it will help you to consolidate your knowledge. It is also helpful to use flashcards to aid the memorization process, for example,  some core APIs or some syntax rules. Donâ€™t go directly into the quiz without studying the materials thoroughly, that will just a waste of time and energy. Because thatâ€™s very frustrating to see lots of errors. Take your time, start slowly, and gradually level up the difficulty.  Below are some useful references.&lt;/p&gt;

&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bookså‚è€ƒä¹¦ç±&quot;&gt;Books(å‚è€ƒä¹¦ç±)&lt;/h3&gt;

&lt;p&gt;I recommend : &lt;a href=&quot;https://www.amazon.com/Oracle-Certified-Professional-Programmer-Study/dp/1119617626/ref=dp_ob_title_bk&quot;&gt;OCP Oracle Certified Professional Java SE 11 Programmer II Study Guide: Exam 1Z0-816 1st Edition&lt;/a&gt; by &lt;a href=&quot;https://www.amazon.com/Scott-Selikoff/e/B00PFTZJ6G/ref=dp_byline_cont_book_1&quot;&gt;Scott Selikoff&lt;/a&gt; (Author), &lt;a href=&quot;https://www.amazon.com/Jeanne-Boyarsky/e/B00PF6JTQK/ref=dp_byline_cont_book_2&quot;&gt;Jeanne Boyarsky&lt;/a&gt; (Author)ï¼ˆThis title will be released on July 8, 2020.ï¼‰&lt;/p&gt;

&lt;p&gt;æˆ‘å»ºè®®ä½¿ç”¨è¿™æœ¬ä¹¦ä½œä¸ºè€ƒè¯•å‚è€ƒã€‚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.selikoff.net/2019/08/31/my-experience-taking-the-new-java-se-11-programmer-ii-1z0-816-exam/&quot;&gt;Selikoff Java SE 11 experience&lt;/a&gt; ä¹¦çš„ä½œè€…çš„è€ƒè¯•ç»éªŒ&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;While questions within a topic were relatively straight-forward, the amount of topics you had to know for the 1Z0-816 exam dwarfs the 1Z0-809 exam. Annotations, Security, Local Type Inference, Private/Static Interface Methods, and Modules are completely new.&lt;/p&gt;

  &lt;p&gt;å°½ç®¡è€ƒè¯•ç›¸å…³çš„ä¸»é¢˜ç›¸å¯¹æ¥è¯´æ˜¯å¾ˆç›´æ¥çš„ï¼Œä½†ä½ åœ¨ 1Z0-816 è€ƒè¯•æ‰€éœ€è¦çŸ¥é“çš„ä¸»é¢˜å†…å®¹ä½¿å¾— 1Z0-809 ç›¸å½¢è§ç»Œã€‚æ³¨è§£ã€å®‰å…¨ã€å±€éƒ¨ç±»å‹æ¨å¯¼ï¼Œæ¥å£çš„ç§æœ‰/é™æ€æ–¹æ³•ï¼Œä»¥åŠæ¨¡å—çš„å†…å®¹éƒ½æ˜¯å…¨æ–°çš„ã€‚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you have timeâ€¦ ï¼ˆæœ‰æ—¶é—´è¿˜æ¨èï¼‰ Java Language Features, Java The Complete Reference, Effective Java&lt;/p&gt;

&lt;h3 id=&quot;mock-exam-softwareæ¨¡æ‹Ÿè½¯ä»¶&quot;&gt;Mock exam software(æ¨¡æ‹Ÿè½¯ä»¶)&lt;/h3&gt;

&lt;p&gt;I used (æˆ‘ä½¿ç”¨çš„æ˜¯) &lt;a href=&quot;http://www.enthuware.com/java-certification-mock-exams/oracle-certified-professional/ocp-java-11-exam-ii-1z0-816&quot;&gt;OCP Java 11 - 1Z0-816 Mock Exams Practice Tests/Questions Part 2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;oracle-website-pageså®˜æ–¹é¡µé¢&quot;&gt;Oracle website pages(å®˜æ–¹é¡µé¢)&lt;/h3&gt;

&lt;h4 id=&quot;technicalæŠ€æœ¯ç›¸å…³&quot;&gt;Technical(æŠ€æœ¯ç›¸å…³)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Secure Coding Guidelines for Java SE&lt;/p&gt;

    &lt;p&gt;(é¡µé¢å·²ç»æ›´æ–°äº†ï¼Œæ’ç‰ˆæ¯”è¾ƒç°ä»£äº†ï¼Œè€Œä¸”å°æ ‡é¢˜æ”¹ä¸º Updated for Java SE 11 è€Œä¸æ˜¯ Java SE 13)&lt;br /&gt;
&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/seccodeguide.html&quot;&gt;Secure Coding Guidelines for Java SE&lt;/a&gt;&lt;br /&gt;
Updated for Java SE 11&lt;br /&gt;
Document version: 7.2&lt;br /&gt;
Published: 27 September 2018&lt;br /&gt;
Last updated: 7 May 2019&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Java SE 11 API docs : &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/index.html&quot;&gt;JavaÂ® Platform, Standard Edition &amp;amp; Java Development Kit Version 11 API Specification&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jls :  &lt;a href=&quot;https://docs.oracle.com/javase/specs/&quot;&gt;Java SE Specifications&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/annotations/&quot;&gt;Annotations Trail&lt;/a&gt; : Learn something new about annotations since Java 8(å­¦ä¹  Java 8 ä»¥æ¥æ›´æ–°çš„æ³¨è§£)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;About Online Proctored Exam(å…³äºåœ¨çº¿è€ƒè¯•) &lt;a href=&quot;https://players.brightcove.net/2985902027001/r1ZNvX6Ux_default/index.html?videoId=6151284095001&quot;&gt;Get Ready for your Online Proctored Exam - Oracle Certification(Video)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/oracle/onvue&quot;&gt;Oracle onvue&lt;/a&gt; Where to schedule an exam(è€ƒè¯•æŠ¥ååœ°å€  )&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/oracle/op/faqs/&quot;&gt;Online Proctoring FAQs&lt;/a&gt;  å¸¸è§é—®é¢˜&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/Documents/Online-Proctored/online-proctored-policies.aspx&quot;&gt;pearsonvue online-proctored-policies&lt;/a&gt;  åœ¨çº¿è€ƒè¯•æ”¿ç­–&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://education.oracle.com/home&quot;&gt;ç”²éª¨æ–‡å¤§å­¦&lt;/a&gt;  (Oracle University)ä¸»é¡µ&lt;/p&gt;

&lt;p&gt;Checkout more info about certification exams(å…³äºè®¤è¯è€ƒè¯•æœ¬èº«çš„ä¿¡æ¯ï¼Œæˆ‘å»ºè®®ä½ å»Oracle Universityå®˜æ–¹ç½‘ç«™çœ‹çœ‹ï¼Œè€ƒè¯•çš„ä¿¡æ¯å’Œè®¤è¯è·¯å¾„çš„ä¿¡æ¯ã€‚)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://education.oracle.com/java-se-8-programmer-i/pexam_1Z0-808&quot;&gt;OCA 808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/oracle-learning-subscription-eight-quick-tips&quot;&gt;Oracle Learning Subscriptions Eight Quick Tips&lt;/a&gt;   å®˜æ–¹è´´å£«&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/Gm1PqdbwBP0&quot;&gt;OnVUE Testing Experience&lt;/a&gt;  ä¸€ä¸ªè§†é¢‘ï¼Œåœ¨çº¿è€ƒè¯•çš„ä½“éªŒ&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/oracle-certification-exams-are-more-accessible-than-ever-before&quot;&gt;Oracle Certification Exams Are More Accessible Than Ever Before&lt;/a&gt;  åŒæ ·æ˜¯ä¸€ä¸ªå…³äºåœ¨çº¿è€ƒè¯•çš„æ–‡ç« &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/your-guide-to-oracle-certification-testing-anywhere&quot;&gt;Your Guide to Oracle Certification Testing Anywhere&lt;/a&gt;  åœ¨çº¿è€ƒè¯•æ–‡ç« &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;è€ƒè¯•å¤ä¹ å¤§çº²1z0-816-exam-objects-in-chinese&quot;&gt;è€ƒè¯•å¤ä¹ å¤§çº²(1Z0-816 exam objects in Chinese)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Java åŸºç¡€&lt;/strong&gt;&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨ &lt;code&gt;final&lt;/code&gt; ç±»&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨å†…éƒ¨ï¼ŒåµŒå¥—ï¼Œä»¥åŠåŒ¿åç±»&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨æšä¸¾&lt;br /&gt;
&lt;strong&gt;Java æ¥å£&lt;/strong&gt;&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨å¸¦æœ‰é»˜è®¤æ–¹æ³•çš„æ¥å£&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨å¸¦æœ‰ç§æœ‰æ–¹æ³•çš„æ¥å£&lt;br /&gt;
å‡½æ•°å¼æ¥å£ä¸ Lambda è¡¨è¾¾å¼&lt;br /&gt;
å®šä¹‰å¹¶ç¼–å†™å‡½æ•°å¼æ¥å£&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨ Lambda è¡¨è¾¾å¼ï¼ŒåŒ…æ‹¬ Lambda è¯­å¥ï¼Œå±€éƒ¨å˜é‡ä½œ lambda å‚æ•°&lt;br /&gt;
&lt;strong&gt;å†…ç½®å‡½æ•°å¼æ¥å£&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;java.util.function&lt;/code&gt; åŒ…é‡Œçš„æ¥å£&lt;br /&gt;
ä½¿ç”¨æ ¸å¿ƒå‡½æ•°å¼æ¥å£ï¼ŒåŒ…æ‹¬ &lt;code&gt;Predicate&lt;/code&gt;, &lt;code&gt;Consumer&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; å’Œ &lt;code&gt;Supplier&lt;/code&gt;&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;java.util.function&lt;/code&gt; åŒ…é‡ŒåŸºç¡€æ¥å£çš„åŸºæœ¬æ•°æ®ç±»å‹åŠäºŒå…ƒå˜å¼&lt;br /&gt;
&lt;strong&gt;è¿ç§»åˆ°æ¨¡å—åŒ–åº”ç”¨&lt;/strong&gt;&lt;br /&gt;
è¿ç§»ä½¿ç”¨ Java SE 9 ä»¥å‰ç‰ˆæœ¬å¼€å‘çš„åº”ç”¨åˆ° SE 11ï¼ŒåŒ…æ‹¬è‡ªä¸Šè€Œä¸‹å’Œè‡ªä¸‹è€Œä¸Šè¿ç§»æ–¹å¼ï¼Œå°†ä¸€ä¸ª Java SE 8 åº”ç”¨åˆ†æ¨¡å—ä½œè¿ç§»&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;jdeps&lt;/code&gt; ç¡®å®šä¾èµ–å…³ç³»ï¼Œå¹¶è¯†åˆ«è§£å†³å¾ªç¯ä¾èµ–çš„æ–¹æ³•ã€‚&lt;br /&gt;
&lt;strong&gt;å¹¶å‘&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Runnable&lt;/code&gt;ï¼Œ&lt;code&gt;Callable&lt;/code&gt; åˆ›å»ºå·¥ä½œçº¿ç¨‹ï¼Œå¹¶ä½¿ç”¨ &lt;code&gt;ExecutorService&lt;/code&gt; å¹¶å‘åœ°æ‰§è¡Œä»»åŠ¡&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;java.util.concurrent&lt;/code&gt; åŒ…é‡Œçš„å®¹å™¨å’Œç±»ï¼ŒåŒ…æ‹¬ &lt;code&gt;CyclicBarrier&lt;/code&gt; å’Œ &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;br /&gt;
ç¼–å†™çº¿ç¨‹å®‰å…¨çš„ä»£ç &lt;br /&gt;
è¯†åˆ«çº¿ç¨‹é—®é¢˜ï¼Œä¾‹å¦‚æ­»é”å’Œæ´»é”&lt;br /&gt;
&lt;strong&gt;I/O (åŸºç¡€ä»¥åŠ NIO2)&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨ I/O æµä»æ§åˆ¶å°å’Œæ–‡ä»¶è¯»å†™æ•°æ®&lt;br /&gt;
ä½¿ç”¨ I/O æµè¯»å†™æ–‡ä»¶&lt;br /&gt;
ä½¿ç”¨åºåˆ—åŒ–è¯»å†™å¯¹è±¡&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Path&lt;/code&gt; æ¥å£æ“ä½œæ–‡ä»¶å’Œç›®å½•è·¯å¾„&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Files&lt;/code&gt; ç±»å»æ£€æŸ¥ã€åˆ é™¤ã€å¤åˆ¶æˆ–ç§»åŠ¨ä¸€ä¸ªæ–‡ä»¶æˆ–ç›®å½•&lt;br /&gt;
ç»“åˆ &lt;code&gt;Files&lt;/code&gt; ç±»ä½¿ç”¨ Stream API&lt;br /&gt;
&lt;strong&gt;JDBC æ•°æ®åº“åº”ç”¨&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨ JDBC URLs å’Œ &lt;code&gt;DriverManager&lt;/code&gt; è¿æ¥åˆ°æ•°æ®åº“&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;PreparedStatement&lt;/code&gt; å»æ‰§è¡Œ CRUD æ“ä½œ&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;PreparedStatement&lt;/code&gt; å’Œ &lt;code&gt;CallableStatement&lt;/code&gt; APIs å»æ‰§è¡Œæ•°æ®åº“æ“ä½œ&lt;br /&gt;
&lt;strong&gt;æ³¨è§£&lt;/strong&gt;&lt;br /&gt;
è¡¨è¿°æ³¨è§£çš„ç”¨é€”ä»¥åŠå…¸å‹ä½¿ç”¨æ¨¡å¼&lt;br /&gt;
åº”ç”¨æ³¨è§£åˆ°ç±»å’Œæ–¹æ³•&lt;br /&gt;
æè¿° JDK ä¸­å¸¸ç”¨çš„æ³¨è§£&lt;br /&gt;
å£°æ˜è‡ªå®šä¹‰æ³¨è§£&lt;br /&gt;
å¼‚å¸¸å¤„ç†ä¸æ–­è¨€&lt;br /&gt;
ä½¿ç”¨ try-with-resources ç»“æ„&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨è‡ªå®šä¹‰å¼‚å¸¸ç±»&lt;br /&gt;
ä½¿ç”¨æ–­è¨€æµ‹è¯•ä¸å˜æ€§&lt;br /&gt;
&lt;strong&gt;æ³›å‹ä¸å®¹å™¨&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨åŒ…è£…ç±»ï¼Œè‡ªåŠ¨è£…ç®±å’Œè‡ªåŠ¨æ‹†ç®±&lt;br /&gt;
ç”¨é’»çŸ³è®°å·å’Œé€šé…ç¬¦åˆ›å»ºå¹¶ä½¿ç”¨æ³›å‹ç±»ã€æ–¹æ³•&lt;br /&gt;
æè¿°å®¹å™¨æ¡†æ¶å¹¶ä½¿ç”¨ä¸»è¦å®¹å™¨æ¥å£&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Comparator&lt;/code&gt; å’Œ &lt;code&gt;Comparable&lt;/code&gt; æ¥å£&lt;br /&gt;
åˆ›å»ºå¹¶ä½¿ç”¨å®¹å™¨çš„ä¾¿åˆ©æ–¹æ³•&lt;br /&gt;
&lt;strong&gt;Java Stream API&lt;/strong&gt;&lt;br /&gt;
æè¿° Stream æ¥å£å’Œç®¡é“&lt;br /&gt;
ä½¿ç”¨ lambda è¡¨è¾¾å¼å’Œæ–¹æ³•å¼•ç”¨&lt;br /&gt;
Streams ä¸Šçš„ Lambda æ“ä½œ&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt; å’Œ &lt;code&gt;flatMap&lt;/code&gt; æ–¹æ³•æå– stream æ•°æ®&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;findFirst&lt;/code&gt;, &lt;code&gt;findAny&lt;/code&gt;, &lt;code&gt;anyMatch&lt;/code&gt;, &lt;code&gt;allMatch&lt;/code&gt; å’Œ &lt;code&gt;noneMatch&lt;/code&gt; æ–¹æ³•æœç´¢ stream æ•°æ®&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Optional&lt;/code&gt; ç±»&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;average&lt;/code&gt; å’Œ &lt;code&gt;sum&lt;/code&gt; stream æ“ä½œæ‰§è¡Œè®¡ç®—&lt;br /&gt;
ä½¿ç”¨ lambda è¡¨è¾¾å¼å¯¹å®¹å™¨æ’åº&lt;br /&gt;
åœ¨ streams ä½¿ç”¨ &lt;code&gt;Collectors&lt;/code&gt; ï¼ŒåŒ…æ‹¬ &lt;code&gt;groupingBy&lt;/code&gt; å’Œ &lt;code&gt;partitioningBy&lt;/code&gt; æ“ä½œ&lt;br /&gt;
&lt;strong&gt;æ¨¡å—åŒ–åº”ç”¨ä¸­çš„æœåŠ¡&lt;/strong&gt;&lt;br /&gt;
æè¿°æœåŠ¡çš„ç»„ä»¶ï¼ŒåŒ…æ‹¬æŒ‡ä»¤&lt;br /&gt;
è®¾è®¡ä¸€ä¸ªæœåŠ¡ç±»å‹ï¼Œä½¿ç”¨ &lt;code&gt;ServiceLoader&lt;/code&gt; åŠ è½½æœåŠ¡ï¼Œæ£€æŸ¥æœåŠ¡çš„ä¾èµ–ï¼ŒåŒ…æ‹¬æ¶ˆè´¹è€…å’Œæä¾›è€…æ¨¡å—&lt;br /&gt;
&lt;strong&gt;å¹¶è¡Œ Streams&lt;/strong&gt;&lt;br /&gt;
ç¼–å†™ä½¿ç”¨å¹¶è¡Œ streams çš„ä»£ç &lt;br /&gt;
ç”¨ streams å®ç°åˆ†è§£ä¸å½’çº¦æ“ä½œ&lt;br /&gt;
&lt;strong&gt;Java SE åº”ç”¨å®‰å…¨ç¼–ç &lt;/strong&gt;&lt;br /&gt;
åœ¨ Java åº”ç”¨ä¸­é¢„é˜²æ‹’ç»æœåŠ¡&lt;br /&gt;
åœ¨ Java åº”ç”¨ä¸­ä¿æŠ¤æœºå¯†ä¿¡æ¯&lt;br /&gt;
å®ç°æ•°æ®ä¸€è‡´æ€§å‡†åˆ™â€”â€”æ³¨å…¥å’ŒåŒ…å«ä»¥åŠè¾“å…¥æ ¡éªŒ&lt;br /&gt;
é€šè¿‡é™åˆ¶å¯è®¿é—®æ€§å’Œå¯æ‰©å±•æ€§ä¿æŠ¤ä»£ç å—å¤–éƒ¨æ”»å‡»ï¼Œå¦¥å–„å¤„ç†è¾“å…¥æ ¡éªŒä»¥åŠå¯å˜æ€§&lt;br /&gt;
å®‰å…¨åœ°æ„å»ºæ•æ„Ÿå¯¹è±¡&lt;br /&gt;
ä¿æŠ¤åºåˆ—åŒ–ä¸ååºåˆ—åŒ–&lt;br /&gt;
&lt;strong&gt;æœ¬åœ°åŒ–&lt;/strong&gt;&lt;br /&gt;
ä½¿ç”¨ &lt;code&gt;Locale&lt;/code&gt; ç±»&lt;br /&gt;
ä½¿ç”¨èµ„æºåŒ…&lt;br /&gt;
ä½¿ç”¨ Java æ ¼å¼åŒ–æ¶ˆæ¯ã€æ—¥æœŸå’Œæ•°å­—&lt;/p&gt;
</description>
        <pubDate>Sun, 31 May 2020 06:32:00 +0000</pubDate>
        <link>https://zwt.io/2020/05/31/Oracle-1Z0-816-exam-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/05/31/Oracle-1Z0-816-exam-review/</guid>
        
        <category>Java</category>
        
        <category>Certification</category>
        
        
      </item>
    
      <item>
        <title>Javaç¬”è¯•é¢˜1</title>
        <description>&lt;h3 id=&quot;çœŸé¢˜1-æŸçŸ¥åäº’è”ç½‘ä¸‹è½½æœåŠ¡æä¾›å•†è½¯ä»¶å·¥ç¨‹å¸ˆç¬”è¯•é¢˜&quot;&gt;çœŸé¢˜1 æŸçŸ¥åäº’è”ç½‘ä¸‹è½½æœåŠ¡æä¾›å•†è½¯ä»¶å·¥ç¨‹å¸ˆç¬”è¯•é¢˜&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ä¸€ã€é€‰æ‹©é¢˜&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; è®¿é—®ä¿®é¥°ç¬¦ä½œç”¨èŒƒå›´ç”±å¤§åˆ°å°æ˜¯ï¼ˆ ï¼‰ã€‚&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.private-protected-default-public&lt;br /&gt;
B.public-protected-default-private&lt;br /&gt;
C.private-default-protected-public&lt;br /&gt;
D.public-default-protected-private&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;è¿™é¢˜æ²¡ä»€ä¹ˆå¥½è¯´ï¼Œå½“ç„¶æ˜¯é€‰æ‹© &lt;strong&gt;B&lt;/strong&gt; å•¦ï¼Œåˆå­¦çš„æ—¶å€™å¯èƒ½æœ‰ç‚¹éš¾è®°ä½ï¼Œä¸è¿‡ä¹ æƒ¯äº†å°±è®°ä½äº†ã€‚åæ¥è¶Šäº†è§£å°±æ›´å®¹æ˜“è®°ä½ï¼Œæ ¹æœ¬ä¸éœ€è¦æ­»è®°ç¡¬èƒŒã€‚ &lt;code&gt;default&lt;/code&gt; å…³é”®å­—ï¼Œè¡¨ç¤ºè®¿é—®æƒé™çš„æ—¶å€™ï¼Œå…¶å®æ–°çš„è§„èŒƒï¼ˆ8ä»¥ä¸Šï¼Ÿï¼‰æ”¹ç§°ä¸º â€˜package privateâ€™ å¯ä»¥ç†è§£ä¸ºåŒ…å†…ç§æœ‰è®¿é—®æƒé™ï¼Œæ‰€ä»¥é™åˆ¶ç¨‹åº¦å°±æ˜¯ä»…æ¬¡äºç§æœ‰ã€‚æ¥ç€protectedå’Œpublicå®¹æ˜“ï¼Œå› ä¸ºpublicè‚¯å®šæ˜¯èŒƒå›´æœ€å®½ï¼ˆå¤§ï¼‰çš„ã€‚&lt;br /&gt;
å…³äºç±»çš„è®¿é—®ä¿®é¥°ç¬¦çš„ä½œç”¨èŒƒå›´ï¼ŒJavaè¯­è¨€è§„èŒƒçš„ 8.1.1 èŠ‚æœ‰ï¼š&lt;br /&gt;
The access modifier &lt;code&gt;public&lt;/code&gt; pertains only to top level classes and member classes, not to local classes or anonymous classes.&lt;br /&gt;
The access modifier &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; pertain only to member classes within a directly enclosing class declaration.&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; åœ¨Java è¯­è¨€ä¸­ï¼Œä¸‹é¢æ¥å£ä»¥é”®âˆ’å€¼å¯¹çš„æ–¹å¼å­˜å‚¨å¯¹è±¡çš„æ˜¯ï¼ˆ ï¼‰ã€‚&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.java.util.List&lt;br /&gt;
B.java.util.Map&lt;br /&gt;
C.java.util.Collection&lt;br /&gt;
D.java.util.Set&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;é€‰ &lt;strong&gt;B&lt;/strong&gt; è¿™é¢˜ä¹Ÿå¾ˆç›´æ¥ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; ä»¥ä¸‹ä¸æ˜¯Object ç±»çš„æ–¹æ³•çš„æ˜¯ï¼ˆ ï¼‰ã€‚&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.hashCode()&lt;br /&gt;
B.finalize()&lt;br /&gt;
C.notify()&lt;br /&gt;
D.hasNext()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;é€‰ &lt;strong&gt;D&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; æœ‰å¦‚ä¸‹ä»£ç ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public void change(String str, char ch[]) {
        str = &quot;test ok&quot;;
        ch[0] = 'g';
    }
    public static void main(String args[]) {
      String str = new String(&quot;good&quot;);
      char[] ch = { 'a', 'b', 'c' };
      Test ex = new Test();
      ex.change(str, ch);
      System.out.print(str + &quot; and &quot;);
      System.out.print(ch);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢ç¨‹åºçš„è¿è¡Œç»“æœæ˜¯ï¼ˆ ï¼‰ã€‚&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.good and abc&lt;br /&gt;
B.good and gbc&lt;br /&gt;
C.test ok and abc&lt;br /&gt;
D.test ok and gbc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;é€‰ &lt;strong&gt;B&lt;/strong&gt; åœ¨ Java è¯­è¨€ä¸­ï¼Œé™¤äº†8 ç§åŸå§‹çš„æ•°æ®ç±»å‹ï¼ˆåˆ†åˆ«ä¸º &lt;code&gt;byte&lt;/code&gt;ã€&lt;code&gt;short&lt;/code&gt;ã€&lt;code&gt;int&lt;/code&gt;ã€&lt;code&gt;long&lt;/code&gt;ã€&lt;code&gt;float&lt;/code&gt;ã€&lt;code&gt;double&lt;/code&gt;ã€&lt;code&gt;char&lt;/code&gt; å’Œ &lt;code&gt;boolean&lt;/code&gt;ï¼‰å¤–ï¼Œå…¶ä»–çš„ç±»å‹éƒ½æ˜¯å¯¹è±¡ï¼Œåœ¨æ–¹æ³•è°ƒç”¨çš„æ—¶å€™ï¼Œä¼ é€’çš„éƒ½æ˜¯å¼•ç”¨ã€‚å¼•ç”¨ä»æœ¬è´¨ä¸Šæ¥è®²ä¹Ÿæ˜¯æŒ‰å€¼ä¼ é€’ï¼Œåªä¸è¿‡ä¼ é€’çš„è¿™ä¸ªå€¼æ˜¯å¯¹è±¡çš„å¼•ç”¨è€Œå·²ï¼Œå› æ­¤ï¼Œåœ¨æ–¹æ³•è°ƒç”¨çš„æ—¶å€™ï¼Œå¯¹å½¢å‚å¼•ç”¨æ‰€æŒ‡å¯¹è±¡å±æ€§å€¼çš„ä¿®æ”¹å¯¹å®å‚å¯è§ã€‚ä½†æ˜¯å¯¹å¼•ç”¨å€¼æœ¬èº«çš„ä¿®æ”¹å¯¹å®å‚æ˜¯ä¸å¯è§çš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;äºŒã€å¡«ç©ºé¢˜&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; &lt;code&gt;Math.round(12.5)&lt;/code&gt; çš„è¿”å›å€¼ç­‰äºï¼ˆ &lt;strong&gt;13&lt;/strong&gt; ï¼‰ï¼Œ&lt;code&gt;Math.round(-12.5)&lt;/code&gt; çš„è¿”å›å€¼ç­‰äºï¼ˆ &lt;strong&gt;-12&lt;/strong&gt; ï¼‰ã€‚&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;round&lt;/code&gt; æ˜¯ä¸€ä¸ªå››èˆäº”å…¥çš„æ–¹æ³•ï¼Œ12.5 çš„å°æ•°éƒ¨åˆ†ä¸º 0.5ï¼Œå½“å¯¹å…¶æ‰§è¡Œ &lt;code&gt;Math.round()&lt;/code&gt; æ“ä½œæ—¶ï¼Œç»“æœéœ€è¦å››èˆäº”å…¥ï¼Œæ‰€ä»¥ï¼Œç»“æœä¸º 13ï¼›âˆ’12.5 çš„å°æ•°éƒ¨åˆ†ä¹Ÿä¸º 0.5ï¼Œå½“å¯¹
å…¶æ‰§è¡Œ &lt;code&gt;Math.round()&lt;/code&gt; æ“ä½œæ—¶ï¼Œç»“æœä¹Ÿéœ€è¦å››èˆäº”å…¥ï¼Œç”±äº âˆ’12 &amp;gt; âˆ’13ï¼Œå› æ­¤ï¼Œç»“æœä¸º âˆ’12ã€‚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; æœ‰å¦‚ä¸‹ç¨‹åºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str1 = &quot;hello world&quot;;
String str2 = &quot;hello&quot; + new String(&quot;world&quot;);
System.out.println(str1 == str2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é‚£ä¹ˆç¨‹åºçš„è¿è¡Œç»“æœæ˜¯ï¼ˆ &lt;strong&gt;false&lt;/strong&gt; ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; åœ¨Java è¯­è¨€ä¸­ï¼ŒåŸºæœ¬æ•°æ®ç±»å‹åŒ…æ‹¬ï¼ˆ æµ®ç‚¹å‹ floatã€double ï¼‰ã€å­—ç¬¦ç±»å‹ï¼ˆ char ï¼‰ã€å¸ƒå°”ç±»å‹ boolean å’Œ æ•°å€¼ç±»å‹ï¼ˆbyteã€shortã€intã€long ï¼‰ã€‚&lt;br /&gt;
&lt;strong&gt;4.&lt;/strong&gt; å­—ç¬¦ä¸²åˆ†ä¸ºä¸¤å¤§ç±»ï¼šä¸€ç±»æ˜¯å­—ç¬¦ä¸²å¸¸é‡ï¼ˆ String ï¼‰ï¼›å¦ä¸€ç±»æ˜¯å­—ç¬¦ä¸²å˜é‡ï¼ˆ StringBuffer ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ä¸‰ã€ç®€ç­”é¢˜&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; æ¥å£å’ŒæŠ½è±¡ç±»æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆï¼šæ¥å£ï¼ˆinterfaceï¼‰å’ŒæŠ½è±¡ç±»ï¼ˆabstract classï¼‰æ˜¯æ”¯æŒæŠ½è±¡ç±»å®šä¹‰çš„ä¸¤ç§æœºåˆ¶ï¼ˆæ³¨æ„ï¼Œè¯¥å¥ä¸­å‰åä¸¤ä¸ªæŠ½è±¡ç±»çš„æ„ä¹‰ä¸ä¸€æ ·ï¼Œå‰è€…è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå®ä½“ï¼Œåè€…è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæ¦‚å¿µï¼‰ã€‚&lt;br /&gt;
ä¸¤è€…å…·æœ‰å¾ˆå¤§çš„ç›¸ä¼¼æ€§ï¼Œç”šè‡³æœ‰æ—¶å€™æ˜¯å¯ä»¥äº’æ¢çš„ã€‚ä½†åŒæ—¶ï¼Œä¸¤è€…ä¹Ÿå­˜åœ¨å¾ˆå¤§çš„åŒºåˆ«ã€‚å…·ä½“è€Œè¨€ï¼Œæ¥å£æ˜¯å…¬å¼€çš„ï¼Œé‡Œé¢ä¸èƒ½æœ‰ç§æœ‰çš„æ–¹æ³•æˆ–å˜é‡ï¼Œæ˜¯ç”¨äºè®©åˆ«äººä½¿ç”¨çš„ï¼Œè€ŒæŠ½è±¡ç±»æ˜¯å¯ä»¥æœ‰ç§æœ‰æ–¹æ³•æˆ–ç§æœ‰å˜é‡çš„ï¼Œå¦‚æœä¸€ä¸ªç±»ä¸­åŒ…å«æŠ½è±¡æ–¹æ³•ï¼Œé‚£ä¹ˆè¿™ä¸ªç±»å°±æ˜¯æŠ½è±¡ç±»ã€‚åœ¨Java è¯­è¨€ä¸­ï¼Œå¯ä»¥é€šè¿‡æŠŠç±»æˆ–è€…ç±»ä¸­çš„æŸäº›æ–¹æ³•å£°æ˜ä¸ºabstractï¼ˆabstract åªèƒ½ç”¨æ¥ä¿®é¥°ç±»æˆ–è€…æ–¹æ³•ï¼Œä¸èƒ½ç”¨æ¥ä¿®é¥°å±æ€§ï¼‰æ¥è¡¨ç¤ºä¸€ä¸ªç±»æ˜¯æŠ½è±¡ç±»ã€‚æ¥å£å°±æ˜¯æŒ‡ä¸€ä¸ªæ–¹æ³•çš„é›†åˆï¼Œæ¥å£ä¸­çš„æ‰€æœ‰æ–¹æ³•éƒ½æ²¡æœ‰æ–¹æ³•ä½“ï¼Œåœ¨Java è¯­è¨€ä¸­ï¼Œæ¥å£æ˜¯é€šè¿‡å…³é”®å­—interface æ¥å®ç°çš„ã€‚åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæŠ½è±¡æ–¹æ³•çš„ç±»å°±å¿…é¡»è¢«å£°æ˜ä¸ºæŠ½è±¡ç±»ï¼ŒæŠ½è±¡ç±»å¯ä»¥å£°æ˜æ–¹æ³•çš„å­˜åœ¨è€Œä¸å»å®ç°å®ƒï¼Œè¢«å£°æ˜ä¸ºæŠ½è±¡çš„æ–¹æ³•ä¸èƒ½åŒ…å«æ–¹æ³•ä½“ã€‚åœ¨æŠ½è±¡ç±»çš„å­ç±»ä¸­ï¼Œå®ç°æ–¹æ³•å¿…é¡»å«æœ‰ç›¸åŒçš„æˆ–è€…æ›´ä½çš„è®¿é—®çº§åˆ«ï¼ˆpublic-&amp;gt;protected-&amp;gt;privateï¼‰ã€‚æŠ½è±¡ç±»åœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ä¸èƒ½è¢«å®ä¾‹åŒ–ï¼Œä½†æ˜¯å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯¹è±¡ä½¿å…¶æŒ‡å‘å…·ä½“å­ç±»çš„ä¸€ä¸ªå®ä¾‹ã€‚æŠ½è±¡ç±»çš„å­ç±»ä¸ºçˆ¶ç±»ä¸­æ‰€æœ‰çš„æŠ½è±¡æ–¹æ³•æä¾›å…·ä½“çš„å®ç°ï¼Œå¦åˆ™ï¼Œå®ƒä»¬ä¹Ÿæ˜¯æŠ½è±¡ç±»ã€‚æ¥å£å¯ä»¥è¢«çœ‹ä½œæ˜¯æŠ½è±¡ç±»çš„å˜ä½“ï¼Œæ¥å£ä¸­æ‰€æœ‰çš„æ–¹æ³•éƒ½æ˜¯æŠ½è±¡çš„ï¼Œå¯ä»¥é€šè¿‡æ¥å£æ¥é—´æ¥åœ°å®ç°å¤šé‡ç»§æ‰¿ã€‚æ¥å£ä¸­çš„æˆå‘˜å˜é‡éƒ½æ˜¯static final
ç±»å‹ï¼Œç”±äºæŠ½è±¡ç±»å¯ä»¥åŒ…å«éƒ¨åˆ†æ–¹æ³•çš„å®ç°ï¼Œæ‰€ä»¥ï¼Œåœ¨ä¸€äº›åœºåˆä¸‹æŠ½è±¡ç±»æ¯”æ¥å£å­˜åœ¨æ›´å¤šçš„ä¼˜åŠ¿ã€‚æ¥å£ä¸æŠ½è±¡ç±»çš„ç›¸åŒç‚¹å¦‚ä¸‹ï¼š&lt;br /&gt;
1ï¼‰éƒ½ä¸èƒ½è¢«å®ä¾‹åŒ–ã€‚&lt;br /&gt;
2ï¼‰æ¥å£çš„å®ç°ç±»æˆ–æŠ½è±¡ç±»çš„å­ç±»éƒ½åªæœ‰å®ç°äº†æ¥å£æˆ–æŠ½è±¡ç±»ä¸­çš„æ–¹æ³•åæ‰èƒ½è¢«å®ä¾‹åŒ–ã€‚&lt;br /&gt;
æ¥å£ä¸æŠ½è±¡ç±»çš„ä¸åŒç‚¹å¦‚ä¸‹ï¼š&lt;br /&gt;
1ï¼‰æ¥å£åªæœ‰å®šä¹‰ï¼Œä¸èƒ½æœ‰æ–¹æ³•çš„å®ç°ï¼Œè€ŒæŠ½è±¡ç±»å¯ä»¥æœ‰å®šä¹‰ä¸å®ç°ï¼Œå³å…¶æ–¹æ³•å¯ä»¥åœ¨æŠ½è±¡ç±»ä¸­è¢«å®ç°ã€‚&lt;br /&gt;
2ï¼‰å®ç°æ¥å£çš„å…³é”®å­—ä¸ºimplementsï¼Œç»§æ‰¿æŠ½è±¡ç±»çš„å…³é”®å­—ä¸ºextendsã€‚ä¸€ä¸ªç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£ï¼Œä½†ä¸€ä¸ªç±»åªèƒ½ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå› æ­¤ï¼Œä½¿ç”¨æ¥å£å¯ä»¥é—´æ¥åœ°è¾¾åˆ°å¤šé‡ç»§æ‰¿çš„ç›®çš„ã€‚&lt;br /&gt;
3ï¼‰æ¥å£å¼ºè°ƒç‰¹å®šåŠŸèƒ½çš„å®ç°ï¼Œå…¶è®¾è®¡ç†å¿µæ˜¯â€œhas-aâ€å…³ç³»ï¼Œè€ŒæŠ½è±¡ç±»å¼ºè°ƒæ‰€å±å…³ç³»ï¼Œå…¶è®¾è®¡ç†å¿µä¸ºâ€œis-aâ€å…³ç³»ã€‚&lt;br /&gt;
4ï¼‰æ¥å£ä¸­å®šä¹‰çš„æˆå‘˜å˜é‡é»˜è®¤ä¸ºpublic static finalï¼Œåªèƒ½å¤Ÿæœ‰é™æ€çš„ä¸èƒ½è¢«ä¿®æ”¹çš„æ•°æ®æˆå‘˜ï¼Œè€Œä¸”ï¼Œå¿…é¡»ç»™å…¶èµ‹åˆå€¼ï¼Œå…¶æ‰€æœ‰çš„æˆå‘˜æ–¹æ³•éƒ½æ˜¯publicã€abstract çš„ï¼Œè€Œä¸”åªèƒ½è¢«è¿™ä¸¤ä¸ªå…³é”®å­—ä¿®é¥°ã€‚è€ŒæŠ½è±¡ç±»å¯ä»¥æœ‰è‡ªå·±çš„æ•°æ®æˆå‘˜å˜é‡ï¼Œä¹Ÿå¯ä»¥æœ‰éæŠ½è±¡çš„æˆå‘˜æ–¹æ³•ï¼Œè€Œä¸”ï¼ŒæŠ½è±¡ç±»ä¸­çš„æˆå‘˜å˜é‡é»˜è®¤ä¸ºdefaultï¼Œå½“ç„¶ä¹Ÿå¯ä»¥è¢«å®šä¹‰ä¸ºprivateã€protected å’Œpublicï¼Œè¿™äº›æˆå‘˜å˜é‡å¯ä»¥åœ¨å­ç±»ä¸­è¢«é‡æ–°å®šä¹‰ï¼Œä¹Ÿå¯ä»¥è¢«é‡æ–°èµ‹å€¼ï¼ŒæŠ½è±¡ç±»ä¸­çš„æŠ½è±¡æ–¹æ³•ï¼ˆå…¶å‰æœ‰abstractä¿®é¥°ï¼‰ä¸èƒ½ç”¨privateã€staticã€synchronized å’Œnative ç­‰è®¿é—®ä¿®é¥°ç¬¦ä¿®é¥°ï¼ŒåŒæ—¶æ–¹æ³•å¿…é¡»ä»¥åˆ†å·ç»“å°¾ï¼Œå¹¶ä¸”ä¸å¸¦èŠ±æ‹¬å·{}ã€‚æ‰€ä»¥ï¼Œå½“åŠŸèƒ½éœ€è¦ç´¯ç§¯æ—¶ï¼Œä½¿ç”¨æŠ½è±¡ç±»ï¼›ä¸éœ€è¦ç´¯ç§¯æ—¶ï¼Œä½¿ç”¨æ¥å£ã€‚&lt;br /&gt;
5ï¼‰æ¥å£è¢«è¿ç”¨äºå®ç°æ¯”è¾ƒå¸¸ç”¨çš„åŠŸèƒ½ï¼Œä¾¿äºæ—¥åç»´æŠ¤æˆ–è€…æ·»åŠ åˆ é™¤æ–¹æ³•ï¼Œè€ŒæŠ½è±¡ç±»æ›´å€¾å‘äºå……å½“å…¬å…±ç±»çš„è§’è‰²ï¼Œä¸é€‚ç”¨äºæ—¥åé‡æ–°å¯¹é‡Œé¢çš„ä»£ç è¿›è¡Œä¿®æ”¹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; å®ç°å¤šçº¿ç¨‹çš„æ–¹æ³•æœ‰å“ªå‡ ç§ï¼Ÿ&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆï¼šJava è™šæ‹Ÿæœºï¼ˆJava Virtual Machineï¼ŒJVMï¼Œæ˜¯è¿è¡Œæ‰€æœ‰Java ç¨‹åºçš„æŠ½è±¡è®¡ç®—æœºï¼Œæ˜¯Java è¯­è¨€çš„è¿è¡Œç¯å¢ƒï¼‰å…è®¸åº”ç”¨ç¨‹åºå¹¶å‘åœ°è¿è¡Œå¤šä¸ªçº¿ç¨‹ã€‚åœ¨Java è¯­è¨€ä¸­ï¼Œå¤šçº¿ç¨‹çš„å®ç°ä¸€èˆ¬æœ‰ä»¥ä¸‹ä¸‰ç§æ–¹æ³•ï¼š&lt;br /&gt;
1ï¼‰å®ç°Runnable æ¥å£ï¼Œå¹¶å®ç°è¯¥æ¥å£çš„run()æ–¹æ³•ã€‚&lt;br /&gt;
ä»¥ä¸‹æ˜¯ä¸»è¦æ­¥éª¤ï¼š
â‘  è‡ªå®šä¹‰ç±»å¹¶å®ç°Runnable æ¥å£ï¼Œå®ç°run()æ–¹æ³•ã€‚&lt;br /&gt;
â‘¡ åˆ›å»ºThread å¯¹è±¡ï¼Œç”¨å®ç°Runnable æ¥å£çš„å¯¹è±¡ä½œä¸ºå‚æ•°å®ä¾‹åŒ–è¯¥Thread å¯¹è±¡ã€‚&lt;br /&gt;
â‘¢ è°ƒç”¨Thread çš„start()æ–¹æ³•ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; åˆ©ç”¨é€’å½’æ–¹æ³•æ±‚6!&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆï¼šæœ¬é¢˜è€ƒæŸ¥çš„æ˜¯é€’å½’çŸ¥è¯†ã€‚&lt;/p&gt;

&lt;p&gt;ä½¿ç”¨é€’å½’æ—¶ï¼Œå…³é”®é—®é¢˜æ˜¯è¦æ˜ç™½é€’å½’è¡¨è¾¾å¼çš„å«ä¹‰ä»¥åŠé€’å½’çš„ç»ˆæ­¢æ¡ä»¶ã€‚&lt;/p&gt;

&lt;p&gt;å®ç°ä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static long fac(int n) {
        if(n &amp;gt; 1)
            return (n * fac(n - 1));
        else
            return 1;
    }
    public static void main(String[] args) {
        System.out.println(fac(6));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç¨‹åºè¿è¡Œçš„ç»“æœä¸º&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;720&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; ç”¨Java è¯­è¨€å®ç°ä¸€ä¸ªè§‚å¯Ÿè€…æ¨¡å¼ã€‚&lt;br /&gt;
ç­”æ¡ˆï¼šè§‚å¯Ÿè€…æ¨¡å¼ï¼ˆä¹Ÿè¢«ç§°ä¸ºå‘å¸ƒ/è®¢é˜…æ¨¡å¼ï¼‰æä¾›äº†é¿å…ç»„ä»¶ä¹‹é—´ç´§å¯†è€¦åˆçš„å¦ä¸€ç§æ–¹æ³•ï¼Œå®ƒå°†è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿçš„å¯¹è±¡åˆ†ç¦»å¼€ã€‚åœ¨è¯¥æ¨¡å¼ä¸­ï¼Œä¸€ä¸ªå¯¹è±¡é€šè¿‡æ·»åŠ ä¸€ä¸ªæ–¹æ³•ï¼ˆè¯¥æ–¹æ³•å…è®¸å¦ä¸€ä¸ªå¯¹è±¡ï¼Œå³è§‚å¯Ÿè€…æ³¨å†Œè‡ªå·±ï¼‰ä½¿æœ¬èº«å˜å¾—å¯è§‚å¯Ÿã€‚å½“å¯è§‚å¯Ÿçš„å¯¹è±¡æ›´æ”¹æ—¶ï¼Œå®ƒä¼šå°†æ¶ˆæ¯å‘é€åˆ°å·²æ³¨å†Œçš„è§‚å¯Ÿè€…ã€‚è¿™äº›è§‚å¯Ÿè€…æ”¶åˆ°æ¶ˆæ¯åæ‰€æ‰§è¡Œçš„æ“ä½œä¸å¯è§‚å¯Ÿçš„å¯¹è±¡æ— å…³ï¼Œè¿™ç§æ¨¡å¼ä½¿å¾—å¯¹è±¡å¯ä»¥ç›¸äº’å¯¹è¯ï¼Œè€Œä¸å¿…äº†è§£åŸå› ã€‚Java è¯­è¨€ä¸C#è¯­è¨€çš„äº‹ä»¶å¤„ç†æœºåˆ¶å°±æ˜¯é‡‡ç”¨çš„æ­¤ç§è®¾è®¡æ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·ç•Œé¢ï¼ˆåŒä¸€ä¸ªæ•°æ®å¯ä»¥æœ‰å¤šç§ä¸åŒçš„æ˜¾ç¤ºæ–¹å¼ï¼‰å¯ä»¥ä½œä¸ºè§‚å¯Ÿè€…ï¼Œä¸šåŠ¡æ•°æ®æ˜¯è¢«è§‚å¯Ÿè€…ï¼Œå½“æ•°æ®æœ‰å˜åŒ–åä¼šé€šçŸ¥ç•Œé¢ï¼Œç•Œé¢æ”¶åˆ°é€šçŸ¥åï¼Œä¼šæ ¹æ®è‡ªå·±çš„æ˜¾ç¤ºæ–¹å¼ä¿®æ”¹ç•Œé¢çš„æ˜¾ç¤ºã€‚é¢å‘å¯¹è±¡è®¾è®¡çš„ä¸€ä¸ªåŸåˆ™æ˜¯ï¼šç³»ç»Ÿä¸­çš„æ¯ä¸ªç±»å°†é‡ç‚¹æ”¾åœ¨æŸä¸€ä¸ªåŠŸèƒ½ä¸Šï¼Œè€Œä¸æ˜¯å…¶ä»–æ–¹é¢ã€‚ä¸€ä¸ªå¯¹è±¡åªåšä¸€ä»¶äº‹æƒ…ï¼Œå¹¶ä¸”å°†å®ƒåšå¥½ã€‚è§‚å¯Ÿè€…æ¨¡å¼åœ¨æ¨¡å—ä¹‹é—´åˆ’å®šäº†æ¸…æ™°çš„ç•Œé™ï¼Œæé«˜äº†åº”ç”¨ç¨‹åºçš„å¯ç»´æŠ¤æ€§å’Œé‡ç”¨æ€§ã€‚è®¾è®¡ç±»å›¾å¦‚å›¾1 æ‰€ç¤ºã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/image-20200531042853475.png&quot; alt=&quot;image-20200531042853475&quot; /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;å›¾1ğŸ‘†&lt;/div&gt;

&lt;p&gt;å…·ä½“çš„å®ç°ä»£ç çš„ç»§æ‰¿å…³ç³»å¦‚å›¾2æ‰€ç¤ºï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/observer-pattern.png&quot; alt=&quot;observer-pattern&quot; /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;å›¾2ğŸ‘†&lt;/div&gt;

&lt;p&gt;ä¸‹é¢ç»™å‡ºä¸€ä¸ªè§‚å¯Ÿè€…æ¨¡å¼çš„ç¤ºä¾‹ä»£ç ï¼Œä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯å®ç°å¤©æ°”é¢„æŠ¥ï¼ŒåŒæ ·çš„æ¸©åº¦ä¿¡æ¯å¯ä»¥æœ‰å¤šç§ä¸åŒçš„å±•ç¤ºæ–¹å¼ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public interface Observer {

    // æ›´æ–°æ¸©åº¦
    void update(float temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

import java.util.ArrayList;

public class Whether implements Subject {

    private final ArrayList&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;&amp;gt;();
    private float temperature;

    @Override
    public void registerObserver(Observer o) {
        this.observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        this.observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : this.observers) {
            observer.update(temperature);
        }
    }

    public void whetherChange() {
        this.notifyObservers();
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
        notifyObservers();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public class WhetherDisplay1 implements Observer {

    private float temperature;

    public WhetherDisplay1(Subject whether) {
        whether.registerObserver(this);
    }

    @Override
    public void update(float temp) {
        this.temperature = temp;
        display();
    }

    private void display() {
        System.out.println(&quot;display1****:&quot; + this.temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public class WhetherDisplay2 implements Observer {

    private float temperature;

    public WhetherDisplay2(Subject whether) {
        whether.registerObserver(this);
    }

    @Override
    public void update(float temp) {
        this.temperature = temp;
        display();
    }

    private void display() {
        System.out.println(&quot;display1----:&quot; + this.temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; ä¸€ä¸ªæœ‰10 äº¿æ¡è®°å½•çš„æ–‡æœ¬æ–‡ä»¶ï¼Œå·²æŒ‰ç…§å…³é”®å­—æ’å¥½åºå­˜å‚¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå¯ä»¥ä»æ–‡ä»¶ä¸­å¿«é€ŸæŸ¥æ‰¾æŒ‡å®šå…³é”®å­—çš„è®°å½•ã€‚&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆ: 10 äº¿æ¡è®°å½•å¯¹åº”çš„æ•°é‡åœ¨ GB é‡çº§,å¯¹äºæ™®é€šçš„è®¡ç®—æœºæ¥è®²,æ²¡æœ‰è¿™ä¹ˆå¤§çš„å†…å­˜ç©ºé—´ä¾›ä½¿ç”¨,å› æ­¤,æ— æ³•ä¸€æ¬¡æŠŠè¿™äº›æ•°æ®ä¿¡æ¯å…¨éƒ¨éƒ½è¯»åˆ°å†…å­˜ä¸­è¿›è¡Œå¤„ç†,éœ€è¦å¯¹é—®é¢˜è¿›è¡Œåˆ†è§£,ä¾‹å¦‚æŠŠæ•°æ®åˆ†æˆ 100 ä»½,æ¯ä¸€ä»½å°±æ˜¯ 100MB é‡çº§,åŸºæœ¬ä¸Šæ”¾å…¥å†…å­˜æ— å‹åŠ›äº†.&lt;/p&gt;

&lt;p&gt;æŠŠè¿™ 10 äº¿æ¡è®°å½•,å‡åˆ†ä¸º 100 ä»½, æŠŠæ¯ä»½çš„ç¬¬ä¸€æ¡è®°å½•å…³é”®å­—å’Œæ­¤çºªå½•å¯¹åº”çš„æ–‡ä»¶åç§»é‡å…ˆæ‰«å…¥å†…å­˜(ç±»ä¼¼ç´¢å¼•),è¿™é‡Œéœ€è¦ç£ç›˜éšæœº IO 100 æ¬¡.&lt;/p&gt;

&lt;p&gt;è¿™æ ·å¯ä»¥é©¬ä¸Šå®šä½å‡ºæŒ‡å®šå…³é”®å­—æ‰€åœ¨çš„è®°å½•å—,æŠŠç›¸åº”çš„è®°å½•å—æ‹¿åˆ°å†…å­˜,äºŒåˆ†æŸ¥æ‰¾å³å¯.&lt;/p&gt;
</description>
        <pubDate>Sun, 10 May 2020 20:02:00 +0000</pubDate>
        <link>https://zwt.io/2020/05/10/java-interview-test1/</link>
        <guid isPermaLink="true">https://zwt.io/2020/05/10/java-interview-test1/</guid>
        
        <category>Java ç¬”è¯•</category>
        
        
      </item>
    
      <item>
        <title>OCP-1Z0-816æ¨¡æ‹Ÿæµ‹è¯•2å›é¡¾</title>
        <description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Given&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Booby {
}
class Dooby extends Booby {
}
class Tooby extends Dooby {
}

public class TestClass {
  Booby b = new Booby();
  Tooby t = new Tooby();
  public void do1(List&amp;lt;? super Dooby&amp;gt; dataList) {
    //1 INSERT CODE HERE
  }
  public void do2(List&amp;lt;? extends Dooby&amp;gt; dataList) {
    //2 INSERT CODE HERE
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the following four statements:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;b = dataList.get(0);&lt;/li&gt;
  &lt;li&gt;t = dataList.get(0);&lt;/li&gt;
  &lt;li&gt;dataList.add(b);&lt;/li&gt;
  &lt;li&gt;dataList.add(t);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What can be inserted in the above code?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 1 and 3 can inserted at //1 and Statements 2 and 4 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Statement 4 can inserted at //1 and Statement 1 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 3 and 4 can inserted at //1 and Statements 1 and 2 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 1 and 2 can inserted at //1 and Statements 3 and 4 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statement 1 can inserted at //1 and Statement 4 can be inserted at //2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;addData1(List&amp;lt;? super Dooby&amp;gt; dataList)&lt;/code&gt;&lt;br /&gt;
This means that dataList is a List whose elements are of a class that is either Dooby or a super class of Dooby. We donâ€™t know which super class of Dooby. Thus, if you try to add any object to dataList, it has to be a assignable to Dooby.&lt;br /&gt;
Thus, &lt;code&gt;dataList.add(b);&lt;/code&gt; will be invalid because b is not assignable to Dooby.&lt;br /&gt;
Further, if you try to take some object out of dataList, that object will be of a class that is either Dooby or a Superclass of Dooby. Only way you can declare a variable that can be assigned the object retrieved from dataList is Object obj. Thus, &lt;code&gt;t = dataList.get(0);&lt;/code&gt; and &lt;code&gt;b = dataList.get(0);&lt;/code&gt; are both invalid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;addData2(List&amp;lt;? extends Dooby&amp;gt; dataList)&lt;/code&gt;&lt;br /&gt;
This means that dataList is a List whose elements are of a class that is either Dooby or a subclass of Dooby. Since we donâ€™t know which subclass of Dooby is the list composed of, there is no way you can add any object to this list.&lt;br /&gt;
If you try to take some object out of dataList, that object will be of a class that is either Dooby or a subclass of Dooby and thus it can be assigned to a variable of class Dooby or its superclass.. Thus, &lt;code&gt;t = dataList.get(0);&lt;/code&gt; is invalid.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;æ³›å‹è§„åˆ™ï¼ˆJLSï¼‰&lt;/strong&gt;&lt;br /&gt;
A type argument $T_1$ is said to contain another type argument $T_2$, written $T_2 &amp;lt;= T_1$, is the set of types denoted by $T_2$ is provably a subset of the set of types denoted by $T_1$ under the reflexive and transitive closure of the following rules(where $&amp;lt;:$ denotes subtyping($\S4.10$)):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$?\space extends\space T&amp;lt;=\space ?\space extends \space S$ if $T &amp;lt;: S$&lt;/li&gt;
  &lt;li&gt;$?\space extends \space T&amp;lt;=\space ?$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ?\space super \space S$  if $T &amp;lt;: S$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ?$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ? \space extends \space Object$&lt;/li&gt;
  &lt;li&gt;$ T&amp;lt;=\space T$&lt;/li&gt;
  &lt;li&gt;$T &amp;lt;= \space ? \space extends \space T$&lt;/li&gt;
  &lt;li&gt;$T &amp;lt;= \space ? \space super \space T$&lt;br /&gt;
&lt;!--more--&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;
Given the following RDBMS table information :&lt;br /&gt;
STUDENT Table&lt;br /&gt;
SID INT Primary Key NAME VARCHAR(50)&lt;br /&gt;
GPA INT&lt;br /&gt;
and the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Statement stmt = connection.createStatement();  
ResultSet rs = stmt.executeQuery(&quot;select SID, NAME,  GPA from STUDENT&quot;);  
while(rs.next()){  
  System.out.println( INSERT CODE HERE );  
}  
connection.close();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What can be inserted in the above code so that it will print the GPA value for each student?  (Assume that items not specified such as import statements and try/catch block are all valid.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getString(2)
    &lt;blockquote&gt;
      &lt;p&gt;The numbering of columns in a ResultSet stars with 1. Therefore, it should be rs.getString(3).&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;rs.getString(3)
    &lt;blockquote&gt;
      &lt;p&gt;Although the value of the GPA field is int, it can still be retrieved using getString().&lt;br /&gt;
Note that if a field is of type VARCHAR and if you try to retrieve the value using say getInt(), it may throw an exception at runtime if the value cannot be parsed into an Integer.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getInt(2)
    &lt;blockquote&gt;
      &lt;p&gt;The numbering of columns in a ResultSet starts with 1. Therefore, it should be rs.getInt(3).&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getInteger(2)&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;rs.getInt(â€œGPAâ€)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Item {
  private int id;
  private String name;
  public Item(int id, String name) {
    this.id = id;
    this.name = name;
  }
  public Integer getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public String toString() {
    return name;
  }
}

public class Test {
  public static void main(String[] args) {
    List&amp;lt;Item&amp;gt; l = Arrays.asList(
          new Item(1, &quot;Screw&quot;),
          new Item(2, &quot;Nail&quot;),
          new Item(3, &quot;Bolt&quot;)
    );
    l.stream()
    // INSERT CODE HERE
    .forEach(System.out::print);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options can be inserted in the above code independent of each other, so that the code will print BoltNailScrew?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;.sorted((a, b)-&amp;gt;a.getId().compareTo(b.getId()))
    &lt;blockquote&gt;
      &lt;p&gt;This option creates a Comparator using a lambda expression that compares two Item objects for their id attribute. Syntactically, this option is correct but we need to sort by name instead of id.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;.sorted(Comparator.comparing(a-&amp;gt;a.getName())).map((i)-&amp;gt;i.getName())
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;This option uses Comparatorâ€™s comparing method that accepts a function that extracts a Comparable sort key, and returns a Comparator that compares by that sort key. Note that this is helpful only if the type of the object returned by the function implements Comparable. Here, it returns a String, which does implement Comparable and so it is ok.&lt;/li&gt;
        &lt;li&gt;Although the map part is not required because Item class overrides the toString method to print the name anyway, it is valid.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;.map((i)-&amp;gt;i.getName())
    &lt;blockquote&gt;
      &lt;p&gt;Just mapping the Items to their names will not help because we need to sort the elements as well.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;.map((i)-&amp;gt;i.getName()).sorted()
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;The call to map converts the stream of Items to a stream of Strings.&lt;/li&gt;
        &lt;li&gt;The call to sorted() sorts the stream of String by their natural order, which is what we want here.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; ls = Arrays.asList(3,4,6,9,2,5,7);
System.out.println(ls.stream().reduce(Integer.MIN_VALUE, (a, b)-&amp;gt;a&amp;gt;b?a:b)) //1
System.out.println(ls.stream().max(Integer::max).get()); //2
System.out.println(ls.stream().max(Integer::compare).get()); //3
System.out.println(ls.stream().max((a, b)-&amp;gt;a&amp;gt;b?a:b)); //4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the above statements will print 9?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;1 and 4&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2 and 3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;1 and 3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2,3, and 4&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;All of them.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The code will print:&lt;/p&gt;

&lt;p&gt;9&lt;br /&gt;
3&lt;br /&gt;
9&lt;br /&gt;
Optional[3]&lt;/p&gt;

&lt;p&gt;You need to understand the following points to answer this question:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The reduce method needs a BinaryOperator. This interface is meant to consume two arguments and produce one output. It is applied repeatedly on the elements in the stream until only one element is left. The first argument is used to provide an initial value to start the process. (If you donâ€™t pass this argument, a different reduce method will be invoked and that returns an Optional object. )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The Stream.max method requires a Comparator. All you need to implement this interface using a lambda expression is a reference to any method that takes two arguments and returns an int. The name of the method doesnâ€™t matter. That is why it is possible to pass the reference of Integerâ€™s max method as an argument to Streamâ€™s max method. However, Integer.max works very differently from Integer.compare. The max method returns the maximum of two numbers while the compare method returns a difference between two numbers. Therefore, when you pass Integer::max to Streamâ€™s max, you will not get the correct maximum element from the stream. That is why //2 will compile but will not work correctly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//4 is basically same as //2. It will not work correctly for the same reason.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String[] params() default {&quot;&quot;};
    String date() default &quot;&quot;;
    int depth() default 10;
    String value() ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) x) -&amp;gt;{ System.out.println(x);});&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is possible to annotate lambda parameters but to do that the type of the lambda parameter must be specified.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) var x) -&amp;gt;{ System.out.println(x);});&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Normally, when a lambda express requires only a single parameter, you donâ€™t need to specify its type because it can be inferred by the compiler. However, in that case, you cannot apply an annotation to it. To be able to apply an annotation and to get the benefit of type inferencing, you can specify the type of the variable as var.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) Integer x) -&amp;gt;System.out.println(x));&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo( &quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Since there is only one element in the @DebugInfo annotation that does not have a default value and since its name is value, you can pass a value for this element directly without specifying the name.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = @DebugInfo(&quot;lambda&quot;)( a, b)-&amp;gt; a+b;&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The annotation is not placed correctly. You can do something like this: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) Integer a, Integer b)-&amp;gt; a+b;&lt;/code&gt; or &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda1&quot;) Integer a, @DebugInfo(&quot;lambda1&quot;) Integer b)-&amp;gt; a+b;&lt;/code&gt; or even this: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) var a, var b)-&amp;gt; a+b;&lt;/code&gt;  But you cannot do: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) var a, Integer b)-&amp;gt; a+b;&lt;/code&gt; because you cannot mix var and explicit types in lambda.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo( date=new Date(), value=&quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Value of an element must be a constant expression. So, new Date() is not a valid value for date element.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;br /&gt;
Which of the following method implementations will write a boolean value to the underlying stream?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw){ boolean bval = true; Â Â Â Â pw.writeBoolean(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;PrintWriter does not have write  methods such as writeInt, writeBoolean, WriteLong. It has overloaded print methods for writing various primitives.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) throws IOException{ Â Â Â Â boolean bval = true; pw.write(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;PrintWriter does not have write(boolean ) method. It does have write(String), write(int ), write(char[] ) methods. It also has write(char[] buf, int off, int len) and write(String buf, int off, int len) methods that let you write a portion of the input buf.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) throws IOException{ Â Â Â Â boolean bval = true;  pw.print(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Although the throws IOException clause is not required here, it is not invalid.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) { boolean bval = true; Â Â Â Â pw.print(bval); }&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) { boolean bval = true; Â Â Â Â pw.println(bval); }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Explanation&lt;br /&gt;
Remember that none of PrintWriterâ€™s print or write methods throw I/O exceptions (although some of its constructors may). This is unlike other streams, where you need to include exception handling (i.e. a try/catch or throws clause) when you use the stream.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;10.&lt;/strong&gt;&lt;br /&gt;
Consider the following code fragment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void myMethod(int x)  //Specify throws clause here
{
    try{
        if(x == 0){
            throw new ClassNotFoundException();
        }
        else throw new NoSuchFieldException();
    }catch(RuntimeException e){
        throw e;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following is a valid throws clause for the above method?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;No throws clause is necessary.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;throws ClassNotFoundException, NoSuchFieldException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;throws ClassNotFoundException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;throws NoSuchFieldException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;throws Exception&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;ClassNotFoundException&lt;/code&gt; and &lt;code&gt;NoSuchFieldException&lt;/code&gt; are checked exceptions and are thrown when you use Java reflection mechanism to load a class and access its fields. For example:&lt;br /&gt;
&lt;code&gt;Class c = Class.forName(&quot;test.MyClass&quot;);&lt;/code&gt; //may throw ClassNotFoundException&lt;br /&gt;
&lt;code&gt;java.lang.reflect.Field f = c.getField(&quot;someField&quot;);&lt;/code&gt; //may throw NoSuchFieldException&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;11.&lt;/strong&gt;&lt;br /&gt;
Which of the following are correct definitions of a repeatable annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public @interface Meal{ String value(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;For an annotation to be repeatable it must be defined with @Repeatable meta-annotation.&lt;br /&gt;
@Repeatable requires the name of the container annotation class. It cannot be empty. For example, @Repeatable(Meals.class)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Repeatable(Meals.class) public @interface Meal { int id() default 0; } public @interface Meals{ Meal[] meals(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The name of the Meal[] array should be value, not meals.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public @interface Meals{ Meal[] value(); String course() default &quot;maincourse&quot;; } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String name(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The value of the &lt;code&gt;@Repeatable&lt;/code&gt; meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type. It is possible to use other elements in the container annotation but they must have default values.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public @interface Meals{ Meal[] value(); String course(); } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String value(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is possible to use other elements in the container annotation but they must have default values. So, String course(); should be changed to something like String course() default â€œmaincourseâ€;&lt;br /&gt;
The reason for this restriction is simple. Java allows you to use the contained annotation and omit the container annotation. But internally, the container does create the container annotation and if there is no default value for any element of the container annotation, the compiler will not be able to supply its value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;
To make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write &lt;code&gt;@Meal(name=&quot;sandwich&quot;)&lt;/code&gt; but, internally, Java converts it to &lt;code&gt;@Meals(@Meal(name=&quot;sandwich&quot;))&lt;/code&gt;. If you apply two such annotations, for example:&lt;br /&gt;
&lt;code&gt;@Meal(name=&quot;sandwich&quot;)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;the compiler will convert them to: &lt;code&gt;@Meals({@Meal(name=&quot;sandwich&quot;), @Meal(name=&quot;fries&quot;) })&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A container annotation is also an annotation and just like any other annotation, it can be used independently. It can have other elements as well. For example, you can use the &lt;code&gt;@Meals&lt;/code&gt; annotation like this:&lt;br /&gt;
&lt;code&gt;@Meals(value={@Meal(name=&quot;sandwich&quot;), @Meal(name=&quot;fries&quot;) }, course=&quot;starter&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Remember that values of a repeated annotations are not additive. So, for example, you cannot expect &lt;code&gt;@Meal(id=1)&lt;/code&gt; and &lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt; to combine automatically to &lt;code&gt;@Meal(id=1, name=&quot;fries&quot;)&lt;/code&gt;. Since id is defined using a default value but name is not, &lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt; is valid but &lt;code&gt;@Meal(id=1)&lt;/code&gt; is not valid.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;12.&lt;/strong&gt;
Your application is packaged in myapp.jar and depends on a jar named datalayer.jar, which in turn depends on mysql-connector-java-8.0.11.jar. The following packages exist in these jars:&lt;/p&gt;

&lt;p&gt;myapp.jar:   com.abc.myapp&lt;br /&gt;
datalayer.jar: com.abc.datalayer&lt;br /&gt;
mysql-connector-java-8.0.11.jar:  com.mysql.jdbc&lt;/p&gt;

&lt;p&gt;You want to use bottom up approach for migrating your app to a modular app. Which of the following is required before you can do this?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Mysql driver jar and datalayer.jar must first be converted into modular jars.
    &lt;blockquote&gt;
      &lt;p&gt;In this case, mysql-connector-java-8.0.11.jar would have to become modular first, then datalayer.jar.&lt;br /&gt;
In the top down approach, on the other hand, you would directly make myapp.jar modular by including a module-info and adding requires datalayer; clause. You would create an automatic module for datalayer.jar by simply placing it on module-path (instead of classpath). You would leave mysql jar on the classpath so that datalayer could access it.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;datalayer.jar must first be converted into modular jar. The mysql jar need not be converted.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The mysql jar must first be converted into modular jar. The datalayer.jar need not be converted.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Neither datalayer nor mysql driver need to be converted into modular jars.&lt;br /&gt;
&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Bottom Up Approach for modularzing an application&lt;/strong&gt;&lt;br /&gt;
While modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in A.jar directly uses a class from B.jar, and a class in B.jar directly uses a class from C.jar, you need to first modularize C.jar and then B.jar before you can modularize A.jar.&lt;br /&gt;
Thus, bottom up approach is possible only when the dependent libraries are modularized already.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;14.&lt;/strong&gt;
Given:&lt;br /&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; ls = Arrays.asList(1, 2, 3);&lt;/code&gt;&lt;br /&gt;
Which of the following options will compute the sum of all Integers in the list correctly?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = ls.stream().sum();
    &lt;blockquote&gt;
      &lt;p&gt;There no sum method in Stream. There is one in IntStream and DoubleStream.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;double sum = ls.stream().reduce(0, (a,b)-&amp;gt; a+b);
    &lt;blockquote&gt;
      &lt;p&gt;The reduce method performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;double sum = ls.stream().mapToInt(x-&amp;gt;x).sum();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = 0; ls.stream().forEach(a-&amp;gt;{sum=sum+a;});
    &lt;blockquote&gt;
      &lt;p&gt;This code is almost correct but for the fact that only final local variables can be used in a lambda expression. Here, the code is trying to use sum and sum is not final. Effectively final means that even though it is not declared as final, it is not assigned any value anywhere else after the first assignment. That compiler determines that this variable never changes and consider it as final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = 0; ls.stream().peek(x-&amp;gt;{sum=sum+x;}).forEach(y-&amp;gt;{});
    &lt;blockquote&gt;
      &lt;p&gt;This has the same problem as above. sum is not final or effectively final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
It is important that you go through the JavaDoc API description of the three flavors of reduce method given here: You should read about the three flavors of reduce method given here: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&quot;&gt;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;15.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Book{
    private String title;
    private Double price;
    public Book(String title, Double price){
        this.title = title;
        this.price = price;
    }
    //accessor methods not shown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will the following code print when compiled and run?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Book b1 = new Book(&quot;Java in 24 hrs&quot;, null);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;DoubleSupplier ds1 = b1::getPrice;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;System.out.println(b1.getTitle()+&quot; &quot;+ds1.getAsDouble());&lt;/code&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs null&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs 0.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will throw a NullPointerException.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile.
    &lt;blockquote&gt;
      &lt;p&gt;There is no problem with the code.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;java.util.function.DoubleSupplier&lt;/code&gt;(and other similar Suppliers such as IntSupplier and LongSupplier) is a functional interface with the functional method named &lt;code&gt;getAsDouble&lt;/code&gt;. The return type of this method is a primitive double (not &lt;code&gt;Double&lt;/code&gt;). Therefore, if your lambda expression for this function returns a &lt;code&gt;Double&lt;/code&gt;, it will automatically be converted into a double because of auto-unboxing. However, if your expression returns a null, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;19.&lt;/strong&gt;
What will the following code print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.Optional;
public class NewClass {
    public static Optional&amp;lt;String&amp;gt; getGrade(int marks){
        Optional&amp;lt;String&amp;gt; grade = Optional.empty();
        if(marks&amp;gt;50){
            grade = Optional.of(&quot;PASS&quot;);
        }
        else {
            grade.of(&quot;FAIL&quot;);
        }
        return grade;
    }
    public static void main(String[] args) {
        Optional&amp;lt;String&amp;gt; grade1 = getGrade(50);
        Optional&amp;lt;String&amp;gt; grade2 = getGrade(55);
        System.out.println(grade1.orElse(&quot;UNKNOWN&quot;));
        if(grade2.isPresent()){
            grade2.ifPresent(x-&amp;gt;System.out.println(x));
        }else{
            System.out.println(grade2.orElse(&quot;Empty&quot;));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;UNKNOWN PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[UNKNOWN] PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[UNKNOWN] Optional[PASS]&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;FAIL PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[FAIL] OPTIONAL[PASS]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You should go through the following article about java.util.Optional:&lt;br /&gt;
&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&quot;&gt;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are a few important things you need to know about Optional class:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Optional has a static method named &lt;code&gt;of(T t)&lt;/code&gt; that returns an Optional object containing the value passed as argument. It will throw &lt;code&gt;NullPointerException&lt;/code&gt; if you pass &lt;code&gt;null&lt;/code&gt;. If you want to avoid &lt;code&gt;NullPointerException&lt;/code&gt;, you should use &lt;code&gt;Optional.ofNullable(T t)&lt;/code&gt; method. This will return &lt;code&gt;Optional.empty&lt;/code&gt; if you pass &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You cannot change the contents of Optional object after creation. Optional does not have a set method. Therefore, &lt;code&gt;grade.of&lt;/code&gt;, although technically correct, will not actually change the Optional object referred to by grade. It will return a new Optional object containing the passed argument.&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;orElse&lt;/code&gt; method returns the actual object contained inside the Optional or the argument passed to this method if the Optional is empty. It does not return an Optional object. Therefore, &lt;code&gt;print(grade1.orElse(&quot;UNKNOWN&quot;))&lt;/code&gt; will print UNKNOWN and not Optional[UNKNOWN].&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isPresent()&lt;/code&gt; returns true if the Optional contains a value, false otherwise.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ifPresent(Consumer)&lt;/code&gt; executes the &lt;code&gt;Consumer&lt;/code&gt; object with the value if the Optional contains a value. Not that it is the value contained in the Optional that is passed to the &lt;code&gt;Consumer&lt;/code&gt; and not the Optional itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;21.&lt;/strong&gt;
Consider the following method exposed by a utility class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static String getOptions(final String propName) {
                return AccessController.doPrivileged(
                    new PrivilegedAction&amp;lt;String&amp;gt;() {
                        public String run() {
                            return System.getProperty(propName);
                        }
                    }
                );
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It has been decided to give appropriate permission in the security file for this code. Identify correct statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It violates secure coding guidelines for invoking privileged actions.
    &lt;blockquote&gt;
      &lt;p&gt;As per Guideline 9-3 / ACCESS-3: â€œSafely invoke java.security.AccessController.doPrivilegedâ€, the given code should retrieve a system property using a hardcoded value instead of passing user input directly to the OS. In the given code, the user can potentially wreck the application by requesting illformated or mischievous property name. Since the code is privileged, the call may cause unwanted impact directly on the OS.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It violates secure coding guidelines for exposing static methods.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It violates secure coding guidelines for validating inputs.
    &lt;blockquote&gt;
      &lt;p&gt;Ideally, it should validate whether the property name for which the value is requested is valid or not.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It violates secure coding guidelines for protecting confidential information.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;22.&lt;/strong&gt;
Which of the following statements are true regarding the try-with-resources statement?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources are closed in the same order of their creation.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources may not be closed properly if the code in the try block throws an exception for which there is no catch block.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources may not be closed properly if the code in the catch block throws an exception.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;catch and finally blocks are executed after the resources opened in the try blocks are closed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to know the following points regarding try-with-resources statement for the exam:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable.&lt;br /&gt;
&lt;strong&gt;2.&lt;/strong&gt; AutoCloseable has only one method - public void close() throws Exception.&lt;br /&gt;
&lt;strong&gt;3.&lt;/strong&gt; Resources are closed at the end of the try block and before any catch or finally block.&lt;br /&gt;
&lt;strong&gt;4.&lt;/strong&gt; Resources are not even accessible in the catch or finally block. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(Device d = new Device())
{
   d.read();
}finally{
   d.close(); //This will not compile because d is not accessible here.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Device d = new Device();
try(d){ //valid since Java 9
  ...
}finally{
   d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Resources are closed in the reverse order of their creation.&lt;br /&gt;
&lt;strong&gt;6.&lt;/strong&gt; Resources are closed even if the code in the try block throws an exception.&lt;br /&gt;
&lt;strong&gt;7.&lt;/strong&gt; java.lang.AutoCloseableâ€™s &lt;code&gt;close()&lt;/code&gt; throws &lt;code&gt;Exception&lt;/code&gt; but java.io.Closeableâ€™s &lt;code&gt;close()&lt;/code&gt; throws &lt;code&gt;IOException&lt;/code&gt;.&lt;br /&gt;
&lt;strong&gt;8.&lt;/strong&gt; If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;23.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {
    static Path p1 = Paths.get(&quot;c:\\finance\\data\\reports\\daily\\pnl.txt&quot;);  
    public static void main(String[] args) {
        System.out.println(p1.subpath(0, 2));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;finance\data&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;finance\data\&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\finance\data\reports&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c:\finance\data&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c:\finance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember the following points about &lt;code&gt;Path.subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indexing starts from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not considered as the beginning.&lt;/li&gt;
  &lt;li&gt;name at beginIndex is included but name at endIndex is not.&lt;/li&gt;
  &lt;li&gt;paths do not start or end with .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, in case of â€œc:\finance\data\reports\daily\pnl.txtâ€, name at 0 is &lt;em&gt;finance&lt;/em&gt; and name at 2 is &lt;em&gt;reports&lt;/em&gt;. However, since the name at endIndex is excluded, &lt;code&gt;subpath(0, 2)&lt;/code&gt; will correspond to finance\data.&lt;/p&gt;

&lt;p&gt;The following is the API description for this method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;br /&gt;
Returns a relative Path that is a subsequence of the name elements of this path.&lt;br /&gt;
The beginIndex and endIndex parameters specify the subsequence of name elements. The name that is closest to the root in the directory hierarchy has index 0. The name that is farthest from the root has index count-1. The returned Path object has the name elements that begin at beginIndex and extend to the element at index endIndex-1.&lt;/p&gt;

&lt;p&gt;Parameters:&lt;br /&gt;
beginIndex - the index of the first element, inclusive&lt;br /&gt;
endIndex - the index of the last element, exclusive&lt;br /&gt;
Returns:&lt;br /&gt;
a new Path object that is a subsequence of the name elements in this Path&lt;br /&gt;
Throws:&lt;br /&gt;
IllegalArgumentException - if beginIndex is negative, or greater than or equal to the number of elements. If endIndex is less than or equal to beginIndex, or larger than the number of elements.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;24.&lt;/strong&gt;
Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class AssertErrorTest
{
   public void robustMethod(int[] intArray) throws AssertionError
   {
      int[] newIA = //get new array by processing intArray
      assert newIA != intArray;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following declarations of robustMethod(int[] intArray) are valid in a subclass of the above class?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray)&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;public void robustMethod(int[] intArray) throws Exception
    &lt;blockquote&gt;
      &lt;p&gt;Exception is in a different branch of Exceptions than AssertionError.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;public void robustMethod(int[] intArray) throws Throwable
    &lt;blockquote&gt;
      &lt;p&gt;Throwable is a super class of AssertionError so it cannot be thrown from the subclassâ€™s overriding method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray) throws Error
    &lt;blockquote&gt;
      &lt;p&gt;Error is also a superclass of AssertionError but any Error or any RuntimeException can be thrown without having to declare them in the throws clause.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray) throws RuntimeException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This questions tests two concepts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;An overriding method must not throw any new or broader checked exceptions than the ones declared in the overridden method. This means, the overriding method can only throw the exceptions or the subclasses of the exceptions declared in the overridden method. It can throw any subclass of Error or RuntimeException as well because it is not mandatory to declare Errors and RuntimeExceptions in the throws clause. An overriding method may also choose not to throw any exception at all.&lt;/li&gt;
  &lt;li&gt;AssertionError is a subclass of Error.&lt;br /&gt;
Therefore, option 1, 4, and 5 are valid.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;25.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String sentence = &quot;Life is a box of chocolates, Forrest. You never know what you're gonna get.&quot;; //1
Optional&amp;lt;String&amp;gt; theword = Stream.of(sentence.split(&quot;[ ,.]&quot;)).anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;)); //2
System.out.println(theword.get()); //3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following statements are correct?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print gonna.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get if lines //2 and //3 are changed to: &lt;code&gt;String theword = Stream.of(sentence.split(&quot;[,.]&quot;)).anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;));&lt;/code&gt; //2 &lt;code&gt;System.out.println(theword.get());&lt;/code&gt; //3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get if lines //2 and //3 are changed to: &lt;code&gt;Optional&amp;lt;String&amp;gt; theword = Stream.of(sentence.split(&quot;[,.]&quot;)).parallel().anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;));&lt;/code&gt; //2 &lt;code&gt;System.out.println(theword.get());&lt;/code&gt; //3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will fail to compile.
    &lt;blockquote&gt;
      &lt;p&gt;anyMatch returns a boolean and not an Optional. Therefore, //2 will not compile.&lt;br /&gt;
The expression Stream.of(sentence.split(â€œ[,.]â€)).anyMatch(w-&amp;gt;w.startsWith(â€œgâ€)); will actually just return true.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;anyMatch&lt;/code&gt; returns a boolean and not an Optional. Therefore, //2 will not compile.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;27.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  Connection con = DriverManager.getConnection(dbURL);
  con.setAutoCommit(false);
  String updateString =
        &quot;update SALES &quot; +
        &quot;set T_AMOUNT = 100 where T_NAME = 'BOB'&quot;;
  Statement stmt = con.createStatement();
  stmt.executeUpdate(updateString);
  //INSERT CODE HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What statement can be added to the above code so that the update is committed to the database?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;con.setAutoCommit(true);&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;con.commit(true);
    &lt;blockquote&gt;
      &lt;p&gt;commit() does not take any parameter.&lt;br /&gt;
FYI, there are two flavors of rollback() - one does not take any argument and another one takes a java.sql.Savepoint as an argument.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt.commit();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;con.setRollbackOnly(false)
    &lt;blockquote&gt;
      &lt;p&gt;There is no such method in Connection.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Node code is necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This is a trick question. Since auto-commit has been disabled in the given code (by calling &lt;code&gt;c.setAutoCommit(false)&lt;/code&gt;), you have to explicitly commit the transaction to commit the changes to the database. The regular way to do this is to call &lt;code&gt;con.commit()&lt;/code&gt;. Notice that commit method does not take any arguments.&lt;/p&gt;

&lt;p&gt;Another way is to utilize the side effect of changing the auto-commit mode of the connection. If the &lt;code&gt;setAutoCommit&lt;/code&gt; method is called during a transaction and the auto-commit mode is changed, the transaction is committed. If &lt;code&gt;setAutoCommit&lt;/code&gt; is called and the auto-commit mode is not changed, the call is a no-op. In this question, &lt;code&gt;con.setAutoCommit(true)&lt;/code&gt; changes the auto-commit mode of the connection from &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and therefore this call commits the changes.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;28.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {
    static Path p1 = Paths.get(&quot;c:\\a\\b\\c&quot;);
    public static String getValue(){
        String x = p1.getName(1).toString();
        String y = p1.subpath(1,2).toString();
        return x+&quot; : &quot;+y;
    }
    public static void main(String[] args) {
        System.out.println(getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;\b:\b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b\c\&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;a:a\b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b\c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember the following points about &lt;code&gt;Path.subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indexing starts from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not considered as the beginning.&lt;/li&gt;
  &lt;li&gt;name at beginIndex is included but name at endIndex is not.&lt;/li&gt;
  &lt;li&gt;paths do not start or end with .&lt;br /&gt;
Thus, if your path is â€œc:\a\b\câ€,&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;subpath(1,1) will cause IllegalArgumentException to be thrown.&lt;br /&gt;
subpath(1,2) will correspond to b.&lt;br /&gt;
subpath(1,3) will correspond to b/c.&lt;/p&gt;

&lt;p&gt;Remember the following 4 points about Path.getName() method :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indices for path names start from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not included in path names.&lt;/li&gt;
  &lt;li&gt;\ is NOT a part of a path name.&lt;/li&gt;
  &lt;li&gt;If you pass a negative index or a value greater than or equal to the number of elements, or this path has zero name elements, java.lang.IllegalArgumentException is thrown. It DOES NOT return null.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, for example, If your Path is â€œc:\code\java\PathTest.javaâ€,&lt;br /&gt;
p1.getRoot()Â Â is c:\Â Â ((For Unix based environments, the root is usually / ).&lt;br /&gt;
p1.getName(0) is code&lt;br /&gt;
p1.getName(1) is java&lt;br /&gt;
p1.getName(2) is PathTest.java&lt;br /&gt;
p1.getName(3) will cause IllegalArgumentException to be thrown.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;29.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String value() default &quot;&quot;;
    String[] params();
    String date();
    int depth() default 10;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo(date = &quot;2019&quot;, params = &quot;index&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The date element is defined as String. So, it doesnâ€™t really have to be a date. Any string value will be valid.&lt;br /&gt;
params is defined as a String[]. So, you can either use a single string such as used in this option or a String array such as params={â€œindexâ€} or params={â€œindex1â€, â€œwhateverâ€} or even params={}.&lt;br /&gt;
value and depth elements have default values so, the value for these elements can be omitted.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo(date = &quot;2019-1-1&quot;, params = { null }) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;You cannot set an annotation element (or its values, if it is an array) to null.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo(depth = 10, date = &quot;01/01/2019&quot;, params = {&quot;index&quot;}, value=&quot;applyLogic&quot;) static final String s = null;&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;The order of values for the elements is not important.&lt;/li&gt;
        &lt;li&gt;Since @Target annotation is not specified in the definition of @DebugInfo, it will be assumed that @DebugInfo is applicable to all place where annotations can be used.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo({&quot;index&quot;}, &quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Names of the elements cannot be omitted when there are more than one values. Even when there is only one value, the name of the element can be omitted only if the name of the element is value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo(&quot;value&quot;, params={&quot;index&quot;}, date=&quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;You cannot omit the name of any element, if you are specifying values for more than one element. So, you must write value=â€valueâ€ instead of just â€œvalueâ€.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;30.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String qr = &quot;insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)&quot;;
String[] tickers = {&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You are trying to initialize the STOCK table and for that you need to insert one row for each of the ticker value in the tickers array. Each row has to be initialized with the same values except the ID and TICKER columns, which are different for each row. The ID column is defined as AUTO_INCREMENT and so you need to pass only 0 for this column.&lt;/p&gt;

&lt;p&gt;Which of the following code snippets would you use?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;for(String ticker: tickers)
try(PreparedStatement ps = c.preparedStatement(qr);) {
  ps.setInt(1,0);
  ps.setString(2, ticker);
  ps.setDouble(3, 0.0);
  ps.setString(4, &quot;NYSE&quot;);
  ps.executeUpdate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This will close the PreparedStatement after each insert. This is very inefficient.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(PreparedStatement ps = c.prepareStatement(qr);)
{
  for(String ticker: tickers) {
    ps.setInt(1, 0);
    ps.setString(2, ticker);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    ps.executeUpdate()ï¼›
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is better than option 1 but there is no need to set the values for ID, LTP, and EXCHANGE columns in every iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(PreparedStatement ps = c.prepareStatement(qr);)
{
    ps.setInt(1, 0);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    for(String ticker: tickers) {
      ps.setString(2, ticker);
      ps.executeUpdate()ï¼›
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;All of the options will insert the required rows in the table, however, this option is most suitable because it is the most efficient of all. A PreparedStatement remembers the values once you set them until you close it. So, there is no need to reset the values for ID, LTP, and EXCHANGE columns if they are not changing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;for(String ticker: tickers)
try(Statement s = c.createStatement(qr);)
{
  s.executeUpdate(&quot;insert into STOCK (ID, TICKER, LTP, EXCHANGE ) values (0, '&quot;+ticker+&quot;', 0.0, 'NYSE')&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This option is as bad as option 1 in terms of performance. Further, it does not offer protection from SQL injection either.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;31.&lt;/strong&gt;
Given that Book is a valid class with appropriate constructor and getTitle and getPrice methods that return a String and a Double respectively, what can be inserted at //1 and //2 so that it will print the price of all the books having a title that starts with â€œAâ€?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Book&amp;gt; books = Arrays.asList(
        new Book(&quot;Atlas Shrugged&quot;, 10.0),
        new Book(&quot;Freedom at Midnight&quot;, 5.0),
        new Book(&quot;Gone with the wind&quot;, 5.0)
);

Map&amp;lt;String, Double&amp;gt; bookMap = //1 INSERT CODE HERE
//2 INSERT CODE HERE
bookMap.forEach(func);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.steam().collect(Collectors.toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;String, Double&amp;gt; func = (a, b) -&amp;gt; {
  if(a.startsWith(&quot;A&quot;)) {
    System.out.println(b);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The first line generates a &lt;code&gt;Map&amp;lt;String, Double&amp;gt;&lt;/code&gt; from the List using Streamâ€™s collect method. The &lt;code&gt;Collectors.toMap&lt;/code&gt; method uses two functions to get two values from each element of the stream.Â Â The value returned by the first function is used as a key and the value returned by the second function is used as a value to build the resulting &lt;code&gt;Map&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;The &lt;code&gt;forEach&lt;/code&gt; method of a &lt;code&gt;Map&lt;/code&gt; requires a &lt;code&gt;BiConsumer&lt;/code&gt;. This function is invoked for each entry, that is each key-value pair, in the map. The first argument of this function is the key and the second is the value.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;String, Double&amp;gt; func = (a, b) -&amp;gt; {
  if(a.startsWith(&quot;A&quot;)) {
    System.out.println(b);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;toMap is not a valid method in Stream.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;Map.Entry&amp;gt; func = (b)-&amp;gt; {
  if(b.getKey().startsWith(&quot;A&quot;)) {
    System.out.println(b.getValue());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;toMap is not a valid method in Stream.&lt;/li&gt;
    &lt;li&gt;BiConsumer requires two generic types and two arguments.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().collect(Collectors.toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
Consumer&amp;lt;Map.Entry&amp;lt;String, Double&amp;gt;&amp;gt; func = (e)-&amp;gt; {
  if(e.getKey().startsWith(&quot;A&quot;)) {
    System.out.println(e.getValue());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The implementation of Consumer is technically correct. However, the forEach method requires a BiConsumer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;33.&lt;/strong&gt;
NOTE: If you are not from a Computer Science background, this question will seem very complicated and almost unanswerable. Further, this has more to do with understanding of an algorithm than assertions. Unfortunately, we have seen similar question in the real exam. If you get such a question in your exam, our suggestion is to just mark it and move on. Attempt it only at the end if you have time.&lt;/p&gt;

&lt;p&gt;Given the following code that implements a sorting algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void mysort(int[] values){
    int n = values.length;
    for(int i = 1; i&amp;lt;n; i++){  

        //1
        int temp = values[i];
        int j = i-1;
        while( (j&amp;gt;-1) &amp;amp;&amp;amp; values[j]&amp;gt;temp){
            values[j+1] = values[j];
            j--;

            //2
        }
        //3
        values[j+1] = temp;

        //4
    }
    //5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test the working of this code, you want to assert that the elements are partially sorted in the middle of the sorting process using this statement:&lt;br /&gt;
&lt;code&gt;assert j&amp;lt;0 || values[j]&amp;lt;=values[j+1];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where can this statement be put?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //1.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //3.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;At //4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //5.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The basic idea behind this algorithm is to determine the right place of an element of among the elements that appear before it in the input array. If a list contains only 1 element, then the list is always already sorted. So, the first top level iteration starts with the second element. In this iteration, the second element is put in the correct position considering just the first two elements. Thus, at the end of the first iteration, first two elements will be sorted. The process is continued till the last element is put in its right place.&lt;/p&gt;

&lt;p&gt;Try to run the above code Step by Step in an editor. Observe the values of the variables.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;38.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  LocalDate d = LocalDate.now();
  DateFormat df = new DateFormat(DateFormat.LONG);
  System.out.println(df.format(d));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print current date in LONG format.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print the number of milliseconds since 1 Jan 1970.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will not compile.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will throw an exception at runtime.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;java.text.DateFormat&lt;/code&gt; class provides several static getXXXInstance methods. The following are the important methods that you need to know for the exam:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static DateFormat getDateInstance()&lt;/code&gt;&lt;br /&gt;
Â Â Â Â Â Â Â Â Â Â Get a default date/time formatter that uses the SHORT style for both the date and the time.&lt;br /&gt;
&lt;code&gt;static DateFormat getDateInstance(int style)&lt;/code&gt;&lt;br /&gt;
Â Â Â Â Â Â Â Â Â Â Gets the date formatter with the given formatting style for the default locale.&lt;br /&gt;
&lt;code&gt;static DateFormat getDateInstance(int style, Locale aLocale)&lt;/code&gt;&lt;br /&gt;
Â Â Â Â Â Â Â Â Â Â Gets the date formatter with the given formatting style for the given locale.&lt;br /&gt;
&lt;code&gt;static DateFormat getInstance()&lt;/code&gt;&lt;br /&gt;
Â Â Â Â Â Â Â Â Â Â Get a default date/time formatter that uses the default style for both the date and the time.&lt;/p&gt;

&lt;p&gt;Note that valid styles values are : &lt;code&gt;DateFormat.DEFAULT&lt;/code&gt;, &lt;code&gt;DateFormat.FULL&lt;/code&gt;, &lt;code&gt;DateFormat.LONG&lt;/code&gt;, &lt;code&gt;DateFormat.MEDIUM&lt;/code&gt;, and &lt;code&gt;DateFormat.SHORT&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;44.&lt;/strong&gt;
Assuming that STOCK table exists and is empty, what will the following code snippet print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String qr = &quot;insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)&quot;;
try(PreparedStatement ps =  c.prepareStatement(qr);)
{
    ps.setInt(1, 111);
    ps.setString(2, &quot;APPL&quot;);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    int i = ps.executeUpdate();  //1
    System.out.println(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile due to error at //1.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print 0.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will print 1.
    &lt;blockquote&gt;
      &lt;p&gt;executeUpdate returns the number of rows that have been affected by the query. If you execute a query that, for example, causes updates to 10 existing rows, executeUpdate would return 10. Here, 1 row has been inserted and so it will return 1.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print 4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print -1.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;45.&lt;/strong&gt;
Given that a method named Double getPrice(String id) exists and may potentially return null, about which of the following options can you be certain that a run time exception will not be thrown?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optional.of method throws NullPointerException if you try to create an Optional with a null value. If you expect the argument to be null, you should use Optional.ofNullable method, which returns an empty Optional if the argument is null.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.ofNullable(getPrice(&quot;1111&quot;));  
Double x = price.orElse(getPrice(&quot;2222&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.ofNullable(getPrice(&quot;1111&quot;));  
Double y = price.orElseGet(()-&amp;gt;getPrice(&quot;333&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optionalâ€™s &lt;code&gt;orElseGet&lt;/code&gt; method takes a &lt;code&gt;java.util.function.Supplier&lt;/code&gt; function as an argument and invokes that function to get a value if the Optional itself is empty. Just like the orElse method, this method does not throw any exception even if the Supplier returns null. It does, however, throw a NullPointerException if the &lt;code&gt;Optional&lt;/code&gt; is empty and the supplier function itself is null.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;), 10.0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This will not compile because Optional.of takes only one argument.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;));  
Double z = price.orElseThrow(()-&amp;gt;new RuntimeException(&quot;Bad Code&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code&gt;orElseThrow&lt;/code&gt; method takes a &lt;code&gt;Supplier&lt;/code&gt; function that returns an &lt;code&gt;Exception&lt;/code&gt;. This method is useful when you want to throw a custom exception in case the Optional is empty.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;46.&lt;/strong&gt;
Whi of the following are correct definitions of a repeatable annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable
public @interface Author {
  int id() default 0;
  String name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;@Repeatable requires the name of the container class. It cannot be empty. For example, @Repeatable(Authors.class)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable(List.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable(List&amp;lt;Author&amp;gt;)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public @interface Authors {
  Author[] value();
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The value of the @Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Authors {
  Author[] values;
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Authors {
  List&amp;lt;Author&amp;gt; authors;
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;48.&lt;/strong&gt;
Which of the following is correct regarding a HashSet?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Elements are stored in a sorted order.
    &lt;blockquote&gt;
      &lt;p&gt;TreeSet does that.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It is immutable.
    &lt;blockquote&gt;
      &lt;p&gt;No, you can add/remove elements to/from it.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It only keeps unique elements.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Elements can be accessed using a unique key.
    &lt;blockquote&gt;
      &lt;p&gt;HashSet is a Set not a Map.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
public class HashSet extends AbstractSet implements Set, Cloneable, Serializable&lt;/p&gt;

&lt;p&gt;This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;50.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public @interface Authors{
   Author[] value();
}
@Repeatable(Authors.class)
public @interface Author {
    int id() default 0;
    String value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct usages of the above annotations.&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(1, &quot;bob&quot;)
@Author(2, &quot;alice&quot;)
public class Sample {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use name=value format for element values because more than one values are being specified.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Authors(@Author(&quot;bob&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;To make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write @Author(â€œbobâ€) but, internally, Java converts it to @Authors(@Author(â€œbobâ€)).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Authors(@Author(&quot;bob&quot;))
@Authors(@Author(&quot;alice&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The @Author annotation is repeatable, @Authors is not!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Authors(@Author(&quot;alice&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Author(1)
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The two annotations are different. Their values are not additive. So, while @Author(â€œbobâ€) is valid @Author(1) is not because it does not include a value for the value element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Author(id=1, value=null)
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;@Author(id=1, value=null) is invalid because you cannot set an element value to null. The value must be a constant non-null value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;54.&lt;/strong&gt;
Given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;RandomAccessFile raf = new RandomAccessFile(&quot;c:\\temp\\test.txt&quot;, &quot;rwd&quot;);
raf.writeChars(&quot;hello&quot;);
raf.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following statements are correct?&lt;br /&gt;
(Assuming that the code has appropriate security permissions.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;If the file test.txt does not exist, an attempt will be made to create it.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt does not exist, an exception will be thrown.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt exists, an exception will be thrown.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt, it will be overwritten and all the existing data will be lost.
    &lt;blockquote&gt;
      &lt;p&gt;Only the initial 5 characters (i.e. 10 bytes) of the file will be overwritten. Any existing data beyond 10 bytes will be left untouched.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt exists, the given characters will be appended to the end of the existing data.
    &lt;blockquote&gt;
      &lt;p&gt;When you open the file, the pointer is at the first position. So the given characters will be written at the beginning of the file.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The permitted values for the access mode and their meanings are:&lt;/p&gt;

&lt;p&gt;â€œrâ€: Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown.&lt;br /&gt;
â€œrwâ€: Open for reading and writing. If the file does not already exist then an attempt will be made to create it.&lt;br /&gt;
â€œrwsâ€: Open for reading and writing, as with â€œrwâ€, and also require that every update to the fileâ€™s content or metadata be written synchronously to the underlying storage device.&lt;br /&gt;
â€œrwdâ€: Open for reading and writing, as with â€œrwâ€, and also require that every update to the fileâ€™s content be written synchronously to the underlying storage device.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;55.&lt;/strong&gt;
Given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title
{
    MR(&quot;Mr. &quot;), MRS(&quot;Mrs. &quot;), MS(&quot;Ms. &quot;);
    private String title;
    private Title(String s){
    title = s;
    }
    public String format(String first, String last){
    return title+&quot; &quot;+first+&quot; &quot;+last;
    }
}

//INSERT CODE HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify valid code snippets ..&lt;/p&gt;

&lt;p&gt;(Assume that Title is accessible wherever required.)&lt;br /&gt;
&lt;strong&gt;You had to select 4 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println(Title.format(&quot;Rob&quot;, &quot;Miller&quot;));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot call format method directly on Title because format is not a static method. You must call it on Title instances. For example, Title.MR.format().&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println(MR.format(&quot;Rob&quot;, &quot;Miller&quot;));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;It must be Title.MR.format(â€œRobâ€, â€œMillerâ€).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2 extends Ttile
{
  DR(&quot;Dr. &quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;An enum cannot extend another enum or class. It may implement an interface though.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    Title.DR dr = new Title.DR(&quot;Dr. &quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Enum constants cannot be instantiated/created using the new keyword.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 7&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t = Title.MR;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 8&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t = Title.MR;
  public String format(String s) { return t.format(s, s); };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to know the following facts about enums:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.&lt;/li&gt;
  &lt;li&gt;An enum is implicitly final, which means you cannot extend it.&lt;/li&gt;
  &lt;li&gt;You cannot extend an enum from another enum or class because an enum implicitly extends &lt;code&gt;java.lang.Enum&lt;/code&gt;. But an enum can implements interfaces.&lt;/li&gt;
  &lt;li&gt;Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because &lt;code&gt;java.lang.Enum&lt;/code&gt; makes it final.&lt;/li&gt;
  &lt;li&gt;Compiler provides an enum with two public static methods automatically - &lt;code&gt;values()&lt;/code&gt; and &lt;code&gt;valueOf(String)&lt;/code&gt;. The &lt;code&gt;values()&lt;/code&gt; method returns an array of its constants and &lt;code&gt;valueOf()&lt;/code&gt; method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;By default, an enumâ€™s toString() prints the enum name but you can override it to print anything you want.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following are a few more important facts about java.lang.Enum which you should know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It implements &lt;code&gt;java.lang.Comparable&lt;/code&gt; (thus, an enum can be added to sorted collections such as &lt;code&gt;SortedSet&lt;/code&gt;, &lt;code&gt;TreeSet&lt;/code&gt;, and &lt;code&gt;TreeMap&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;It has a method &lt;code&gt;ordinal()&lt;/code&gt;, which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.&lt;/li&gt;
  &lt;li&gt;It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;57.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;module abc.print{
   requires org.pdf;
   provides org.pdf.Print with com.abc.print.PrintImpl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct statements about the above module.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;org.pdf.Print must be an interface.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;org.pdf.Print must be an interface or an abstract class.
    &lt;blockquote&gt;
      &lt;p&gt;Ideally, Print should be an interface or an abstract class but there is no such technical restriction. As per JLS Section 7.7.4: The service must be a class type, an interface type, or an annotation type. It is a compile-time error if a provides directive specifies an enum type as the service.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;com.abc.print.PrintImpl must have a no-args constructor.
    &lt;blockquote&gt;
      &lt;p&gt;This is not necessary. It could also have a provider method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;com.abc.print.PrintImpl must implement(or extend) org.pdf.Print.
    &lt;blockquote&gt;
      &lt;p&gt;This is not necessary. If PrintImpl has a provider method, then that method could return any sub-type of Print. PrintImpl does not have to be a sub-type of Print.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;None of the above are correct.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Here are the rules for a service provider:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If a service provider explicitly declares a public constructor with no formal parameters, or implicitly declares a public default constructor, then that constructor is called the provider constructor.&lt;/li&gt;
  &lt;li&gt;If a service provider explicitly declares a public static method called provider with no formal parameters, then that method is called the provider method.&lt;/li&gt;
  &lt;li&gt;If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the provides directive; or a compile-time error occurs.&lt;/li&gt;
  &lt;li&gt;While a service provider that is specified by a provides directive must be declared in the current module, its provider method may have a return type that is declared in another module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service.&lt;/li&gt;
  &lt;li&gt;If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the provides directive, or a compile-time error occurs.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;58.&lt;/strong&gt;
Which of the following statements are correct regarding synchronization and locks?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A thread shares the intrinsic lock of an object with other threads between the time the threads enter a synchronized method and exit the method.
    &lt;blockquote&gt;
      &lt;p&gt;Just the opposite is true. An intrinsic lock is never shared. Once a thread acquires an intrinsic lock, it owns the lock exclusively until it releases the lock.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;When a synchronized method ends with a checked exception, the intrinsic lock held by the thread is released automatically.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A thread will retain the intrinsic lock if the return from a synchronized method is caused due to an uncaught unchecked exception.
    &lt;blockquote&gt;
      &lt;p&gt;The intrinsic lock is released when the method ends. Irrespective of how it ends.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Every object has an intrinsic lock associated with it and that lock is automatically acquired by a thread when it executes a method on that object.
    &lt;blockquote&gt;
      &lt;p&gt;A thread acquires the intrinsic lock of an object when it enters synchronized method on that object or when it enter a synchronized block that uses that object. The lock is not acquired when a thread enters a non-synchronized method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Please go through this link that explains synchronization and intrinsic locks. You will find questions in the exam that use statements given in this trail: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;59.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.Serializable;
class Booby{
    int i; public Booby(){ i = 10; System.out.print(&quot;Booby&quot;); }
}
class Dooby extends Booby implements Serializable {
    int j; public Dooby(){ j = 20; System.out.print(&quot;Dooby&quot;); }
}
class Tooby extends Dooby{
    int k; public Tooby(){ k = 30; System.out.print(&quot;Tooby&quot;); }
}
public class TestClass {
  public static void main(String[] args) throws Exception{
    Tooby t = new Tooby();
    t.i = 100;
    ObjectOutputStream oos  = new ObjectOutputStream(new FileOutputStream(&quot;c:\\temp\\test.ser&quot;));
    oos.writeObject(t); oos.close();
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;c:\\temp\\test.ser&quot;));
    t = (Tooby) ois.readObject();ois.close();
    System.out.println(t.i+&quot; &quot;+t.j+&quot; &quot;+t.k);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby 100 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby Dooby Tooby 10 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Booby Dooby Tooby Booby 10 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby 0 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby 100 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby Dooby Tooby 100 20 30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Objects of a class that is not marked Serializable cannot be serialized. In this question, class Booby does not implement Serializable and so, its objects cannot be serialized. Class Dooby implements Serializable and since Tooby extends Dooby, it is Serializable as well.&lt;/p&gt;

&lt;p&gt;Now, when you serialize an object of class Tooby, only the data members of Dooby and Tooby will be serialized. Data members of Booby will not be serialized. Thus, the value of i (which is 100) at the time of serialization will not be saved in the file.&lt;/p&gt;

&lt;p&gt;When reading the object back (i.e. deserializing), the constructors of serializable classes are not called. Their data members are set directly from the values present in serialized data. Constructor for unserializable classes is called. Thus, in this case, constructors of Tooby and Dooby are not called but the constructor of Booby is called. Therefore, i is set in the constructor to 10 and j and k are set using the data from the file to 20 and 30 respectively.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;60.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.TYPE)
public @interface DBTable {
  public String value();
  public String[] primarykey();
  public String surrogateKey() default &quot;id&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct usages of the above annotation.&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;person&quot;, primarykey={&quot;name&quot;})
interface Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use value=â€personâ€ because you are specifying values for more than one elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(value=&quot;person&quot; primarykey={&quot;name&quot;})
interface Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;person&quot;, {&quot;name&quot;}, &quot;pid&quot;)
class Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use elementName=elementValue format for specifying element values because you are specifying values for more than one element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(value=&quot;DAYS&quot;, primarykey=&quot;name&quot;)
enum DAYS {
  MON, TUE, WED, THU, FRI, SAT, SUN;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since the target of @DBTable annotation is specified as ElementType.TYPE, this annotation can be used on a class, an interface, or an enum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;DAYS&quot;, {&quot;name&quot;})
enum DAYS {
  MON, TUE, WED, THU, FRI, SAT, SUN;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
There are two rules that you need to remember while specifying values for annotation elements:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;You can omit the element name while specifying a value only when the name of the element is value and only when you are specifying just one value. In other words, if you are specifying values for more than one elements, you need to use the elementName=elementValue format for each element. The order of the elements is not important.&lt;/li&gt;
  &lt;li&gt;If an element expects an array, you can specify the values by enclosing them in { }. But if you want to specify an array of length 1, you may omit the { }.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;62.&lt;/strong&gt;
What will the following code fragment print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Path p1 = Paths.get(&quot;x\\y&quot;);
Path p2 = Paths.get(&quot;z&quot;);
Path p3 = p1.relativize(p2);
System.out.println(p3);

&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;x\y\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + \x\y\z =&amp;gt; x\y\x\y\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + \z =&amp;gt; x\y\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;..\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + ..\z =&amp;gt; x\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;..\..\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + ..\..\z =&amp;gt; x + ..\z =&amp;gt; z&lt;br /&gt;
This is what we want. So this is the correct answer.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;A â€œ..â€ implies parent folder, therefore imagine that you are taking off one â€œ..â€ from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.&lt;br /&gt;
For example, .. appended to y makes it y\.., which cancels out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, â€œa/câ€ relativize â€œa/bâ€  is â€œ../bâ€ because â€œ/a/c/../bâ€ is â€œ/a/bâ€ Notice that  â€œc/..â€ cancel out.&lt;/p&gt;

&lt;p&gt;Please go through the following description of relativize() method, which explains how it works in more detail.&lt;/p&gt;

&lt;p&gt;Note that in Java 11, the paths are first normalized before relativizing.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path relativize(Path other)&lt;/code&gt;&lt;br /&gt;
Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is â€œ/a/bâ€ and the given path is â€œ/a/b/c/dâ€ then the resulting relative path would be â€œc/dâ€.&lt;/p&gt;

&lt;p&gt;Where this path and the given path do not have a root component, then a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;A relative path cannot be constructed if only one of the paths have a root component.&lt;/p&gt;

&lt;p&gt;Where both paths have a root component then it is implementation dependent if a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;If this path and the given path are equal then an empty path is returned.&lt;/p&gt;

&lt;p&gt;For any two normalized paths p and q, where q does not have a root component,
p.relativize(p.resolve(q)).equals(q)&lt;/p&gt;

&lt;p&gt;When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is â€œ/a/bâ€ and the given path is â€œ/a/xâ€ then the resulting relative path may be â€œ../xâ€. If â€œbâ€ is a symbolic link then is implementation dependent if â€œa/b/../xâ€ would locate the same file as â€œ/a/xâ€.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;63.&lt;/strong&gt;
What will the following code fragment print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Path p1 = Paths.get(&quot;\\personal\\readme.txt&quot;);
Path p2 = Paths.get(&quot;\\index.html&quot;);
Path p3 = p1.relativize(p2);
System.out.println(p3);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + \index.html =&amp;gt;\personal\readme.txt\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\personal\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + \personal\index.html =&amp;gt;\personal\readme.txt\personal\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;personal\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + personal\index.html =&amp;gt;\personal\readme.txt\personal\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;..\..\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe that if you append this path to p1, you will get p2. Therefore, this is the right answer.&lt;br /&gt;
p1 + ....\index.html&lt;br /&gt;
=&amp;gt;\personal\readme.txt + ....\index.html&lt;br /&gt;
=&amp;gt;\personal + ..\index.html&lt;br /&gt;
=&amp;gt;\index.html&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;A â€œ..â€ implies parent folder, therefore imagine that you are taking off one â€œ..â€ from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.&lt;br /&gt;
For example, .. appended to personal makes it personal.., which cancels out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, â€œa/câ€ relativize â€œa/bâ€  is â€œ../bâ€ because â€œ/a/c/../bâ€ is â€œ/a/bâ€ Notice that  â€œc/..â€ cancel out.&lt;/p&gt;

&lt;p&gt;Note that in Java 11, the paths are first normalized before computing relativizing.&lt;/p&gt;

&lt;p&gt;Please go through the following description of relativize() method, which explains how it works in more detail.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path relativize(Path other)&lt;/code&gt;&lt;br /&gt;
Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is â€œ/a/bâ€ and the given path is â€œ/a/b/c/dâ€ then the resulting relative path would be â€œc/dâ€.&lt;/p&gt;

&lt;p&gt;Where this path and the given path do not have a root component, then a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;A relative path cannot be constructed if only one of the paths have a root component.&lt;/p&gt;

&lt;p&gt;Where both paths have a root component then it is implementation dependent if a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;If this path and the given path are equal then an empty path is returned.&lt;/p&gt;

&lt;p&gt;For any two normalized paths p and q, where q does not have a root component,
p.relativize(p.resolve(q)).equals(q)&lt;/p&gt;

&lt;p&gt;When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is â€œ/a/bâ€ and the given path is â€œ/a/xâ€ then the resulting relative path may be â€œ../xâ€. If â€œbâ€ is a symbolic link then is implementation dependent if â€œa/b/../xâ€ would locate the same file as â€œ/a/xâ€.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;65.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Boiler{
    public void boil();
    private static void log(String msg){ //1
       System.out.println(msg);
    }
    public static void shutdown(){
        log(&quot;shutting down&quot;);
    }
}
interface Vaporizer extends Boiler{  
    public default void vaporize(){
        boil();
        System.out.println(&quot;Vaporized!&quot;);
    }
}
public class Reactor implements Vaporizer{
    public void boil() {
        System.out.println(&quot;Boiling...&quot;);
    }

    public static void main(String[] args) {
        Vaporizer v =  new Reactor(); //2
        v.vaporize(); //3
        v.shutdown(); //4
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;Boiling...
Vaporized!
shutting down
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Compilation failure at //1.
    &lt;blockquote&gt;
      &lt;p&gt;Since Java 9, an interface is allowed to have private (but not protected) static as well as instance methods. Fields of an interface are still always implicitly public, static, and final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Compilation failure at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Compilation failure at //4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;If code at //4 is changed to Vaporizer.shutdown();, it will print  Boiling...
Vaporized!
shutting down
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Definition of interface Vaporizer will cause compilation to fail.
    &lt;blockquote&gt;
      &lt;p&gt;Definition of interface Vaporizer is fine.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember that static method of an interface can only be accessed by using the name of that interface. i.e. &lt;code&gt;Boiler.shutdown()&lt;/code&gt; in this case. This is unlike a static method of a class, which can be accessed using a subclass name or a variable name as well.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;66.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String value();
    String[] params();
    String date();
    int depth();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date = &quot;2019&quot;, depth = 10, params = &quot;index&quot;)
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The date element is defined as String. So, it doesnâ€™t really have to be a date. Any string value will be valid. params is defined as a &lt;code&gt;String[]&lt;/code&gt;. So, you can either use a single string such as used in this option or a String array such as &lt;code&gt;params={&quot;index&quot;}&lt;/code&gt; or &lt;code&gt;params={&quot;index1&quot;, &quot;whatever&quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date = &quot;01/01/2019&quot;, depth = &quot;10&quot;, params = &quot;index&quot; )
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;em&gt;depth&lt;/em&gt; is defined as &lt;code&gt;int&lt;/code&gt;, you canâ€™t pass â€œ10â€, You must pass 10 (i.e. without double quotes.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date=&quot;01/01/2019&quot;, depth=&quot;10&quot;, params = {&quot;index&quot;})
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;em&gt;depth&lt;/em&gt; is defined as &lt;code&gt;int&lt;/code&gt;, you canâ€™t pass â€œ10â€, You must pass 10 (i.e. without double quotes.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date=&quot;01/01/2019&quot;)
@DebugInfo(depth = 10, params = {&quot;index&quot;})
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since @DebugInfo is not annotated with @Repeatable, you can use this annotation only once at any place.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;69.&lt;/strong&gt;
Identify the correct statements about the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
class Person {
    private static int count = 0;
    private String id = &quot;0&quot;; private String interest;
    public Person(String interest){ this.interest = interest; this.id = &quot;&quot; + ++count; }
    public String getInterest(){ return interest;     }
    public void setInterest(String interest){ this.interest = interest; }
    public String toString(){ return id; }
}

public class StudyGroup
{
    String name = &quot;MATH&quot;;
    TreeSet&amp;lt;Person&amp;gt; set = new TreeSet&amp;lt;Person&amp;gt;();
    public void add(Person p) {
      if(name.equals(p.getInterest())) set.add(p);
    }

    public static void main(String[] args) {
      StudyGroup mathGroup = new StudyGroup();
      mathGroup.add(new Person(&quot;MATH&quot;));
      System.out.println(&quot;A&quot;);
      mathGroup.add(new Person(&quot;MATH&quot;));
      System.out.println(&quot;B&quot;);
      System.out.println(mathGroup.set);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print : A, B, and then the contents of mathGroup.set.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will compile with a warning.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will NOT throw an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will compile without warning but will throw an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will only print : A&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print : A and B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Note that &lt;code&gt;TreeSet&lt;/code&gt; is an ordered set that keeps its elements in a sorted fashion. When you call the &lt;code&gt;add()&lt;/code&gt; method, it immediately compares the element to be added to the existing elements and puts the new element in its appropriate place. Thus, the foremost requirement of a &lt;code&gt;TreeSet&lt;/code&gt; is that the elements must either implement &lt;code&gt;Comparable&lt;/code&gt; interface (which has the &lt;code&gt;compareTo(Object) method)&lt;/code&gt; and they must also be mutually comparable or the &lt;code&gt;TreeSet&lt;/code&gt; must be created with by passing a &lt;code&gt;Comparator&lt;/code&gt; (which has a &lt;code&gt;compare(Object, Object)&lt;/code&gt; method). For example, you might have two classes \\\A\\\ and \\\B\\\ both implementing &lt;code&gt;Comparable&lt;/code&gt; interface. But if their &lt;code&gt;compareTo()&lt;/code&gt; method does not work with both the types, you cannot add both type of elements in the same &lt;code&gt;TreeSet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this question, &lt;code&gt;Person&lt;/code&gt; class does not implement &lt;code&gt;Comparable&lt;/code&gt; interface. Ideally, when you add the first element, since there is nothing to compare this element to, there should be no exception. But when you add the second element, &lt;code&gt;TreeSet&lt;/code&gt; tries to compare it with the existing element, thereby throwing &lt;code&gt;ClassCastException&lt;/code&gt; because they donâ€™t implement &lt;code&gt;Comparable&lt;/code&gt; interface. However, this behavior was changed in the &lt;code&gt;TreeSet&lt;/code&gt; implementation recently and it throws a &lt;code&gt;ClassCastException&lt;/code&gt; when you add the first element itself.&lt;/p&gt;

&lt;p&gt;The compiler knows nothing about this requirement of &lt;code&gt;TreeSet&lt;/code&gt; since it is an application level requirement and not a language level requirement. So the program compiles fine without any warning.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;70.&lt;/strong&gt;
java.util.Locale allows you to do which of the following?&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country specific formatting for fonts.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country and language specific for HTML pages.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Provide country and language specific formatting for Dates.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Provide country specific formatting for Currencies.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country and language specific formatting for properties files.
    &lt;blockquote&gt;
      &lt;p&gt;The objective of Localization is not to format properties files but to format the data that is displayed to the user in country/language specific manner. Resource Bundles, which are nothing but appropriately named properties files, are used along with the &lt;code&gt;Locale&lt;/code&gt; (i.e. country and language) information to format &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Currencies&lt;/code&gt;, and text messages in Locale specific manner.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;73.&lt;/strong&gt;
Identify valid statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocal = System.getDefaultLocale();
    &lt;blockquote&gt;
      &lt;p&gt;There is no such method in System class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocale = Locale.getDefaultLocale();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = Locale.getDefault();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = Locale.US;
    &lt;blockquote&gt;
      &lt;p&gt;Locale class has several static constants for standard country locales.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocale = Locale.getInstance();
    &lt;blockquote&gt;
      &lt;p&gt;There is no getInstance() method in Locale.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = new Locale(â€œruâ€, â€œRUâ€);
    &lt;blockquote&gt;
      &lt;p&gt;You donâ€™t have to worry about the actual values of the language and country codes. Just remember that both are two lettered codes and country codes are always upper case.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;74.&lt;/strong&gt;
Consider the following classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Boo {
    public Boo(){ System.out.println(&quot;In Boo&quot;); }
}
class BooBoo extends Boo {
    public BooBoo(){ System.out.println(&quot;In BooBoo&quot;); }
}

class Moo extends BooBoo implements Serializable {
    int moo = 10; { System.out.println(&quot;moo set to 10&quot;); }
    public Moo(){ System.out.println(&quot;In Moo&quot;); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the following code was executed and the file moo1.ser was created successfully:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  Moo moo = new Moo();
  moo.moo = 20;
  FileOutputStream fos = new FileOutputStream(&quot;c:\\temp\\moo1.ser&quot;);
  ObjectOutputStream os = new ObjectOutputStream(fos);
  os.writeObject(moo);
  os.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, the following code was executed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  FileInputStream fis = new FileInputStream(&quot;c:\\temp\\moo1.ser&quot;);
  ObjectInputStream is = new ObjectInputStream(fis);
  Moo moo = (Moo) is.readObject();
  is.close();
  System.out.println(moo.moo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following will be a part of the output of the second piece of code?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;In Boo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;In BooBoo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;In Moo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;10&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;20&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;moo set to 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
During deserialization, the constructor of the class (or any static or instance blocks) is not executed. However, if the super class does not implement Serializable, its constructor is called. So here, &lt;code&gt;BooBoo&lt;/code&gt; and &lt;code&gt;Boo&lt;/code&gt; are not Serializable. So, their constructor is invoked.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;75.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;

interface Birdie {
    void fly();
}

class Dino implements Birdie {
    public void fly(){ System.out.println(&quot;Dino flies&quot;); }
    public void eat(){ System.out.println(&quot;Dino eats&quot;);}
}

class Bino extends Dino {
    public void fly(){ System.out.println(&quot;Bino flies&quot;); }
    public void eat(){ System.out.println(&quot;Bino eats&quot;);}
}

public class TestClass {
    public static void main(String[] args)    {
       List&amp;lt;Birdie&amp;gt; m = new ArrayList&amp;lt;&amp;gt;();
       m.add(new Dino());
       m.add(new Bino());
       for(Birdie b : m) {
    b.fly();
    b.eat();
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dino flies
Dino eats
Bino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Bino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;The code will not compile.
    &lt;blockquote&gt;
      &lt;p&gt;Note that in the for loop b has been declared to be of type Birdie. But Birdie doesnâ€™t define the method eat(), so the compiler will not allow b.eat() even though the actual class of the object referred to by b does have an eat() method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception at run time.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;76.&lt;/strong&gt;
Consider the following program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.FileReader;
import java.io.FileWriter;

public class ClosingTest {
    public static void main(String[] args) throws Exception {
        try(FileReader fr = new FileReader(&quot;c:\\temp\\license.txt&quot;);
            FileWriter fw = new FileWriter(&quot;c:\\temp\\license2.txt&quot;) )
        {
            int x = -1;
            while( (x = fr.read()) != -1){
                fw.write(x);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify the correct statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The FileWriter object will always be closed before the FileReader object.
    &lt;blockquote&gt;
      &lt;p&gt;Resources are closed automatically at the end of the try block in reverse order of their creation.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The order of the closure of the FileWriter and FileReader objects is platform dependent and should not be relied upon.
    &lt;blockquote&gt;
      &lt;p&gt;The order is defined. They are always closed in the reverse order.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The FileWriter object will not be closed if an exception is thrown while closing the FileReader object.
    &lt;blockquote&gt;
      &lt;p&gt;The close method is called on all the resources one by one even if any resource throws an exception in its close method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This is not a fail safe approach to managing resources because in certain situations one or both of the resources may be left open after the end of the try block.
    &lt;blockquote&gt;
      &lt;p&gt;This is the right approach. The close method will be called automatically on all the resources that were opened even if any exception is thrown any where.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;77.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Book{
    private String title;
    private double price;
    public Book(String title, double price){
        this.title = title;
        this.price = price;
    }
    //getters/setters not shown
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will the following code print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Book&amp;gt; books = Arrays.asList(new Book(&quot;Thinking in Java&quot;, 30.0),
                                 new Book(&quot;Java in 24 hrs&quot;, 20.0),
                                 new Book(&quot;Java Recipies&quot;, 10.0));
double averagePrice = books.stream().filter(b-&amp;gt;b.getPrice()&amp;gt;10)
        .mapToDouble(b-&amp;gt;b.getPrice())
        .average().getAsDouble();
System.out.println(averagePrice);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will thrown an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;0.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;25.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition &lt;code&gt;b.getPrice()&amp;gt;10&lt;/code&gt;, which means only two elements are left in the stream, second, it maps each &lt;code&gt;Book&lt;/code&gt; element to a double using the mapping function &lt;code&gt;b.getPrice()&lt;/code&gt;, which means, the stream now contains two doubles - &lt;em&gt;20.0&lt;/em&gt; and &lt;em&gt;30.0&lt;/em&gt;. Finally, the &lt;code&gt;average()&lt;/code&gt; method computes the average of all the elements. Therefore, the code will print &lt;em&gt;25.0&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition &lt;code&gt;b.getPrice()&amp;gt;10&lt;/code&gt;, which means only two elements are left in the stream, second, it maps each &lt;code&gt;Book&lt;/code&gt; element to a double using the mapping function &lt;code&gt;b.getPrice()&lt;/code&gt;, which means, the stream now contains two doubles - &lt;em&gt;20.0&lt;/em&gt; and &lt;em&gt;30.0&lt;/em&gt;. Finally, the &lt;code&gt;average()&lt;/code&gt; method computes the average of all the elements. Therefore, the code will print &lt;em&gt;25.0&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;79.&lt;/strong&gt;
Your group has an existing application (reports.jar) that uses a library (analytics.jar) from another group in your company. Both - the application and the library - use a JDBC driver packaged in ojdbc8.jar.&lt;/p&gt;

&lt;p&gt;Which of the following options describes the steps that will be required to modularize your application?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert analytics.jar and ojdbc8.jar into automatic modules  
2. Convert reports.jar into a named module.  
3. Add requires clauses for analytics and ojdbc8 in reports.jar in its module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Modularize analytics.jar and ojdbc8.jar into modules by adding module-info.java to these jars. 2. Convert reports.jar into a named module. 3. Add requires clauses for all packages contained in analytics.jar and ojdbc8.jar that are directly referred to by classes in reports.jar in its module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert reports.jar into a named module. 2. Add requires clauses for analytics and ojdbc8 modules in reports.jar in its module-info.java. 3. Use analytics.jar and ojdbc8.jar as unnamed modules.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert ojdbc8.jar into automatic module. 2. Convert analytics.jar into a named module by adding module-info.java to it. In this module-info, export all packages that are used by reports.jar and add requires clauses for all packages of ojdbc.jar that are used by analytics.jar. 3. Convert reports.jar into a named module. Add requires clause for analytics module in reports's module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
If a module directly uses classes from another jar, then that jar has to be converted into a module (either named or automatic).&lt;/p&gt;

&lt;p&gt;So, if you want to modularize reports.jar, then analytics.jar and ojdbc8.jar must also be converted into a module. Since these two jars are not controlled by you, they can be converted into automatic modules.&lt;/p&gt;

&lt;p&gt;module-info for reports.jar must have requires clauses for the two automatic modules (whose names will be analytics and ojdbc8).&lt;/p&gt;

&lt;p&gt;Since an automatic module is allowed to access classes from all other modules, nothing special needs to be done for analytics.jar. It will be able to access all classes from ojdbc.jar.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;80.&lt;/strong&gt;
Which of the given options if put at //1 will correctly instantiate objects of various classes defined in the following code?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class TestClass
{
   public class A{
   }
   public static class B {
   }
   public static void main(String args[]){
      class C{
      }
      //1
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;new TestClass().new A();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass().new B();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass.A();
    &lt;blockquote&gt;
      &lt;p&gt;A is not static. So on outer instance of TestClass is necessary.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;new C();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass.C();&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
class A is not static inner class of &lt;code&gt;TestClass&lt;/code&gt;. So it cannot exist without an outer instance of &lt;code&gt;TestClass&lt;/code&gt;. So, option 1 is the right way to instantiate it. class B is static inner class and can be instantiated like this: &lt;code&gt;new TestClass.B()&lt;/code&gt;. But &lt;code&gt;new TestClass().new B()&lt;/code&gt; is not correct.&lt;br /&gt;
Although not related to this question, unlike popular belief, anonymous class can never be static. Even if created in a static method.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;81.&lt;/strong&gt;
Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Statement stmt = null;
try(Connection c = DriverManager.getConnection(&quot;jdbc:derby://localhost:1527/sample&quot;, &quot;app&quot;, &quot;app&quot;))
{
    stmt = c.createStatement();
    ResultSet rs = stmt.executeQuery(&quot;select * from STUDENT&quot;);
    while(rs.next()){
        System.out.println(rs.getString(1));
    }

}
catch(SQLException e){
    System.out.println(&quot;Exception &quot;+e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which objects can be successfully used to query the database after the try block ends without any exception?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt as well c&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;None of them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
There are a few things to note in the question:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Once a &lt;code&gt;Connection&lt;/code&gt; object is closed, you cannot access any of the subsequent objects such as &lt;code&gt;Statement&lt;/code&gt; and &lt;code&gt;ResultSet&lt;/code&gt; that are retrieved from that &lt;code&gt;Connection&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The references declared in the try block (in this case, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;ResultSet&lt;/code&gt;) are not visible outside the try block. Not even in the catch block.&lt;/li&gt;
  &lt;li&gt;When a resource is created in the try-with-resources block ( in this case, c), it is closed at the end of the try block irrespective of whether there is an exception in the try block or not.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on the above, it is easy to see that only stmt is visible after the try block but it cannot be successfully used because the &lt;code&gt;Connection&lt;/code&gt; object from which it was retrieved has already been closed.&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Mar 2020 12:20:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/28/ocp-mock-test2-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/28/ocp-mock-test2-review/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>è®¤è¯è€ƒè¯•</category>
        
        
      </item>
    
      <item>
        <title>ç¬¬11ç« ç»ƒä¹ å›é¡¾</title>
        <description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Which of the following is an advantage of the Java Platform Module System? &lt;strong&gt;B&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A.&lt;/strong&gt; A central repository of all modules&lt;br /&gt;
&lt;strong&gt;B.&lt;/strong&gt; Encapsulating packages&lt;br /&gt;
&lt;strong&gt;C.&lt;/strong&gt; Encapsulating objects&lt;br /&gt;
&lt;strong&gt;D.&lt;/strong&gt; No defined types&lt;br /&gt;
&lt;strong&gt;E.&lt;/strong&gt; Platform independence&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Which statement is true of the following module? &lt;strong&gt;D&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;zoo.staff
|---zoo
|-- staff
|-- Vet.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;A.&lt;/strong&gt; The directory structure shown is a valid module.&lt;br /&gt;
&lt;strong&gt;B.&lt;/strong&gt; The directory structure would be a valid module if module.java were added directly underneath zoo.staff.&lt;br /&gt;
&lt;strong&gt;C.&lt;/strong&gt; The directory structure would be a valid module if module.java were added directly underneath zoo.&lt;br /&gt;
&lt;strong&gt;D.&lt;/strong&gt; The directory structure would be a valid module if module-info.java were added directly underneath zoo.staff.&lt;br /&gt;
&lt;strong&gt;E.&lt;/strong&gt; The directory structure would be a valid module if module-info.java were added directly underneath zoo.&lt;br /&gt;
&lt;strong&gt;F.&lt;/strong&gt; None of these changes would make this directory structure a valid module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;è§£é‡Šï¼š&lt;/strong&gt;  Modules are required to have a module-info.java file at the root directory of the module. Option D matches this requirement.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; B&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; D -&amp;gt; G The -m or â€“module option is used to specify the module and class name. The -p or -module-path option is used to specify the location of the modules. Option D would be correct if the rest of the command were correct. However, running a program requires specifying the package name with periods (.) instead of slashes. Since the command is incorrect, option G is correct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; AF -&amp;gt; AFG Options C and D are incorrect because there is no use keyword. Options A and F are correct because opens is for reflection and uses declares an API that consumes a service. Option G is also correct as the file can be completely empty. This is just something you have to memorize.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; BDF -&amp;gt; BC Packages inside a module are not exported by default, making option B correct and option A incorrect. Exporting is necessary for other code to use the packages; it is not necessary to call the main() method at the command line, making option C correct and option D incorrect. The module-info.java file has the correct name and compiles, making options E and F incorrect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt; EF -&amp;gt; DG Options A, B, E, and F are incorrect because they refer to keywords that donâ€™t exist. The requires transitive keyword is used when specifying a module to be used by the requesting module and any other modules that use the requesting module. Therefore, dog needs to specify the transitive relationship, and option G is correct. The module puppy just needs to require dog, and it gets the transitive dependencies, making option D correct.&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt; ABCD -&amp;gt; ABD Options A and B are correct because the -p (â€“module-path) option can be passed when compiling or running a program. Option D is also correct because jdeps can use the â€“module-path option when listing dependency information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.&lt;/strong&gt; AEF -&amp;gt; AB The -p specifies the module path. This is just a directory, so all of the options have a legal module path. The -m specifies the module, which has two parts separated by a slash. Options E and F are incorrect since there is no slash. The first part is the module name. It is separated by periods (.) rather than dashes (-), making option C incorrect. The second part is the package and class name, again separated by periods. The package and class names must be legal Java identifiers. Dashes (-) are not allowed, ruling out option D. This leaves options A and B as the correct answers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.&lt;/strong&gt; B&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.&lt;/strong&gt; ABD -&amp;gt; BDEF This is another question you just have to memorize. The jmod command has five modes you need to be able to list: create, extract, describe, list, and hash. The hash operation is not an answer choice. The other four are making options B, D, E, and F correct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12.&lt;/strong&gt; A -&amp;gt; B The java command uses this option to print information when the program loads. You might think jar does the same thing since it runs a program too. Alas, this parameter does not exist on jar.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13.&lt;/strong&gt; AD -&amp;gt; E There is a trick here. A module definition uses the keyword module rather than class. Since the code does not compile, option E is correct. If the code did compile, options A and D would be correct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14.&lt;/strong&gt; A&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15.&lt;/strong&gt; AD -&amp;gt; BD The java command has an â€“add-exports option that allows exporting a package at runtime. However, it is not encouraged to use it, making options B and D the answer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16.&lt;/strong&gt; BC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17.&lt;/strong&gt; D -&amp;gt; E&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18.&lt;/strong&gt; AC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19.&lt;/strong&gt; BC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20.&lt;/strong&gt; BE&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21.&lt;/strong&gt; G&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Mar 2020 18:42:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/22/chapter11-exam-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/22/chapter11-exam-review/</guid>
        
        <category>Java</category>
        
        <category>OCP</category>
        
        
      </item>
    
      <item>
        <title>RSocketä¸Spring Securityç®€å•æ•´åˆ</title>
        <description>&lt;h3 id=&quot;åˆ›å»ºå·¥ç¨‹&quot;&gt;åˆ›å»ºå·¥ç¨‹&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;greetings-service&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;åœ¨ start.spring.io é€‰æ‹© 2.3.0 M2 ç‰ˆæœ¬ Spring Bootï¼Œä¾èµ–é¡¹å¦‚ä¸‹&lt;/p&gt;

      &lt;p&gt;Lombok&lt;/p&gt;

      &lt;p&gt;RSocket&lt;/p&gt;

      &lt;p&gt;Spring Security&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;greetings-client&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;å®¢æˆ·ç«¯çš„ä¾èµ–é¡¹ä¹Ÿæ˜¯&lt;/p&gt;

      &lt;p&gt;Lombok&lt;/p&gt;

      &lt;p&gt;RSocket&lt;/p&gt;

      &lt;p&gt;Spring Security&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;æœåŠ¡ç«¯åº”ç”¨&quot;&gt;æœåŠ¡ç«¯åº”ç”¨&lt;/h4&gt;

&lt;p&gt;GreetingsServiceApplication.java  &lt;!--more--&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// çœç•¥å¯¼å…¥
// ä¸€ä¸ªç®€å•çš„ï¼ŒåŸºäºç”¨æˆ·åå’Œå¯†ç çš„â€œé—®å€™â€åº”ç”¨
// ç®€å•èµ·è§ï¼Œæ‰€æœ‰ç±»éƒ½å†™åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œ
@SpringBootApplication
public class GreetingsServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(GreetingsServiceApplication.class, args);
    }
}

@Configuration
@EnableRSocketSecurity
class RSocketSecurityConfiguration {

    @Bean
    RSocketMessageHandler messageHandler(RSocketStrategies strategies) {
        RSocketMessageHandler mh = new RSocketMessageHandler();
        mh.getArgumentResolverConfigurer()
            .addCustomResolver(new AuthenticationPrincipalArgumentResolver());
        mh.setRSocketStrategies(strategies);
        return mh;
    }

    // æˆæƒ
    @Bean
    PayloadSocketAcceptorInterceptor authorization(RSocketSecurity security) {
        return security
                .authorizePayload(spec -&amp;gt; spec
                        .route(&quot;greetings&quot;)
                        .authenticated()
                        .anyExchange()
                        .permitAll())
                .simpleAuthentication(Customizer.withDefaults())
                .build();
    }

    // ç”¨æˆ·è®¤è¯ Authentication
    @Bean
    MapReactiveUserDetailsService authentication() {
        UserDetails jlong = User.withDefaultPasswordEncoder().username(&quot;jlong&quot;)
            .password(&quot;pw&quot;).roles(&quot;USER&quot;).build();
        UserDetails rwinch = User.withDefaultPasswordEncoder().username(&quot;rwinch&quot;)
            .password(&quot;pw&quot;).roles(&quot;ADMIN&quot;, &quot;USER&quot;).build();
        return new MapReactiveUserDetailsService(jlong, rwinch);
    }
}

// DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
class GreetingResponse {
    private String message;
}

@Controller
class GreetingController {

    @MessageMapping(&quot;greetings&quot;)
    Flux&amp;lt;GreetingResponse&amp;gt; greet(@AuthenticationPrincipal Mono&amp;lt;UserDetails&amp;gt; user) {
        return user
                .map(UserDetails::getUsername)
                .flatMapMany(GreetingController::greet);
    }

    private static Flux&amp;lt;GreetingResponse&amp;gt; greet(String name) {
        return Flux.fromStream(
                Stream.generate(() -&amp;gt; 
                new GreetingResponse(&quot;Hello &quot; + name + &quot; @ &quot; + 
                Instant.now().toString())))
                .delayElements(Duration.ofSeconds(1));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;æœåŠ¡ç«¯çš„é…ç½®æ–‡ä»¶&lt;/strong&gt;ï¼šapplication.properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-properties&quot;&gt;spring.rsocket.server.port=8888
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;å®¢æˆ·ç«¯åº”ç”¨&quot;&gt;å®¢æˆ·ç«¯åº”ç”¨&lt;/h4&gt;

&lt;p&gt;GreetingsClientApplication.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@Log4j2
public class GreetingsClientApplication {

    @SneakyThrows
    public static void main(String[] args) {
        SpringApplication.run(GreetingsClientApplication.class, args);
        System.in.read(); // è®©ç¨‹åºä¸è¦ç»“æŸ
    }

    private final MimeType mimeType =
            MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
    private final UsernamePasswordMetadata credentials = new UsernamePasswordMetadata(&quot;jlong&quot;, &quot;pw&quot;);

    // é…ç½®æ‰€ç”¨ç¼–ç å™¨
    @Bean
    RSocketStrategiesCustomizer rSocketStrategiesCustomizer() {
        return strategies -&amp;gt; strategies.encoder(new SimpleAuthenticationEncoder());
    }

    // ç›¸å½“äºå®¢æˆ·ç«¯
    @Bean
    RSocketRequester rSocketRequester(RSocketRequester.Builder builder) {
        return builder
                //.setupMetadata(this.credentials, this.mimeType)
                .connectTcp(&quot;localhost&quot;, 8888)
                .block();
    }

    // åº”ç”¨å°±ç»ªæ—¶é€šè¿‡RSocketå‘localhost:8888/greetingså‘èµ·è¯·æ±‚
    // å¹¶å°†å“åº”æ¶ˆæ¯é€šè¿‡æ—¥å¿—è¾“å‡ºåˆ°æ§åˆ¶å°
    @Bean
    ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; ready(RSocketRequester greetings) {
        return event -&amp;gt; greetings
                .route(&quot;greetings&quot;)
                .metadata(this.credentials, this.mimeType)
                .data(Mono.empty())
                .retrieveFlux(GreetingResponse.class)
                .subscribe(gr -&amp;gt; log.info(&quot;secured response: &quot; + gr.toString()));
    }
}

// DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
class GreetingResponse {
    private String message;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ç»“æŸ&quot;&gt;ç»“æŸ&lt;/h3&gt;

&lt;p&gt;æ„Ÿè§‰ç›´æ¥çœ‹ä»£ç ä¹ŸæŒºå¥½ç†è§£çš„ï¼Œå°±ä¸å‹‰å¼ºæ·»åŠ å¤ªå¤šæ–‡å­—è¯´æ˜äº†ã€‚æœ‰ä»€ä¹ˆä¸æ˜ç™½çš„ï¼Œå¯ä»¥çœ‹&lt;a href=&quot;https://www.bilibili.com/video/av95256090&quot;&gt;è§†é¢‘è®²è§£&lt;/a&gt;ã€‚&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Mar 2020 21:00:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/10/spring-tips-rsocket-spring-security/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/10/spring-tips-rsocket-spring-security/</guid>
        
        <category>RSocket</category>
        
        <category>Spring Security</category>
        
        <category>Authentication</category>
        
        
      </item>
    
      <item>
        <title>ç½‘ç»œçˆ¬è™«å­¦ä¹ ç¬”è®°</title>
        <description>&lt;h3 id=&quot;è¯¾ç¨‹è®¡åˆ’&quot;&gt;è¯¾ç¨‹è®¡åˆ’&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;å…¥é—¨&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HttpClient&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jsoup&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;æ¡ˆä¾‹&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;dependencies {
    implementation('org.jsoup:jsoup:1.12.2')
    implementation('org.apache.httpcomponents:httpclient:4.5.2')
  
    testImplementation('org.slf4j:slf4j-log4j12:1.7.25')
    testImplementation('org.junit.jupiter:junit-jupiter:5.6.0')
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;çˆ¬è™«åŠŸèƒ½&quot;&gt;çˆ¬è™«åŠŸèƒ½&lt;/h3&gt;

&lt;p&gt;ä»åŠŸèƒ½ä¸Šæ¥è®²ï¼Œçˆ¬è™«ä¸€èˆ¬åˆ†ä¸ºæ•°æ®é‡‡é›†ï¼Œå¤„ç†ï¼Œå­˜å‚¨ä¸‰ä¸ªéƒ¨åˆ†ã€‚çˆ¬è™«ä»ä¸€ä¸ªæˆ–è‹¥å¹²ä¸ªåˆå§‹é¡µé¢çš„URLå¼€å§‹ï¼Œè·å¾—åˆå§‹é¡µé¢ä¸Šçš„URLï¼Œåœ¨æŠ“å–é¡µé¢çš„è¿‡ç¨‹ä¸­ï¼Œä¸æ–­ä»å½“å‰é¡µé¢æŠ½å–æ–°çš„URLæ”¾å…¥é˜Ÿåˆ—ï¼Œç›´åˆ°æ»¡è¶³ç³»ç»Ÿçš„ä¸€å®šåœæ­¢æ¡ä»¶ã€‚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;æ•°æ®é‡‡é›†&lt;/li&gt;
  &lt;li&gt;å¤„ç†&lt;/li&gt;
  &lt;li&gt;å­˜å‚¨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ä»åˆå§‹é¡µé¢å¼€å§‹ï¼Œçˆ¬å–è¿™ä¸ªé¡µé¢é‡Œé¢çš„è¯¦ç»†é¡µé¢è¿æ¥ï¼Œæ¥ç€æ˜¯ä¸‹ä¸€é¡µï¼Œç­‰ç­‰ã€‚&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;ä¸ºä»€ä¹ˆå­¦ä¹ ç½‘ç»œçˆ¬è™«&quot;&gt;ä¸ºä»€ä¹ˆå­¦ä¹ ç½‘ç»œçˆ¬è™«&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;å¯ä»¥å®ç°æœç´¢å¼•æ“&lt;/p&gt;

    &lt;p&gt;æœé›†ï¼Œè‡ªå·±æ„Ÿå…´è¶£çš„æ•°æ®ã€‚åšå¥½ç©çš„äº‹æƒ…ã€‚&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;å¤§æ•°æ®æ—¶ä»£ï¼Œè·å–æ›´å¤šæ•°æ®æºï¼Œäººå·¥æ™ºèƒ½&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;æ•°æ®åˆ†æ&lt;/li&gt;
      &lt;li&gt;æ•°æ®æŒ–æ˜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;æœç´¢å¼•æ“ä¼˜åŒ–ï¼Œç½‘ç«™æ¨å¹¿ï¼Œç ”ç©¶è§„åˆ™&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;å°±ä¸šï¼Œæ•°æ®å·¥ç¨‹å¸ˆï¼Œçˆ¬è™«å·¥ç¨‹å¸ˆï¼Œ Microsoft Health,  Data mining&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;å¸¦å‚æ•°çš„-get-è¯·æ±‚&quot;&gt;å¸¦å‚æ•°çš„ GET è¯·æ±‚&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HttpGet&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;post-è¯·æ±‚&quot;&gt;POST è¯·æ±‚&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HttpPost ä¸å¸¦å‚æ•°&lt;/li&gt;
  &lt;li&gt;å¸¦å‚æ•°&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[To be continued!]&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Mar 2020 19:30:00 +0000</pubDate>
        <link>https://zwt.io/2020/03/02/web-scraping-notes/</link>
        <guid isPermaLink="true">https://zwt.io/2020/03/02/web-scraping-notes/</guid>
        
        <category>Java</category>
        
        <category>çˆ¬è™«</category>
        
        <category>scraping</category>
        
        
      </item>
    
      <item>
        <title>OCP-1Z0-816 æ¨¡æ‹Ÿæµ‹è¯•1å›é¡¾</title>
        <description>&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Path p1 = Paths.get(&quot;c:\\temp\\test1.txt&quot;);
Path p2 = Paths.get(&quot;c:\\temp\\test2.txt&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following code fragments moves the file test1.txt to test2.txt, even if test2.txt exists?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Files.move(p1, p2);
    &lt;blockquote&gt;
      &lt;p&gt;This will throw a &lt;code&gt;java.nio.file.FileAlreadyExistsException&lt;/code&gt; if the file already exists.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Files.move(p1, p2, StandardCopyOption.REPLACE_EXISTING);&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;try(Files.move(p1, p2)) { }
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code&gt;Files.move&lt;/code&gt; returns a &lt;code&gt;Path&lt;/code&gt; object (of the destination file), which is not a resource that can be closed because it does not implement &lt;code&gt;AutoCloseable&lt;/code&gt; interface. So this will not compile.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;try(Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING)) { Files.delete(p1); }&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING); Files.delete(p1);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Files.copy method will copy the test1.txt into test2.txt. If test2.txt doesnâ€™t exist, it will be created. However, Files.isSameFile method doesnâ€™t check the contents of the file. It is meant to check if the two path objects resolve to the same file or not. In this case, they are not, and so, it will return false.&lt;br /&gt;
The following is brief JavaDoc description for both the methods:&lt;br /&gt;
&lt;code&gt;public static Path copy(Path source, Path target, CopyOption... option) throws IOException&lt;/code&gt;  &lt;!--more--&gt;
Copy a file to a target file.&lt;br /&gt;
This method copies a file to the target file with the options parameter specifying how the copy is performed. By default, the copy fails if the target file already exists or is a symbolic link, except if the source are the same file, in which case the method completes without copying the file.&lt;br /&gt;
File attributes are not required to be copied to the target file. If symbolic links are supported, and the file is a symbolic link, then the final target of the link is copied. If the file is a directory in the target location(entries in the directory are not copies).&lt;br /&gt;
The options parameter may include any of the following:&lt;br /&gt;
&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt; If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.&lt;br /&gt;
&lt;strong&gt;COPY_ATTRIBUTES&lt;/strong&gt; Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file store. Copying of file timestamps may result in precision loss.&lt;br /&gt;
&lt;strong&gt;NOFOLLOW_LINKS&lt;/strong&gt; Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link. In other words, the &lt;strong&gt;COPY_ATTRIBUTES&lt;/strong&gt; option may be ignored when copying a symbolic link.&lt;br /&gt;
An implementation of this interface may support additional implementation specific options.&lt;br /&gt;
Copying a file is not an atomic operation. If an &lt;code&gt;IOException&lt;/code&gt; is thrown then it possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the &lt;code&gt;REPLACE_EXISTING&lt;/code&gt; option is specified and the target file exists, then the target file is replaced. The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities.&lt;br /&gt;
&lt;code&gt;public static Path move(Path source, Path target, CopyOption... options) throws IOException&lt;/code&gt;&lt;br /&gt;
Move or rename a file to a target file.&lt;br /&gt;
By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not require moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an &lt;code&gt;IOException&lt;/code&gt;). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the Files.walkFileTree utility method.&lt;br /&gt;
The options parameter may include any of the following:&lt;br /&gt;
&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt;  If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.
&lt;strong&gt;ATOMIC_MOVE&lt;/strong&gt; The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;code&gt;IOException&lt;/code&gt;. If the move cannot be performed as an atomic file system operation then &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options.&lt;br /&gt;
Where the move requires that the file be copied then the last-modified-time is copied to the new file. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and a IOException is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class LowBalanceException extends ____ {  // 1
    public LowBalanceException(String msg) { super(msg); }
}

class WithdrawalException extends ____ { // 2 
    public WithdrawalException(String msg) { super(msg); }
}

class Account {
    double balance;
    public void withdraw(double amount) throws WithdrawalException {
        try {
            throw new RuntimeException(&quot;Not Implemented&quot;);
        } catch (Exception e) {
            throw new LowBalanceException( e.getMessage());
        }
    }
    public static void main(String[] args) {
        try {
            Account a = new Account();
            a.withdraw(100.0);
        } catch(Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What can be inserted at // 1 and // 2 so that the above code will prints Not Implemented?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception Exception&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception LowBalanceException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;WithdrawalException Exception&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;WithdrawalException RuntimeException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; The withdraw method declares that it throws &lt;code&gt;WithdrawalException&lt;/code&gt;. This means that the only exceptions that can come out of this method are WithdrawalExceptions (which means &lt;code&gt;WithdrawalException&lt;/code&gt; or its subclasses) or RuntimeExceptions.&lt;br /&gt;
&lt;strong&gt;2.&lt;/strong&gt; The try block in withdraw method throws a &lt;code&gt;RuntimeException&lt;/code&gt;. It will be caught by the &lt;code&gt;catch(Exception)&lt;/code&gt; block because &lt;code&gt;RuntimeException&lt;/code&gt; is-a &lt;code&gt;Exception&lt;/code&gt;. The code in the catch block throws a LowBalanceException, which is not caught. Thus, it will be thrown out of this method, which means LowBalanceException must either be a &lt;code&gt;RuntimeException&lt;/code&gt; or be a &lt;code&gt;WithdrawalException&lt;/code&gt; (i.e. must extend &lt;code&gt;WithdrawalException&lt;/code&gt;) to satisfy the throws clause of the withdraw method.&lt;br /&gt;
&lt;strong&gt;3.&lt;/strong&gt; The &lt;code&gt;main()&lt;/code&gt; method does not have a throws clause but the call to &lt;code&gt;withdraw()&lt;/code&gt; is enclosed within a try block with &lt;code&gt;catch(Exception)&lt;/code&gt;. Thus, &lt;code&gt;WithdrawalException&lt;/code&gt; can extend either &lt;code&gt;Exception&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; Which of the following lines will cause the compilation to fail?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public enum EnumA{ A, AA, AAA};  //1

public class TestClass //2
{
  public enum EnumB { B, BB, BBB }; //3
  public static enum EnumC { C, CC, CCC }; //4
  public TestClass()
  {
    enum EnumD { D, DD, DDD } //5
  }
  public void methodX()
  {
    public enum EnumE{ E, EE, EEE } //6
  }
  public static void main(String[] args) //7
  {
    enum EnumF {F, FF, FFF }; //8
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;1,2, or both depending on the file name.
    &lt;blockquote&gt;
      &lt;p&gt;Since both EnumA and TestClass are public, they must be defined in a file with a name of EnumA.java and TestClass.java respectively.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;3
    &lt;blockquote&gt;
      &lt;p&gt;A public (or non-public) enum can be defined inside any class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;4
    &lt;blockquote&gt;
      &lt;p&gt;A enum can be defined as a static member of any class. You can also have multiple public enums with in the same class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;5
    &lt;blockquote&gt;
      &lt;p&gt;An enum cannot be defined inside any method or constructor&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;6
    &lt;blockquote&gt;
      &lt;p&gt;An enum cannot be defined inside any method or constructor&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;7
    &lt;blockquote&gt;
      &lt;p&gt;There is nothing wrong with this line.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;8
    &lt;blockquote&gt;
      &lt;p&gt;An enum cannot be defined inside any method or constructor&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to know the following facts about enums:&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.&lt;br /&gt;
&lt;strong&gt;2.&lt;/strong&gt; An enum is implicitly final, which means you cannot extend it.&lt;br /&gt;
&lt;strong&gt;3.&lt;/strong&gt; You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces.&lt;br /&gt;
&lt;strong&gt;4.&lt;/strong&gt; Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final.&lt;br /&gt;
&lt;strong&gt;5.&lt;/strong&gt; Compiler provides an enum with two public static methods automatically - &lt;code&gt;values()&lt;/code&gt; and &lt;code&gt;valueOf(String)&lt;/code&gt;. The &lt;code&gt;values()&lt;/code&gt; method returns an array of its constants and &lt;code&gt;valueOf()&lt;/code&gt; method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;.&lt;br /&gt;
&lt;strong&gt;6.&lt;/strong&gt; By default, an enumâ€™s &lt;code&gt;toString()&lt;/code&gt; prints the enum name but you can override it to print anything you want.&lt;br /&gt;
The following are a few more important facts about &lt;code&gt;java.lang.Enum&lt;/code&gt; which you should know:&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; It implements &lt;code&gt;java.lang.Comparable&lt;/code&gt; (thus, an enum can be added to sorted collections such as &lt;code&gt;SortedSet&lt;/code&gt;, &lt;code&gt;TreeSet&lt;/code&gt;, and &lt;code&gt;TreeMap&lt;/code&gt;).&lt;br /&gt;
&lt;strong&gt;2.&lt;/strong&gt; It has a method &lt;code&gt;ordinal()&lt;/code&gt;, which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.&lt;br /&gt;
&lt;strong&gt;3.&lt;/strong&gt; It has a method &lt;code&gt;name()&lt;/code&gt;, which returns the name of this enum constant, exactly as declared in its enum declaration.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt; Which statements about the following code are correct?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface House{
  public default String getAddress() {
    return &quot;101 Main Str&quot;;
  }
}
interface Office {
  public static String getAddress() {
    return &quot;101 Smart Str&quot;;
  }
}
interface WFH extends House, Office {
  private boolean isOffice() {
    return true;
  }
}
class HomeOffice implements House, Office {
  public String getAddress() {
    return &quot;R No 1, Home&quot;;
  }
}
public class TestClass {
  public static void main(String[] args) {
    Office off = new HomeOffice(); //1
    System.out.println(off.getAddress()); //2
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Code for class HomeOffice will cause compilation to fail.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Code for interface WFH will cause compilation to fail.
    &lt;blockquote&gt;
      &lt;p&gt;Since Java 9, an interface is allowed to have private(but not protected) static as well as instance methods.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will compile fine and print R No 1, Home when run.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Line at //1 will cause compilation to fail.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Line at //2 will cause compilation to fail.
    &lt;blockquote&gt;
      &lt;p&gt;Since the declared type of variable off is Office, compiler will check the call to getAddress against Office interface. However, getAddress in Office is static and Java 8 requires static interface method to be invoked using the interface name instead of a reference variable. That is why, the compiler will raise the following error message:&lt;br /&gt;
TestClass.java:26 error: illegal static interface method call&lt;br /&gt;
   System.out.println(h.getAddress()); //2&lt;br /&gt;
the receiver expression should be replaced with the type qualifier â€˜Officeâ€™
1 error&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;9.&lt;/strong&gt; Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Booby {
}
class Dooby extends Booby {
}
class Tooby extends Dooby {
}

and the following declarations:  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;List&amp;lt;? super Booby&amp;gt; bV = null;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;List&amp;lt;? extends Tooby&amp;gt; tV = null;&lt;/code&gt;&lt;br /&gt;
Which of the following statements will compile without any error?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;11.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;14.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;15.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;17.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;20.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;21.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;25.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;27.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;29.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;30.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;31.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;32.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;33.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;34.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;35.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;36.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;39.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;41.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;42.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;43.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;45.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;46.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;48.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;49.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;50.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;51.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;53.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;57.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;58.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;60.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;61.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;63.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;64.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;65.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;66.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;67.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;70.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;71.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;73.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;78.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;80.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;81.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;82.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;83.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;How many methods have to be provided by a class that is not abstract and that implements Serializable interface?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;0
    &lt;blockquote&gt;
      &lt;p&gt;Serializable interface does not declare any methods. That is why is also called as a â€œmarkerâ€ interface.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Given that a code fragment has just created a JDBC Connection and has executed an update statement, which of the following statements is correct?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database are pending a commit call on the connection.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database will be rolled back if another update is executed without committing the previous update.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Changes to the database will be committed right after the update statement has completed execution.
    &lt;blockquote&gt;
      &lt;p&gt;A Connection is always in auto-commit mode when it is created. As per the problem statement, an update was fired without explicitly disabling the auto-commit mode, the changes will be committed right after the update statement has finished execution.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Changes to the database will be committed when another query (update or select) is fired using the connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
When a connection is created, it is in auto-commit mode. i.e. auto-commit is enabled. This means that each individual SQL statement is treated as a transaction and is automatically committed right after it is completed. (A statement is completed when all of its result sets and update counts have been retrieved. In almost all cases, however, a statement is completed, and therefore committed, right after it is executed.)&lt;/p&gt;

&lt;p&gt;The way to allow two or more statements to be grouped into a transaction is to disable the auto-commit mode. Since it is enabled by default, you have to explicitly disable it after creating a connection by calling &lt;code&gt;con.setAutoCommit(false);&lt;/code&gt;  &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Which interfaces does java.util.NavigableMap extend directly or indirectly?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.SortedSet&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java.util.SortedMap&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.TreeMap&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt; is a class that implements &lt;code&gt;NavigableMap&lt;/code&gt; interface. &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; is the other such class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.util.List&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
A &lt;code&gt;NavigableMap&lt;/code&gt; is a &lt;code&gt;SortedMap&lt;/code&gt; (which in turn extends Map) extended with navigation methods returning the closest matches for given search targets. Methods &lt;code&gt;lowerEntry&lt;/code&gt;, &lt;code&gt;floorEntry&lt;/code&gt;, &lt;code&gt;ceilingEntry&lt;/code&gt;, and &lt;code&gt;higherEntry&lt;/code&gt; return Map. Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a give key, returning null if there is no such key. Similarly, methods &lt;code&gt;lowerKey&lt;/code&gt;, &lt;code&gt;ceilingKey&lt;/code&gt;, and &lt;code&gt;higherKey&lt;/code&gt; return only the associated keys.&lt;/p&gt;

&lt;p&gt;All of these methods are designed for locating, not traversing entries.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;NavigableMap&lt;/code&gt; may be accessed and traversed in either ascending or descending key order. The &lt;code&gt;descendingMap&lt;/code&gt; method returns a view of the map with the senses of all relational and directional methods inverted. The performance of ascending operations and views is likely to be faster than that of descending ones. Methods &lt;code&gt;subMap&lt;/code&gt;, &lt;code&gt;headMap&lt;/code&gt;, and &lt;code&gt;tailMap&lt;/code&gt; differ from the like-named &lt;code&gt;SortedMap&lt;/code&gt; methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Submaps of any NavigableMap must implement the NavigableMap interface.&lt;/p&gt;

&lt;p&gt;This interface additionally defines methods &lt;code&gt;firstEntry&lt;/code&gt;, &lt;code&gt;pollFirstEntry&lt;/code&gt;, &lt;code&gt;lastEntry&lt;/code&gt;, and &lt;code&gt;pollLastEntry&lt;/code&gt; that return and/or remove the least and greatest mapping, if any exist, else returning null.&lt;/p&gt;

&lt;p&gt;Implementations of entry-returning methods are expected to return &lt;code&gt;Map.Entry&lt;/code&gt; pairs representing snapshots of mappings at the time they were produced, and thus generally do not support the optional &lt;code&gt;Entry.setValue&lt;/code&gt; method. Note however that it is possible to change mappings in the associated map using method put.&lt;/p&gt;

&lt;p&gt;Methods &lt;code&gt;subMap(K, K)&lt;/code&gt;, &lt;code&gt;headMap(K)&lt;/code&gt;, and &lt;code&gt;tailMap(K)&lt;/code&gt; are specified to return &lt;code&gt;SortedMap&lt;/code&gt; to allow existing implementations of &lt;code&gt;SortedMap&lt;/code&gt; to be compatibly retrofitted to implement &lt;code&gt;NavigableMap&lt;/code&gt;, but extensions and implementations of this interface are encouraged to override these methods to return &lt;code&gt;NavigableMap&lt;/code&gt;. Similarly, &lt;code&gt;SortedMap.keySet()&lt;/code&gt; can be overridden to return &lt;code&gt;NavigableSet&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;In which of the following cases can the Console object be acquired?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started from an interactive command line with explicitly redirecting the standard input and output streams to Console.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;When the JVM is started from an interactive command line without redirecting the standard input and output streams.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started in the background with the standard input and output streams directed to Console.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;When the JVM is started in the background without redirecting the standard input and output streams.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.&lt;/p&gt;

&lt;p&gt;If this virtual machine has a console then it is represented by a unique instance of this class which can be obtained by invoking the &lt;code&gt;System.console()&lt;/code&gt; method. If no console device is available then an invocation of that method will return null.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following are wrapper classes for primitive types?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Void&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;There is Void class but it does not wrap any primitive type.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Null&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;There is no Null class in java.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the above&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Frequently it is necessary to represent a value of primitive type as if it were an object. There are following wrapper classes for this purpose:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Char&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, and &lt;code&gt;Double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that Byte, Short, Integer, Long, Float and Double extend from Number which is an abstract class. An object of type Double, for example, contains a field whose type is double, representing that value in such a way that a reference to it can be stored in a variable of reference type. These classes also provide a number of methods for converting among primitive values, as well as supporting such standard methods as &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hasCode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It is important to understand that objects of wrapper classes are immutable.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following standard functional interface returns void?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Supplier&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It takes no argument and returns an object.&lt;br /&gt;
&lt;code&gt;T get()&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Function&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Represents a function that accepts one argument and produces a result.&lt;br /&gt;
&lt;code&gt;R apply(T t)&lt;/code&gt;&lt;br /&gt;
Applies this function to the given argument.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Predicate&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It takes and argument and returns a boolean:&lt;br /&gt;
&lt;code&gt;boolean test(T t)&lt;/code&gt;&lt;br /&gt;
Evaluates this predicate on the given argument.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;Consumer&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Its functional method is:&lt;br /&gt;
&lt;code&gt;void accept(T t)&lt;/code&gt;&lt;br /&gt;
Performs this operation on the given argument.&lt;br /&gt;
It also has the following default method:&lt;br /&gt;
&lt;code&gt;default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after)&lt;/code&gt;&lt;br /&gt;
Returns a composed &lt;code&gt;Consumer&lt;/code&gt; that performs, in sequence, this operation followed by the after operation.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;UnaryOperator&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of &lt;code&gt;Function&lt;/code&gt; for the case where the operand and result are of the same type.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You should go through the description of all the functional interfaces given &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of the following switches is/are used for controlling the execution of assertions at run time?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-ua&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;-da&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is a short form for â€˜disable assertionsâ€™.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;-enableassertions&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-assert&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;-keepassertions&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Although not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:&lt;br /&gt;
Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by â€œâ€¦â€œ(three dots also known as ellipses):&lt;br /&gt;
&lt;code&gt;java -ea:&amp;lt;class&amp;gt; myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;java -da:&amp;lt;package&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
You can have multiple &lt;code&gt;-ea/-da&lt;/code&gt; flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.&lt;br /&gt;
&lt;code&gt;java -ea -da:com.xyz... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
The above command enables assertions for all classes  in all packages, but then the subsequent &lt;code&gt;-da&lt;/code&gt; switch disables them for the &lt;code&gt;com.xyz&lt;/code&gt; package and its subpackages.&lt;br /&gt;
To enable assertion for one package and disable for other you can use:&lt;br /&gt;
&lt;code&gt;java -ea:&amp;lt;package1&amp;gt;... -da:&amp;lt;package2&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
You can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:&lt;br /&gt;
&lt;code&gt;java -ea:... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;java -da:... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
Note that when you use a package name in the &lt;code&gt;ea&lt;/code&gt; or &lt;code&gt;da&lt;/code&gt; flag, the flag applies to that package as well as its subpackages. For example,&lt;br /&gt;
&lt;code&gt;java -ea:com... -da:com.enthuware... com.enthuware.Main&lt;/code&gt;&lt;br /&gt;
The above command first enables assertions for all the classes in &lt;code&gt;com&lt;/code&gt; as well as for the classes in the subpackages of &lt;code&gt;com&lt;/code&gt;. It then disables assertions for classes in package &lt;code&gt;com.enthuware&lt;/code&gt; and its subpackages.&lt;br /&gt;
Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use &lt;code&gt;-enablesystemassertions/-esa&lt;/code&gt; or &lt;code&gt;-disablesystemassertions/-dsa&lt;/code&gt;&lt;br /&gt;
Note that * and ** are not valid wildcards for including subpackages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Which of these statements concerning the use of standard collection interfaces are true?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the standard collection classes are thread safe.
    &lt;blockquote&gt;
      &lt;p&gt;Vector and Hashtable are.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;class HashSet implements SortedSet.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Collection classes implementing List cannot have duplicate elements.
    &lt;blockquote&gt;
      &lt;p&gt;List is meant for ordering of elements. Duplicates are allowed.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;ArrayList can only accommodate a fixed number of elements.
    &lt;blockquote&gt;
      &lt;p&gt;It grows as more elements are added.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Some operations may throw an UnsupportedOperationException.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Some operations may throw an UnsupportedOperationException. This exception type is unchecked, and code calling these operations is not required to explicitly handle exceptions of this type.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following are standard annotations used to suppress various warnings generated by the compiler?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarning(&quot;rawtypes&quot;)&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarning( {&quot;deprecation&quot;, &quot;unchecked&quot;} )&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarning(&quot;deprecation&quot;, &quot;unchecked&quot;)&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Syntax is incorrect because this annotation takes only one value type String array. So, if you want to pass multiple string values, you must pass an array containing those values.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;This can be used on a constructor or a method. If a constructor or a method tries to perform unsafe operations involving a var args parameter and a parameterized collection, a warning is generated. This annotation suppresses that warning. Example:&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SafeVarargs // Not actually safe but still suppresses the warning
static void m(List&amp;lt;String&amp;gt;... stringList) {
    Object[] array = stringLists;
    List&amp;lt;Integer&amp;gt; temList = Arrays.asList(42);
    array[0] = temList; // Semantically invalid, but compiles without warnings because of the annotation
    String s = stringLists[0].get(0);  // Oh no, ClassCastException at runtime!
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Override&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;This annotation is used only on methods. It causes a warning to be generated if a method does not actually override any method from the base class. It does not suppress any warning.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Deprecated&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;This annotation causes a warning to be generated. It does not suppress any warning.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
As per JLS 11 section 9.6.4.5, &lt;code&gt;@SuppressWarning&lt;/code&gt; must support three values: &lt;code&gt;unchecked&lt;/code&gt;, &lt;code&gt;deprecation&lt;/code&gt;, and &lt;code&gt;removal&lt;/code&gt;. However, it is not an error if you use a value that is not supported by the compiler. A compiler simply ignores it.&lt;/p&gt;

&lt;p&gt;Different compilers may support more values. For example, Oracleâ€™s javac compiler supports a large number of values (https://docs.oracle.com/en/java/javase/11/tools/javac.html). The ones that you should be aware of for the exam are: &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;rawtypes&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt;, and &lt;code&gt;varargs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This annotation is not repeatable. Therefore, you cannot use it twice on the same type. However, you can specify multiple values like this: &lt;code&gt;@SuppressWarning({ &quot;deprecation&quot;, &quot;unchecked&quot;} )&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;You are implementing a special sorting algorithm that can sort objects of different classes. Which of the following class declarations will you use?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class SpecialSorter&amp;lt;&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
public class SpecialSorter&amp;lt;K&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This is the correct way to define a generic class. Within the class, you can use K as a type, for example:&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class SpecialSorter&amp;lt;K&amp;gt; {
    public void sort(ArrayList&amp;lt;K&amp;gt; items) {
        K item = items.get(0);
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class &amp;lt;SpecialSorter&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
public class SpecialSorter(K) {
    ...
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Code that uses generic collection classes can interoperate with code that uses raw collections classes because of?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;type erasure
    &lt;blockquote&gt;
      &lt;p&gt;Type erasure means that a compiled java class does not contain any of the generic information that is present in the java file. In other words, the compiler removes the generic information from a java class when it compile it into byte code. For example, &lt;code&gt;List&amp;lt;String&amp;gt; list;&lt;/code&gt; and &lt;code&gt;List list;&lt;/code&gt; are compiled to the same byte code. Therefore, at run time, it does not matter whether youâ€™ve used generic classes or not and this kinds of classes to interoperate because they are essentially the same class to the JVM.&lt;br /&gt;
Type erasure ensure that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;reification
    &lt;blockquote&gt;
      &lt;p&gt;This is just the opposite of type erasure. Here, all the type information is preserved in the byte code. In Java, arrays are reified. For example,&lt;/p&gt;

      &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ArrayList[] alArray = new ArrayList[1];
Collection[] cArray = alArray;
cArray[0] = new HashSet();
&lt;/code&gt;&lt;/pre&gt;

      &lt;p&gt;The above code will compile fine. But it will throw an &lt;code&gt;java.lang.ArrayStoreException&lt;/code&gt; at run time because the byte code contains the information that &lt;code&gt;cArray&lt;/code&gt; actually points to an array of &lt;code&gt;ArrayList&lt;/code&gt;s and not of &lt;code&gt;HasSet&lt;/code&gt;s.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;just in time compilation&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;byte code instrumentation&lt;br /&gt;
å­—èŠ‚ç æ“ä½œå¥½åƒæœ‰ç‚¹æ„æ€ã€‚&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following is/are valid functional interface?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() {}
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it does not have an abstract method.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() {}
    static void n() {}
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it does not have an abstract method.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    void m();
    void n();
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;It is not a valid functional interface because it has more than one abstract methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;java
interface F {
    default void m() { }
    abstract void n();
}
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;The use of abstract keyword is redundant here, but it legal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;java
interface F {
    void m() {}
}
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This will not compile because the method has a body but it lacks the keyword default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods in addition to the abstract method. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Predicate&amp;lt;T&amp;gt; {
    boolean test(T t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.&lt;/p&gt;

&lt;p&gt;You could have a method that takes an instance of class that  implements this interface defined like this -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void printImportantData(ArrayList&amp;lt;Data&amp;gt; dataList, Predicate&amp;lt;Data&amp;gt; p) {
    for (Data d: dataList) {
        if (p.test(d)) System.out.println(d);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where Data class could be as simple as &lt;code&gt;public class Data { public int value; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now, you can call the above method as follows:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printImportantData(al, (Data d) -&amp;gt; { return d.value &amp;gt; 1; } );&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notice the lack of method name here. This is possible because the interface has only one abstract method so the compiler can figure out the name. This can be shortened to:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printImportantData(al, d -&amp;gt; d.value &amp;gt; 1);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notice that there is no declaration of d! The compiler can figure out all information it needs because the interface has only one abstract method and that method has only one parameter. So you donâ€™t need to write all those things in your code.&lt;/p&gt;

&lt;p&gt;Compare the above approach to the old style using an inner class that does the same thing -&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;printImportantData(al, new Predicate&amp;lt;Data&amp;gt;() {
    public boolean test(Data d) {
        return d.value &amp;gt; 1;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Predicate&lt;/code&gt; interface described above can be used anywhere there is a need to â€œdo something with an object and return a booleanâ€ and is actually provided by the standard java library in &lt;code&gt;java.util.function&lt;/code&gt; package. This package provides a few other useful functional interfaces.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Predicate&amp;lt;T&amp;gt;&lt;/code&gt; Represents a predicate (boolean-valued function) of one argument of type T.&lt;br /&gt;
&lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt; Represents an operation that accepts a single input argument of type T and returns no result.&lt;br /&gt;
&lt;code&gt;Function&amp;lt;T, R&amp;gt;&lt;/code&gt; Represents a function that accepts one argument of type T and produces a result of type R&lt;br /&gt;
&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt; Represents a supplier of results of type T.&lt;/p&gt;

&lt;p&gt;Please see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&lt;/a&gt; for learning Lambda expressions in Java.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;çœ‹æ®µä»£ç ï¼Œåˆ¤æ–­è¾“å‡ºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.HashSet;

enum SIZE {
    TALL, GRANDE, JUMBO;
}

public class CoffeeMug {
    public static void main(String[] args) {
        HashSet&amp;lt;SIZE&amp;gt; hs = new HashSet&amp;lt;&amp;gt;();
        hs.add(SIZE.TALL); hs.add(SIZE.JUMBO); hs.add(SIZE.GRANDE);
        hs.add(SIZE.TALL); hs.add(SIZE.TALL); hs.add(SIZE.JUMBO);
        for(SIZE s: hs) System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two concepts involved in this question:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A &lt;code&gt;Set&lt;/code&gt; (such as a &lt;code&gt;HashSet&lt;/code&gt;) does not allow duplicate elements. If you add a duplicate element, it is ignored. Thus, only three unique &lt;code&gt;SIZE&lt;/code&gt; elements are stored.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is important to understand how the &lt;code&gt;add()&lt;/code&gt; method of a Set works :&lt;br /&gt;
&lt;code&gt;boolean add(E o)&lt;/code&gt;
    Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element, o, to this set if this set contains no element e such that &lt;code&gt;(o==null ? e==null : o.equals(e))&lt;/code&gt;. If this set already contains the specified element, the call leaves this set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The order of elements is not defined in &lt;code&gt;HashSet&lt;/code&gt;. So while retrieving elements, it can return them in any order.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember that, &lt;code&gt;TreeSet&lt;/code&gt; does store elements in their &lt;strong&gt;natural sorted order&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Also remember that the order of Enums is the order in which they are defined. It is not necessarily same as alphabetical order of their names.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Which of the following annotations are retained for run time?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is defined with &lt;code&gt;@Retention(SOURCE)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Override&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is defined with &lt;code&gt;@Retention(SOURCE)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is defined with &lt;code&gt;@Retention(RUNTIME)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is defined with &lt;code&gt;@Retention(RUNTIME)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@Deprecated&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is defined with &lt;code&gt;@Retention(RUNTIME)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Your application needs to load a set of key value pairs from a database table which never changes. Multiple threads need to access this information but none of them changes it.  Which class would be the most appropriate to store such data if the values need not be keep in a sorted fashion?&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;List&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You should know that all &lt;code&gt;Hashtable&lt;/code&gt; methods are synchronized and this compromises its performance for simultaneous reads.&lt;br /&gt;
Since no thread modifies the data, it is not efficient to use a &lt;code&gt;Hashtable&lt;/code&gt;.&lt;br /&gt;
A &lt;code&gt;HashMap&lt;/code&gt; is perfect choice because its methods are not synchronized and so it allows efficient multiple reads. &lt;code&gt;TreeMap&lt;/code&gt; is used to keep the keys sorted which makes it a little bit slower than &lt;code&gt;HashMap&lt;/code&gt;.&lt;br /&gt;
&lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt; canâ€™t be used since we need to store Key-value pairs.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;A programmer has written the following code to ensure that the phone number is not null and is of 10 characters:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void processPhoneNumber(String number) {
    assert number != null &amp;amp;&amp;amp; number.length() == 10 : &quot;Invalid phone number&quot;;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the given statements regarding the above code are correct?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This is an appropriate use of assertions.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This code will not work  in all situations.
    &lt;blockquote&gt;
      &lt;p&gt;It will not work if assertions are disabled.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The given code is syntactically correct.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Constrains on input parameters should be enforced using assertions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
As a rule, assertions should not be used to assert the validity of input parameters of a public method. Since assertions may be disabled at the wish of the user of the program, input validation will not occur when assertions are disabled. A public method should ensure in all situations(whether assertions are enabled or disabled) that the input parameters are valid before proceeding with the rest of the code. For this reason, input validation should always be done using the standard exception mechanism:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if(number == null || number.length() != 10) throw new RuntimeException(&quot;Invalid phone number&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;However, assertions may be used to validate the input parameters of a private method. This is because private methods are called only by the developer of the class. Therefore, if a private method is called with an invalid parameter, this problem should be rectified at the development stage itself. It cannot occur in the production stage, so there is not need to throw an explicit exception.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;nio-2-files-class&quot;&gt;NIO 2 Files class&lt;/h3&gt;

&lt;p&gt;æ–‡ä»¶æ“ä½œï¼Œ &lt;code&gt;Files.copy&lt;/code&gt;æ–¹æ³•&lt;/p&gt;

&lt;p&gt;However, &lt;code&gt;Files.isSameFile&lt;/code&gt; method doesnâ€™t check the contents of the file. It is meant to check if the two path objects resolve to the same file or not. In this case, they are not, and so, it will return false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static Path copy(Path source, Path target, CopyOption... options) throws IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é€‰é¡¹å‚æ•°ï¼ˆoptions parameter)å¯ä»¥åŒ…æ‹¬ä»¥ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;â€‹      If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COPY_ATTRIBUTES&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;â€‹      Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file store. Copying of file timestamps may result in precision loss.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOFOLLOW_LINKS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;â€‹      Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link.  In other words, the COPY_ATTRIBUTES option may be ignored when copying a symbolic link.&lt;br /&gt;
An implementation of this interface may support additional implementation specific options.
Coping a file is not an atomic operation. If an &lt;code&gt;IOException&lt;/code&gt; is thrown then itâ€™s possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the creation of the new file may not be atomic with respect to other file system activities.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static Path move(Path source, Path target, CopyOption... options) throws IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Move or rename a file to a target file.
By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not required moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an &lt;code&gt;IOException&lt;/code&gt;). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the &lt;code&gt;Files.walkFileTree&lt;/code&gt; utility method.&lt;/p&gt;

&lt;p&gt;The options parameter may include any of the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REPLACE_EXISTING&lt;/strong&gt; If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ATOMIC_MOVE&lt;/strong&gt; The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;code&gt;IOException&lt;/code&gt;. If the move cannot be performed as an atomic file system operation then &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options.&lt;/p&gt;

&lt;p&gt;Where the move requires that the file be copied then the last-modified-time is copied to the new file. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and an &lt;code&gt;IOException&lt;/code&gt; is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file.&lt;/p&gt;

&lt;hr /&gt;
</description>
        <pubDate>Wed, 26 Feb 2020 15:15:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/26/ocp-mock-test1-review/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/26/ocp-mock-test1-review/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>è®¤è¯è€ƒè¯•</category>
        
        
      </item>
    
      <item>
        <title>816è€ƒç‚¹é€Ÿè®°</title>
        <description>&lt;h4 id=&quot;1-unmodifiable-collections-using-ofcopyof-and-collectionsunmodifiablexxx-methods&quot;&gt;1. Unmodifiable collections using of/copyOf and Collections.unmodifiableXXX methods&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;java.util.List&lt;/code&gt; and &lt;code&gt;java.util.Set&lt;/code&gt; have &lt;code&gt;of&lt;/code&gt; and &lt;code&gt;copyOf&lt;/code&gt; static factory methods that provide a convenient way to create unmodifiable lists/sets.&lt;/p&gt;

&lt;p&gt;The of methods accept either an array or multiple individual parameters. If you pass it a collection, it will be treated as a regular object i.e. it will return a list/set containing the same collection object instead of returning a list/set containing the objects that the passed collection contains.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;copyOf&lt;/code&gt;, on the other hand, accepts only a &lt;code&gt;Collection&lt;/code&gt;. It iterates through the passed &lt;code&gt;Collection&lt;/code&gt; and adds all the elements of that &lt;code&gt;Collection&lt;/code&gt; in the returned list/set. &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Here are a few important points about these methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;They return unmodifiable copies of the original List/Set. Thus, any operation that tries to modify the returned list throws an &lt;code&gt;java.lang.UnsupportedOperationException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The list/set returned by the &lt;code&gt;of/copyOf&lt;/code&gt; methods is completely independent of the original collection. Thus, if you modify the original collection after passing it to &lt;code&gt;of/copyOf&lt;/code&gt; methods, those changes will not be reflected in the list returned by the &lt;code&gt;of/copyOf&lt;/code&gt; methods.&lt;/li&gt;
  &lt;li&gt;They do not support &lt;code&gt;null&lt;/code&gt; elements. Thus, if your array contains a &lt;code&gt;null&lt;/code&gt; and if you try to create a &lt;code&gt;List&lt;/code&gt; using &lt;code&gt;List.of&lt;/code&gt;, it will throw a &lt;code&gt;NullPointerException&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;Collections.unmodifiableXXX&lt;/code&gt; methods&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java.utils.Collections&lt;/code&gt; class also has several variations of &lt;code&gt;unmodifiableXXX&lt;/code&gt; static methods (such as &lt;code&gt;unmodifiableList(List )&lt;/code&gt;, &lt;code&gt;unmodifiableSet(Set )&lt;/code&gt;, and &lt;code&gt;unmodifiableMap(Map )&lt;/code&gt; ). These method return an unmodifiable view of the underlying collection. The fundamental difference between &lt;code&gt;Collections.unmodifiableXXX&lt;/code&gt; and &lt;code&gt;List.of/copyOf&lt;/code&gt; methods is that &lt;code&gt;Collections.unmodifiableList&lt;/code&gt; returns a view (instead of a copy) into the underlying list. Which means, if you make any changes to the underlying list after creating the view, those changes will be visible in the view. Further, &lt;code&gt;Collections.unmodifiableList&lt;/code&gt; has no problem with nulls.&lt;/p&gt;

&lt;p&gt;The word unmodifiable in &lt;code&gt;unmodifiableXXX&lt;/code&gt; method name refers to the fact that you cannot modify the view using a reference to view.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;2-top-down-approach-for-modularizing-an-application&quot;&gt;2. Top Down Approach for modularizing an application&lt;/h4&gt;

&lt;p&gt;While modularizing an app in a top-down approach, you need to remember the following points -&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Any jar file can be converted into an automatic module by simply putting that jar on the module-path instead of the classpath. Java automatically derives the name of this module from the name of the jar file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any jar that is put on classpath (instead of module-path) is loaded as a part of the â€œunnamedâ€ module.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An explicitly named module (which means, a module that has an explicitly defined name in its module-info.java file) can specify dependency on an automatic module just like it does for any other module i.e. by adding a requires &lt;code&gt;&amp;lt;module-name&amp;gt;;&lt;/code&gt; clause in its module info but it cannot do so for the unnamed module because there is no way to write a requires clause without a name. In other words, a named module can access classes present in an automatic module but not in the unnamed module.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Automatic modules are given access to classes in the unnamed module (even though there is no explicitly defined module-info and requires clause in an automatic module). In other words, a class from an automatic module will be able to read a class in the unnamed module without doing anything special.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An automatic module exports all its packages and is allowed to read all packages exported by other modules. Thus, an automatic module can access: all packages of all other automatic modules + all packages exported by all explicitly named modules + all packages of the unnamed module (i.e. classes loaded from the classpath).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, if your application jar &lt;strong&gt;A&lt;/strong&gt; directly uses a class from another jar &lt;strong&gt;B&lt;/strong&gt;, then you would have to convert &lt;strong&gt;B&lt;/strong&gt; into a module (either named or automatic). If &lt;strong&gt;B&lt;/strong&gt; uses another jar &lt;strong&gt;C&lt;/strong&gt;, then you can leave &lt;strong&gt;C&lt;/strong&gt; on the class path if &lt;strong&gt;B&lt;/strong&gt; hasnâ€™t yet been migrated into a named module. Otherwise, you would have to convert &lt;strong&gt;C&lt;/strong&gt; into an automatic module as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br /&gt;
There are two possible ways for an automatic module to get its name:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;When an Automatic-Module-Name entry is available in the manifest, its value is the name of the automatic module.&lt;/li&gt;
  &lt;li&gt;Otherwise, a name is derived from the JAR filename (see the ModuleFinder JavaDoc for the derivation algorithm) - Basically, hyphens are converted into dots and the version number part is ignored. So, for example, if you put mysql-connector-java-8.0.11.jar on module path, its module name would be mysql.connector.java&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;3-bottom-up-approach-for-modularizing-an-application&quot;&gt;3. Bottom Up Approach for modularizing an application&lt;/h4&gt;

&lt;p&gt;While modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in &lt;strong&gt;A.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;B.jar&lt;/strong&gt;, and a class in &lt;strong&gt;B.jar&lt;/strong&gt; directly uses a class from &lt;strong&gt;C.jar&lt;/strong&gt;, you need to first modularize &lt;strong&gt;C.jar&lt;/strong&gt; and then &lt;strong&gt;B.jar&lt;/strong&gt; before you can modularize &lt;strong&gt;A.jar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Thus, bottom up approach is possible only when the dependent libraries are modularized already.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;4-java-module-execution-options&quot;&gt;4. Java Module Execution Options&lt;/h4&gt;

&lt;p&gt;You need to know about three command line options for running a class that is contained in a module:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;â€“module-path&lt;/strong&gt; or -p: This option specifies the location(s) of the module(s) that are required for execution. This option is very versatile. You can specify exploded module directories, directories containing modular jars, or even specific modular or non-modular jars here. The path can be absolute or relative to the current directory. For example, â€“module-path c:/javatest/output/mathutils.jar or â€“module-path mathutils.jar&lt;br /&gt;
You can also specify the location where the moduleâ€™s files are located. For example, if your module is named abc.math.utils and this module is stored in c:\javatest\output, then you can use: â€“module-path c:/javatest/output. Remember that c:\javatest\output directory must contain abc.math.utils directory and the module files (including module-info.class) must be present in their appropriate directory structure under abc.math.utils directory.&lt;br /&gt;
You can specify as many jar files or module locations separated by path separator (; on windows and : on *nix) as required.&lt;br /&gt;
NOTE: -p is the short form for â€“module-path.(Observe the single and double dashes).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;â€“module&lt;/strong&gt; or &lt;strong&gt;-m&lt;/strong&gt;: This option specifies the module that you want to run. For example, if you want to run abc.utils.Main class of abc.math.utils module, you should write â€“module abc.math.utils/abc.utils.Main&lt;br /&gt;
If a module jar specifies the Main-Class property its MANIFEST.MF file, you can omit the main class name from â€“module option.&lt;br /&gt;
For example, you can write, â€“module abc.math.utils instead of â€“module abc.math.utils/abc.utils.Main.&lt;br /&gt;
NOTE: -m is the short form for â€“module.(Observe the single and double dashes).&lt;br /&gt;
Thus,&lt;br /&gt;
&lt;code&gt;java --module-path mathutils.jar --module abc.math.utils/abc.utils.Main&lt;/code&gt; is same as&lt;br /&gt;
&lt;code&gt;java -p mathutils.jar -m abc.math.utils/abc.utils.Main&lt;/code&gt;&lt;br /&gt;
NOTE: It is possible to treat modular code as non-modular by ignoring module options altogether. For example, if you want to run the same class using the older classpath option, you can do it like this:&lt;br /&gt;
java -classpath mathutils.jar abc.utils.Main&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;-classpath&lt;/strong&gt;: Remember that modular code cannot access code present on the -classpath but â€œautomatic modulesâ€ are an exception to this rule. When a non-modular jar is put on â€“module-path, it becomes an â€œautomatic moduleâ€ but it can still access all the modular as well as non-modular code. In other words, a class from an automatic module can access classes present on â€“module-path as well as on -classpath without having any â€œrequiresâ€ clause (remember that there is no module-info in automatic modules).
Thus, if your modular jar A depends on a non-modular jar B, you have to put that non-modular jar B on â€“module-path. You must also add appropriate requires clause in your module Aâ€™s module-info otherwise compilation of your module will not succeed. Further, if the non-modular jar B depends on another non-modular jar C, then the non-modular jar C may be put on the classpath or module-path.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;5-java-module-compilation-options&quot;&gt;5. Java Module Compilation Options&lt;/h4&gt;

&lt;p&gt;For compiling a Java class that is part of a module, you need to remember the following five command line options:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;â€“module-source-path: This option is used to specify the location of the module source files. It should point to the parent directory of the directory where module-info.java of the module is stored. For example, if your module name is moduleA, then the module-info.java for this module would be in moduleA directory and if moduleA directory exists in src directory, then â€“module-source-path should contain the src directory i.e. â€“module-source-path src&lt;br /&gt;
If moduleA depends on another module named moduleB, and if moduleB directory exists in src2 directory, you can add this directory in â€“module-source-path as well i.e. â€“module-source-path src;src2. javac will compile the required files of src2 as well if the source code of moduleB is organized under src2 correctly.&lt;/li&gt;
  &lt;li&gt;-d: This option is required when you use the â€“module-source-path option. It is used to specify the output directory. This is the directory where javac will generate the moduleâ€™s package driven directory structure and the class files for the sources. For example, if you specify out as the output directory, javac will create a directory under out with the same name as the name of the module and will create class files with appropriate package driven directory structure under that directory.&lt;/li&gt;
  &lt;li&gt;â€“module or -m: This option is used when you want to compile all the source files of a particular module. This option is helpful when you want to compile all the files at once without listing any of the source files of a module individually in the command.&lt;br /&gt;
For example, if you have two java files in moduleA, stored under moduleA\a\A1.java and moduleA\a\A2.java, you can compile both of them at the same time using the command: java â€“module-source-path src -d out â€“module moduleA&lt;br /&gt;
Javac will find out all the java source files under moduleA and compile all of them. It will create the class files under the output directory specified in -d option i.e. out. Thus, the out directory will now have two class files - moduleA/a/A1.class and moduleA/a/A2.class.&lt;/li&gt;
  &lt;li&gt;â€“module-path or -p: This option specifies the location(s) of any other module upon which the module to be compiled depends and is very versatile. You can specify the exploded module directories, directories containing modular jars, or specific modular jars here. For example, if you want to compile moduleA and it depends on another module named abc.util packaged as utils.jar located in thirdpartymodules directory then your module-path can be thirdpartymodules or thirdpartymodules/utils.jar. That both the following two commands will work:&lt;br /&gt;
&lt;code&gt;javac --module-source-path src --module-path thirdpartymodules -d out --module moduleA&lt;/code&gt; and&lt;br /&gt;
&lt;code&gt;javac --module-source-path src --module-path thirdpartymodules\utils.jar -d out --module moduleA&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;Note:&lt;/strong&gt;If your module depends on a non-modular third party jar, you need to do two things -Put that third party jar in â€“module-path.&lt;br /&gt;
Putting a non-modular jar in â€“module-path causes that jar to be loaded as an â€œautomatic moduleâ€. The name of this module is assumed to be same as the name of the jar minus any version numbers. For example, if you put mysql-driver-6.0.jar in â€“module-path, it will be loaded as an automatic module with name mysql.driver. Name derivation is explained in detail in java.lang.module.ModuleFinder JavaDoc but for the exam, just remember that hyphens are converted into dots and the version number and extension part is removed.&lt;br /&gt;
It is also possible for a non-modular jar to specify its module name using Automatic-Module-Name: &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; entry to the jarâ€™s MANIFEST.MF.Add a requires &lt;code&gt;&amp;lt;module-name&amp;gt;;&lt;/code&gt; clause in module-info of your module.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-classpath&lt;/strong&gt;: This option is used for compilation of non-modular code. If you are compiling regular non-modular code but that code depends on some classes, then you can put those classes or jars on the classpath using -classpath option.&lt;br /&gt;
&lt;strong&gt;Note:&lt;/strong&gt; This option is not helpful for compilation of modular code because classes of a modular cannot see classes on classpath. Modular code can only see other modular code. That is why, non-modular classes have to be converted into â€œautomatic modulesâ€ and put on â€“module-path as explained above.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;6-enum-points&quot;&gt;6. enum points&lt;/h4&gt;

&lt;p&gt;You need to know the following facts about enums:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.&lt;/li&gt;
  &lt;li&gt;An enum is implicitly final, which means you cannot extend it.&lt;/li&gt;
  &lt;li&gt;You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces.&lt;/li&gt;
  &lt;li&gt;Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final.&lt;/li&gt;
  &lt;li&gt;Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException.&lt;/li&gt;
  &lt;li&gt;By default, an enumâ€™s toString() prints the enum name but you can override it to print anything you want.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following are a few more important facts about java.lang.Enum which you should know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap).&lt;/li&gt;
  &lt;li&gt;It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.&lt;/li&gt;
  &lt;li&gt;It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;7-autocloseable-points&quot;&gt;7. AutoCloseable points&lt;/h4&gt;

&lt;p&gt;You need to know the following points regarding try-with-resources statement for the exam:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable.&lt;/li&gt;
  &lt;li&gt;AutoCloseable has only one method - public void close() throws Exception.&lt;/li&gt;
  &lt;li&gt;Resources are closed at the end of the try block and before any catch or finally block.&lt;/li&gt;
  &lt;li&gt;Resources are not even accessible in the catch or finally block. For example:
    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(Device d = new Device())
{
   d.read();
}finally{
   d.close(); //This will not compile because d is not accessible here.
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Device d = new Device();
try(d){ //valid since Java 9
  ...
}finally{
   d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;Resources are closed in the reverse order of their creation.&lt;/li&gt;
  &lt;li&gt;Resources are closed even if the code in the try block throws an exception.&lt;/li&gt;
  &lt;li&gt;java.lang.AutoCloseableâ€™s close() throws Exception but java.io.Closeableâ€™s close() throws IOException.&lt;/li&gt;
  &lt;li&gt;If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;8-jdbc-url&quot;&gt;8. JDBC URL&lt;/h4&gt;

&lt;p&gt;The format of a JDBC URL is : &lt;code&gt;jdbc:&amp;lt;subprotocol&amp;gt;:&amp;lt;subname&amp;gt;&lt;/code&gt;&lt;br /&gt;
where subprotocol defines the kind of database connectivity mechanism that may be supported by one or more drivers. The contents and syntax of the subname will depend on the subprotocol.&lt;br /&gt;
Here are a few examples of commonly used urls for connecting to derby db (the Java database that comes bundled with various IDEs such as NetBeans) and MySQL:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jdbc:derby:sample&lt;br /&gt;
jdbc:derby://localhost:1527/sample&lt;br /&gt;
jdbc:mysql://localhost:1527/sample&lt;br /&gt;
jdbc:mysql://192.168.0.100:3306/testdb&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Observe that a JDBC url always starts with jdbc: and has at least three components separated by a two colons.&lt;br /&gt;
It also usually includes the hostname or address and the port number on which the database is listening for the requests but that is not necessary.&lt;br /&gt;
Most drivers allow adding more options to the URL in the subname part, for example the following JDBC url for Oracle DB specifies the type of the jdbc driver :&lt;br /&gt;
&lt;code&gt;jdbc:oracle:thin:@localhost:1521:testdb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Userid and password are usually supplied separately from the URL but some drivers allow them to be specified in the URL itself. For example:&lt;br /&gt;
&lt;code&gt;jdbc:oracle:thin:scott/mypassword@//myhost:1521/orcl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;9-command-line-switches-for-assertions&quot;&gt;9. Command Line Switches for Assertions&lt;/h4&gt;

&lt;p&gt;Although not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:&lt;br /&gt;
Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by â€œâ€¦â€ (three dots also known as ellipses):&lt;br /&gt;
&lt;code&gt;java -ea:&amp;lt;class&amp;gt; myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;java -da:&amp;lt;package&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.&lt;br /&gt;
&lt;code&gt;java -ea -da:com.xyz... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.&lt;br /&gt;
To enable assertion for one package and disable for other you can use:&lt;br /&gt;
&lt;code&gt;java -ea:&amp;lt;package1&amp;gt;... -da:&amp;lt;package2&amp;gt;... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:&lt;br /&gt;
&lt;code&gt;java -ea:... myPackage.myProgram&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;java -da:... myPackage.myProgram&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,&lt;br /&gt;
&lt;code&gt;java -ea:com... -da:com.enthuware... com.enthuware.Main&lt;/code&gt;&lt;br /&gt;
The above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.&lt;/p&gt;

&lt;p&gt;Another thing is that &lt;code&gt;-ea/-da&lt;/code&gt; do not apply to system classes. For system classes (i.e. the classes that come bundled with the JDK/JRE), you need to use &lt;code&gt;-enablesystemassertions/-esa&lt;/code&gt; or &lt;code&gt;-disablesystemassertions/-dsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that ** and * are not valid wildcards for including subpackages.&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Feb 2020 01:15:00 +0000</pubDate>
        <link>https://zwt.io/2020/02/26/ocp-816-learning-points/</link>
        <guid isPermaLink="true">https://zwt.io/2020/02/26/ocp-816-learning-points/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>è®¤è¯è€ƒè¯•</category>
        
        
      </item>
    
  </channel>
</rss>
