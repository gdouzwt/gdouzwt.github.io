<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://blog.zwt.io/</link>
    <atom:link href="https://blog.zwt.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 30 Mar 2021 16:32:37 +0000</pubDate>
    <lastBuildDate>Tue, 30 Mar 2021 16:32:37 +0000</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>基于Grafana的物联网可视化仪表盘</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文介绍如何在Ubuntu Server 20.04.2 LTS 服务器设置一个物联网可视化仪表盘。用到的技术包括 Docker, InfluxDB, MQTT, Grafana, Telegraf, NodeRed
硬件方面采用 ESP8266、Arduino 或者其它任何兼容它的。本系统用于监控物联网设备的情况。其中 InfluxBD 用于存储来自传感器的数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/image-20210305030358768.png&quot; alt=&quot;image-20210305030358768&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;服务器&quot;&gt;服务器&lt;/h4&gt;

&lt;p&gt;我的服务器用的是旧的台式电脑安装 Ubuntu Server 20.04.2 LTS 操作系统，然后安装 Docker Engine。根据 Docker &lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;官网文档提供的方法 &lt;/a&gt; &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;先安装一些必要的包（如还没有）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo \
  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo apt-get update
 sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等 Docker 安装完成后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo usermod -aG docker $USER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是安装其它软件。&lt;/p&gt;

&lt;h5 id=&quot;安装并配置-mosquitto&quot;&gt;安装并配置 Mosquitto&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull eclipse-mosquitto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一款开源的 MQTT broker，然后运行它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -it -p 1883:1883 -p 9001:9001 eclipse-mosquitto
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;安装并配置-influxdb&quot;&gt;安装并配置 InfluxDB&lt;/h5&gt;

&lt;p&gt;InfluxBD 是一款时间序列数据库，可以用于存储与时间相关的数据，适合存传感器收集到的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 InfluxDB&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -d -p 8086:8086 -v influxdb:/var/lib/influxdb --name influxdb influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是将influxdb作为守护进程启动，并创建了卷用于存储数据在 &lt;code&gt;/var/lib/influxdb&lt;/code&gt;&lt;/p&gt;

&lt;h6 id=&quot;如何创建-influxdb-数据库和用户&quot;&gt;如何创建 InfluxDB 数据库和用户&lt;/h6&gt;

&lt;p&gt;这里需要创建数据库和用户，后面 Telegraf 需要访问数据库，以存储来自 MQTT 的数据。&lt;/p&gt;

&lt;p&gt;首先打开 InfluxDB CLI：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker exec -it influxdb influx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来创建数据库和用户：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;create database sensors

create user &quot;telegraf&quot; with password &quot;telegraf&quot;

grant all on sensors to telegraf
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 02:45:00 +0000</pubDate>
        <link>https://blog.zwt.io/2021/03/05/grafana-iot-visualization-dashboard/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2021/03/05/grafana-iot-visualization-dashboard/</guid>
        
        <category>IoT</category>
        
        <category>可视化</category>
        
        <category>物联网</category>
        
        <category>传感器</category>
        
        
      </item>
    
      <item>
        <title>剑指Offer 面试题 3</title>
        <description>&lt;h4 id=&quot;题目&quot;&gt;题目&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一个长度为n的数组里的所有数字都在 0 到 n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2 ,3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个题目在牛客网是&lt;strong&gt;请找出数组中第一个重复的数字&lt;/strong&gt;，书中是“请找出数组中&lt;strong&gt;任意一个&lt;/strong&gt;重复的数字”。如果直接按照书中的代码，那就不能通过牛客网的全部测试用例，这就有点搞了。不过还是先讲一下解题思路吧。&lt;/p&gt;

&lt;h5 id=&quot;先排序再扫描&quot;&gt;先排序，再扫描&lt;/h5&gt;

&lt;p&gt;排序后的数组很容易可以找出重复数字，从头到尾扫描一遍，发现相邻两个数相等的情况即找到了重复数字。时间复杂度为 $O(nlogn)$&lt;/p&gt;

&lt;h5 id=&quot;利用哈希表&quot;&gt;利用哈希表&lt;/h5&gt;

&lt;p&gt;从头到尾扫描一遍数组，如果哈希表中没有这个数字，就将它加入哈希表，如果该数字已存在，则找到了重复数字。这个方法可以用 $O(1)$ 的时间来判断哈希表是否包含当前扫描到的数字，整个算法的时间复杂度是 $O(n)$ ，但代价是需要一个 $O(n)$ 大小的哈希表。&lt;/p&gt;

&lt;h5 id=&quot;利用数组下标&quot;&gt;利用数组下标&lt;/h5&gt;

&lt;p&gt;因为数组中所有数字都在0~n-1范围内，如果数组没有重复数字，那么数组排序后里面数字应该与它对应的下标相等。但因为数组中数字有重复，所以某个位置上的数字应该会出现多于一次。其实说的是，某个下标对应着的与下标相等的数字可能出现多次。原书中那句话是，“由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。”，当时看到这句话有点懵，难道数组的一个位置还可以挤下两个数字？后来知道他所指的“位置”是指，下标值与数值相等的这种情况。说起位置，就有点想起 &lt;code&gt;PositionalList&lt;/code&gt; …&lt;/p&gt;

&lt;p&gt;清楚了上面的情况，那么怎么可以找出重复数字？书中也是一段文字描述，按照里边描述的确可以找出重复数字，但看起来有点不直观，所以画个流程图看看。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/image-20201207035713049.png&quot; alt=&quot;image-20201207035713049&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这实际上是一个 &lt;strong&gt;in-place&lt;/strong&gt; 的排序操作，一边排序同时判断是否有重复数字。上图中 &lt;em&gt;i&lt;/em&gt; 表示数组的下标值，&lt;em&gt;m&lt;/em&gt; 表示数字值。我们开始从头到尾依次扫描这个数组，当扫描到下标为 &lt;em&gt;i&lt;/em&gt; 的数字时，首先比较这个数字(&lt;em&gt;m&lt;/em&gt;)是否等于 &lt;em&gt;i&lt;/em&gt;。如果是，就扫描下一个数字；如果不等，则将该数字与第 &lt;em&gt;m&lt;/em&gt; 个数字进行比较（即与下标值等于 &lt;em&gt;m&lt;/em&gt; 的那个数比较）。此时，如果它和第 &lt;em&gt;m&lt;/em&gt; 个数字相等，则找到了一个重复数字，因为这个数字在下标值为 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;m&lt;/em&gt; 的位置都出现了。如果它和第 &lt;em&gt;m&lt;/em&gt; 个数字不相等，就将第 &lt;em&gt;i&lt;/em&gt; 个数字和第 &lt;em&gt;m&lt;/em&gt; 个数字交换，这个操作就是将 &lt;em&gt;m&lt;/em&gt; 放到下标值等于其数值的位置，放在它该出现的位置上。这个过程其实就是一个插入排序（Insertion Sort），利用了数组下标有序，in-place 操作做到空间复杂度为 $O(1)$ ，每个数字最多只要交换两次就可以找到它自己的位置，因此总的时间复杂度是 $O(n)$，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * @param numbers     输入的数组
 * @param length      数组的长度
 * @param duplication 原书中的是 C/C++ 的一个指针，用于返回数组中重复的数字，
                      在这里可能只是为了统一，将重复数字存在数组第一个位置
 * @return            true 如果有重复，否则 false
 */
public boolean duplicate(int numbers[], int length, int[] duplication) {
    // 判空
    if (numbers == null || length &amp;lt;= 0) {
        return false;
    }

    // 判断是否数组内数字是否符合题目要求范围
    for (int i = 0; i &amp;lt; length; i++) {
        if (numbers[i] &amp;lt; 0 || numbers[i] &amp;gt; length - 1) {
            return false;
        }
    }

    for (int i = 0; i &amp;lt; length; i++) {
        while(numbers[i] != i) {  // 原题是找到任意一个重复数字，但这样做不符合牛客网的要求
        // if (numbers[i] != i) {  // 改为 if 可以通过牛客网题目测试，但题解不正确，因为测试用例有问题，奇怪。
            if (numbers[i] == numbers[numbers[i]]) {
                duplication[0] = numbers[i];
                return true;
            }

            // swap numbers[i] and numbers[numbers[i]]
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过测试的一种解法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean duplicate(int[] numbers, int length, int[] duplication) {

    if (numbers == null || length &amp;lt;= 0) {
        return false;
    }

    Set&amp;lt;Integer&amp;gt; values = new HashSet&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; length; i++) {
        if (numbers[i] &amp;lt; 0 || numbers[i] &amp;gt; length - 1) {
            return false;
        }
    }

    int[] cloned = Arrays.copyOf(numbers, numbers.length);

    for (int i = 0; i &amp;lt; length; i++) {
        while (numbers[i] != i) {  //原题是找到任意一个重复数字
            if (numbers[i] == numbers[numbers[i]]) {
                //duplication[0] = numbers[i];
                values.add(numbers[i]);
                break;
            }

            // swap numbers[i] and numbers[numbers[i]]
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    if (!values.isEmpty()) {
        for (int i : cloned) {
            if (values.contains(i)) {
                duplication[0] = i;
                break;
            }
        }
    }

    return !values.isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成这样还不如下面这种方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 使用临时数组
public boolean duplicate(int numbers[], int length, int[] duplication) {
    if (numbers == null || numbers.length == 0)
        return false;
    int[] temp = new int[length];
    for (int i = 0; i &amp;lt; length; i++) {
        temp[numbers[i]]++;
        if (temp[numbers[i]] &amp;gt; 1) {
            duplication[0] = numbers[i];
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个方法参考自：&lt;a href=&quot;https://blog.nowcoder.net/n/1fe32887be5c453aae05429990659f52&quot;&gt;牛客网的一个解题&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;结束了&quot;&gt;结束了&lt;/h5&gt;

&lt;p&gt;这个题是剑指 Offer 开局的第一题，有点经典，除了上面主要着重分析的方法，还有其它各种解法，但传统解题以点到为止。时间不太够，要继续刷其它题了。&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Dec 2020 03:03:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/12/07/find-duplicate-number-in-array/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/12/07/find-duplicate-number-in-array/</guid>
        
        <category>Java</category>
        
        <category>面试</category>
        
        
      </item>
    
      <item>
        <title>剑指Offer 面试题 34</title>
        <description>&lt;h4 id=&quot;题目&quot;&gt;题目&lt;/h4&gt;

&lt;p&gt;书中原题目是：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;struct BinaryTreeNode
{
  int               m_nValue;
  BinaryTreeNode    m_pLeft;
  BinaryTreeNode    m_pRight;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过牛客网上的题目，稍微有点不同：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题目是要求返回 &lt;code&gt;ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;&lt;/code&gt;，还有那个按字典序打印。&lt;/p&gt;

&lt;p&gt;这道题主要是对树进行前序遍历，访问到某个节点时累加起来，直到叶子节点，判断路径节点值之和是否为要求的整数。思路相对来说比较简单和直接，但是需要注意实现采用的数据结构的细节。&lt;br /&gt;
首先，从一个具体例如入手分析，输入下图 1 中二叉树和整数 22  &lt;!--more--&gt;
&lt;img src=&quot;/img/binary-tree.png&quot; alt=&quot;二叉树&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从根节点 10 开始按前序遍历，下一个节点是 5，此时路径包含两个节点，分别是 10，5。接下来将访问到 4 这个节点，这时候已经达到叶子节点，但路径上的节点值之和是 19，不等于 22，所以不符合要求。之后回溯到父子点 5，接着再去访问右节点 7，此时路径中的节点的值 10，5，7之和刚好是 22，符合要求。&lt;br /&gt;
其中的规律是，当用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值。如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，我们把它添加到&lt;code&gt;ArrayList&lt;/code&gt;里边。如果当前节点不是叶节点，则继续访问它的子节点。当前节点访问结束后，递归方法将自动回到它的父节点。因此，我们在方法退回之前在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点。可以看出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一致，而递归调用的本质就是一个压栈和出栈的过程。这里的内容基本跟书里的讲解差不多，只不过按牛客网的题目要求，并且用 Java 实现的话，我自己的做法是使用了集合框架里的 &lt;code&gt;Deque&lt;/code&gt; 接口，一个双端队列。因为这样子，可以保证队列的顺序符合最终要求返回的路径内节点的顺序，同时也可以当作一个栈在队尾（相当于栈顶）操作。具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.ch4;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;

/**
 * 输入一颗二叉树的根节点和一个整数，
 * 按字典序打印出二叉树中结点值的和为输入整数的所有路径。
 * 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
 */
public class FindPathSum {

    private final ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; lists;

    public FindPathSum() {
        this.lists = new ArrayList&amp;lt;&amp;gt;();
    }

    public static class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    /**
     * @param root   输入的二叉树的根节点
     * @param target 预期路径节点值之和
     * @return 路径组成的 List
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root, int target) {
        if (root == null) {
            return new ArrayList&amp;lt;&amp;gt;();
        }
        Deque&amp;lt;Integer&amp;gt; path = new ArrayDeque&amp;lt;&amp;gt;();  // 一个双端队列存储路径
        int currentSum = 0;
        return findPath(root, target, path, currentSum);
    }

    /**
     * @param root       当前节点
     * @param target     路径节点值之和
     * @param path       路径
     * @param currentSum 当前路径值之和
     * @return 返回多少路径
     */
    private ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; findPath(TreeNode root, int target, Deque&amp;lt;Integer&amp;gt; path, int currentSum) {

        currentSum += root.val;
        path.offer(root.val);  // 放入队列

        // 如果是叶节点，并且路径上节点值的和等于输入的值，
        // 则将这条路径添加到 ArrayList
        boolean isLeaf = root.left == null &amp;amp;&amp;amp; root.right == null;  // 递归结束条件
        if (currentSum == target &amp;amp;&amp;amp; isLeaf) {
            lists.add(new ArrayList&amp;lt;&amp;gt;(path));
        }

        // 如果不是叶节点，则遍历它的子节点
        if (root.left != null) {
            findPath(root.left, target, path, currentSum);
        }
        if (root.right != null) {
            findPath(root.right, target, path, currentSum);
        }

        // 在返回父节点之前，在路径上删除当前节点
        path.pollLast();
        return lists;

    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 03 Dec 2020 21:40:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/12/03/binary-path-sum/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/12/03/binary-path-sum/</guid>
        
        <category>Java</category>
        
        <category>面试</category>
        
        
      </item>
    
      <item>
        <title>水塔液位自动控制装置</title>
        <description>&lt;p&gt;前段时间做了点小东西，随缘记录一下。&lt;br /&gt;
在家里日常生活用水是用水塔，通过水泵将水从水井抽到楼顶的水塔用的。通常这些水塔都会有自动液位控制的，一般是一个浮球，机械式的开关。但家里的水塔比较旧没有安装水位控制装置，所以我一直想在水塔添加这样的功能。因为不想用浮球式液位控制，主要是想趁机折腾一下，玩一下技术。最初有些不太实际的脑洞，例如，可不可以通过测量液位变化时水塔的电容反映水位变化；还有根据水压变化计算出液面高度……  因为不想安装水压测量到水管里，而且还要设法与水泵开关联动，麻烦。大概五年前，上大二的时候，刚学单片机，就想着用 51 做一个东西去根据水塔液位变化自动控制水泵开关。  &lt;!--more--&gt;
&lt;img src=&quot;/img/image-20210305032735210.png&quot; alt=&quot;image-20210305032735210&quot; /&gt;
大概就是这么一个东西，当初用 51 接一个超声波测距模块，还有继电器，联合起来控制水泵。测得距离大于某个值，说明水位低于某个值，就打开水泵抽水，直到距离小于某个值就关掉水泵停止抽水，逻辑很简单的。&lt;br /&gt;
不过当时程序可能写得不太好，硬件也没有弄得很好，因为用洞洞板焊接的。那东西在一次暴雨天后就坏了，我弟以为那是遭雷击了，我也不太清楚，反正就坏了。 然后半个月前，我闲着又再次折腾起这东西。这次硬件上使用 Arduino + ESP8266 + 小米路由器 + 小米智能网关 + 加个小米 ZigBee 版智能插座。超声波测距模块由Arduino 驱动，再通过串口发送距离数据到 ESP8266，通过 WiFi TCP 传到小米路由器（跑 OpenWRT)，在小米路由器上的 Linux 写了个程序，基于 ubox (epoll) 的 TCP 和 UDP 客户端。其中 TCP 接收来自 ESP8266 的液位数据，UDP 客户端用于与小米智能网关交互。当水塔液位低于某个水平，这个程序就会向小米智能网关发送命令，去控制米家智能插座打开。这个插座接着水泵，就相当于初版里边的继电器。&lt;br /&gt;
之前还弄了个可视化监控的东西，但是后来 PC 机做的服务器崩了，就没有继续玩下去。本来还有个基于 JavaFX 的图形界面，可以查看液位，手动控制开关之类的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;更新了。上周换了一个防水的超声波模块，因为考虑到我不在老家的时候，如果用那种普通的 HC-SR04，不防水，一两个月就坏，没有空维修就麻烦。所以换了一个防水的，贵很多，但估计会比较耐用、稳定。录了个视频大概聊了一下: &lt;a href=&quot;https://www.bilibili.com/video/BV1b5411N7UX&quot;&gt;BV1b5411N7UX&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后关于可视化监控的，见另外一篇文章的介绍 &lt;a href=&quot;/2021/03/05/grafana-iot-visualization-dashboard/&quot;&gt;基于Grafana的物联网可视化仪表盘&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Nov 2020 12:13:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/11/23/water-tank-level-control-automation/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/11/23/water-tank-level-control-automation/</guid>
        
        <category>Personal</category>
        
        <category>Draft</category>
        
        <category>Notes</category>
        
        
      </item>
    
      <item>
        <title>Spring单例与单例模式</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Spring 单例不是 Java 单例。本文讨论 Spring 的单例与单例模式的区别。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;单例是 Spring 当中 bean 的默认范围(Scope)。Spring 容器会为某个 bean 定义对象创建唯一的实例，很多时候我们会将这种设计跟《设计模式》(GoF) 书中定义的单例模式作比较。&lt;/p&gt;

&lt;h3 id=&quot;1-单例范围-vs-单例模式&quot;&gt;1. 单例范围 vs 单例模式&lt;/h3&gt;

&lt;p&gt;Spring 当中的单例范围跟单例模式不是同一个东西。其中的两点差异如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单例模式确保某个类加载器的某个类只有一个实例&lt;/li&gt;
  &lt;li&gt;而 Spring 单例范围是每个容器的每个bean  &lt;!--more--&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;11-单例范围的例子&quot;&gt;1.1 单例范围的例子&lt;/h4&gt;

&lt;p&gt;Spring 的单例实例会被放在缓存中，下次再访问那个命名的 bean 的时候就会从缓存里面取。下边看看例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Account {

    private String name;

    public Account() {
    }

    public Account(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return &quot;Account{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring Boot 的 main 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@SpringBootApplication
public class SpringSingletonApp {

    public static void main(String[] args) {
        SpringApplication.run(SpringSingletonApp.class, args);
    }

    @Bean(name = &quot;bean1&quot;)
    public Account account() {
        return new Account(&quot;Test User 1&quot;);
    }

    @Bean(name = &quot;bean2&quot;)
    public Account account1() {
        return new Account(&quot;Test User 2&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理解上面的代码：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们创建了同一个类的 2 个实例，并有不同的 bean id。那么上面代码中 Spring 的 IoC 容器创建了多少个实例？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;2 个不同的实例，在容器中分别绑定到它们的 id？&lt;/li&gt;
  &lt;li&gt;还是 1 个实例绑定到 2 个 bean id？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-测试用例&quot;&gt;1.2 测试用例&lt;/h4&gt;

&lt;p&gt;我们使用单元测试找出答案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest
class SpringSingletonAppTests {

    private static final Logger log = LoggerFactory.getLogger(SpringSingletonAppTests.class);

    @Resource(name = &quot;bean1&quot;)
    Account account1;

    @Resource(name = &quot;bean1&quot;)
    Account duplicateAccount;

    @Resource(name = &quot;bean2&quot;)
    Account account2;

    @Test
    public void testSingletonScope() {
        log.info(account1.getName());
        log.info(account2.getName());

        log.info(&quot;Accounts are equal -&amp;gt; {}&quot;, account1 == account2);
        log.info(&quot;Duplicate account  -&amp;gt; {}&quot;, account1 == duplicateAccount);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;20:06:31.165 [main] INFO  i.z.s.SpringSingletonAppTests - Test User 1
20:06:31.165 [main] INFO  i.z.s.SpringSingletonAppTests - Test User 2
20:06:31.165 [main] INFO  i.z.s.SpringSingletonAppTests - Accounts are equal -&amp;gt; false
20:06:31.167 [main] INFO  i.z.s.SpringSingletonAppTests - Duplicate account  -&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的输出我们发现：
Spring 返回了两个不同的实例，单例范围的同一个类可以有多于一个的对象实例。&lt;/p&gt;

&lt;p&gt;对于某个 bean id，Spring 容器仅维护唯一的共享单例 bean，在我们上面的例子中，Spring IoC 容器基于同一个类的 bean 定义创建了两个实例，并将它们绑定到对应的 id。
Spring 的 bean 定义就像键值对那样，bean id 就是 key，bean 的实例就是 value。每个 key 引用都会返回同一个 bean 实例（例如 bean1 引用始终返回 id 为 bean1 的 bean）&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;Spring 单例跟传统的单例模式是不同的。Spring 确保在每个容器对给定 bean id 定义只创建一个 bean 实例。 传统单例模式是保证给定一个类加载器所加载的某个类只有唯一的一个实例。&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Nov 2020 02:04:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/11/02/Spring-singleton-vs-Singleton-pattern/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/11/02/Spring-singleton-vs-Singleton-pattern/</guid>
        
        <category>Personal</category>
        
        <category>Notes</category>
        
        
      </item>
    
      <item>
        <title>DS-ch15 Memory Management and B-Trees</title>
        <description>&lt;h1 id=&quot;155-exercises&quot;&gt;15.5 Exercises&lt;/h1&gt;

&lt;h3 id=&quot;reinforcement&quot;&gt;Reinforcement&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;R-15.1&lt;/strong&gt; Julia just bought a new computer that uses 64-bit integers to address memory cells. Argue why Julia will never in her life be able to upgrade the main memory of her computer so that it is the maximum-size possible, assuming that you have to have distinct atoms to represent different bits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.2&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. How many page misses does the LRU algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.3&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. How many page misses does the FIFO algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.4&lt;/strong&gt; Consider an initially empty memory cache consisting of four pages. What is the maximum number of page misses that the random algorithm incurs on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)? Show all of the random choices the algorithm made in this case.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.5&lt;/strong&gt; Describe, in detail, algorithms for adding an item to, or deleting an item from, an $(a,b)$ tree.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.6&lt;/strong&gt; Suppose &lt;em&gt;T&lt;/em&gt; is a multiway tree in which each internal node has at least five and at most eight children. For what values of &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; is $T$ a valid $(a,b)$ tree?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.7&lt;/strong&gt; For what values of d is the tree $T$ of the previous exercise an order-&lt;em&gt;d&lt;/em&gt; B-tree?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-15.8&lt;/strong&gt; Draw the result of inserting, into an initially empty order-7 B-tree, entries with keys (4,40,23,50,11,34,62,78,66,22,90,59,25,72,64,77,39,12), in this order.  &lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;creativity&quot;&gt;Creativity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;C-15.9&lt;/strong&gt; Describe an efficient external-memory algorithm for removing all the duplicate entries in an array list of size &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.10&lt;/strong&gt; Describe an external-memory data structure to implement the stack ADT so that the total number of disk transfers needed to process a sequence of &lt;em&gt;k&lt;/em&gt; push and pop operations is $O(k/B)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.11&lt;/strong&gt; Describe an external-memory data structure to implement the queue ADT so that the total number of disk transfers needed to process a sequence of &lt;em&gt;k&lt;/em&gt; enqueue and dequeue operations is $O(k/B)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.12&lt;/strong&gt; Describe an external-memory version of the &lt;code&gt;PositionalList&lt;/code&gt; ADT (Section 7.3), with block size &lt;em&gt;B&lt;/em&gt;, such that an iteration of a list of length n is completed using $O(n/B)$ transfers in the worst case, and all other methods of the ADT require only $O(1)$ transfers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.13&lt;/strong&gt; Change the rules that define red-black trees so that each red-black tree &lt;em&gt;T&lt;/em&gt; has a corresponding $(4,8)$ tree, and vice versa.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.14&lt;/strong&gt; Describe a modified version of the B-tree insertion algorithm so that each time we create an overflow because of a split of a node &lt;em&gt;w&lt;/em&gt;, we redistribute keys among all of &lt;em&gt;w&lt;/em&gt;’s siblings, so that each sibling holds roughly the same number of keys (possibly cascading the split up to the parent of &lt;em&gt;w&lt;/em&gt;). What is the minimum fraction of each block that will always be filled using this scheme?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.15&lt;/strong&gt; Another possible external-memory map implementation is to use a skip list, but to collect consecutive groups of $O(B)$ nodes, in individual blocks, on any level in the skip list. In particular, we define an &lt;strong&gt;&lt;em&gt;order-d B-skip list&lt;/em&gt;&lt;/strong&gt; to be such a representation
of a skip list structure, where each block contains at least $⌈d/2⌉$ list nodes and at most &lt;em&gt;d&lt;/em&gt; list nodes. Let us also choose &lt;em&gt;d&lt;/em&gt; in this case to be the maximum number of list nodes from a level of a skip list that can fit into one block. Describe how we should modify the skip-list insertion and removal algorithms for a &lt;em&gt;B&lt;/em&gt;-skip list so that the expected height of the structure is $O(logn/logB)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.16&lt;/strong&gt; Describe how to use a B-tree to implement the Partition ADT (Section 14.7.3) so that the union and find operations each use at most $O(logn/logB)$ disk transfers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.17&lt;/strong&gt; Suppose we are given a sequence &lt;em&gt;S&lt;/em&gt; of &lt;em&gt;n&lt;/em&gt; elements with integer keys such that some elements in &lt;em&gt;S&lt;/em&gt; are colored “blue” and some elements in &lt;em&gt;S&lt;/em&gt; are colored “red.” In addition, say that a red element &lt;em&gt;e&lt;/em&gt; &lt;strong&gt;&lt;em&gt;pairs&lt;/em&gt;&lt;/strong&gt; with a blue element &lt;em&gt;f&lt;/em&gt; if they have the same key value. Describe an efficient external-memory algorithm for finding all the red-blue pairs in &lt;em&gt;S&lt;/em&gt;. How many disk transfers does your algorithm perform?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.18&lt;/strong&gt; Consider the page caching problem where the memory cache can hold &lt;em&gt;m&lt;/em&gt; pages, and we are given a sequence &lt;em&gt;P&lt;/em&gt; of &lt;em&gt;n&lt;/em&gt; requests taken from a pool of $m + 1$ possible pages. Describe the optimal strategy for the offline algorithm and show that it
causes at most $m + n/m$ page misses in total, starting from an empty cache.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.19&lt;/strong&gt; Describe an efficient external-memory algorithm that determines whether an array of &lt;em&gt;n&lt;/em&gt; integers contains a value occurring more than &lt;em&gt;n/2&lt;/em&gt; times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.20&lt;/strong&gt; Consider the page caching strategy based on the &lt;strong&gt;&lt;em&gt;least frequently used&lt;/em&gt;&lt;/strong&gt; (LFU) rule, where the page in the cache that has been accessed the least often is the one that is evicted when a new page is requested. If there are ties, LFU evicts the least frequently used page that has been in the cache the longest. Show that there is a sequence P of n requests that causes LFU to miss $Ω(n)$ times for a cache of m pages, whereas the optimal algorithm will miss only $O(m)$ times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-15.21&lt;/strong&gt; Suppose that instead of having the node-search function $f (d) = 1$ in an order-&lt;em&gt;d&lt;/em&gt; B-tree &lt;em&gt;T&lt;/em&gt; , we have $f (d) = logd$. What does the asymptotic running time of performing a search in &lt;em&gt;T&lt;/em&gt; now become?&lt;/p&gt;

&lt;h3 id=&quot;projects&quot;&gt;Projects&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;P-15.22&lt;/strong&gt; Write a Java class that simulates the best-fit, worst-fit, first-fit, and next-fit algorithms for memory management. Determine experimentally which method is the best under various sequences of memory requests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-15.23&lt;/strong&gt; Write a Java class that implements all the methods of the sorted map ADT by means of an $(a,b)$ tree, where &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are integer constants passed as parameters to a constructor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-15.24&lt;/strong&gt; Implement the B-tree data structure, assuming a block size of 1024 and integer keys. Test the number of “disk transfers” needed to process a sequence of map operations.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Aug 2020 02:36:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/08/16/ds-ch15/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/08/16/ds-ch15/</guid>
        
        <category>Data Structure</category>
        
        
      </item>
    
      <item>
        <title>DS-ch01</title>
        <description>&lt;h1 id=&quot;110-exercises&quot;&gt;1.10 Exercises&lt;/h1&gt;

&lt;h3 id=&quot;reinforcement&quot;&gt;Reinforcement&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;R-1.1&lt;/strong&gt; Write a short Java method, &lt;code&gt;inputAllBaseTypes&lt;/code&gt;, that inputs a different value of each base type from the standard 
input device and prints it back to the standard output device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.2&lt;/strong&gt; Suppose that we create an array &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;GameEntry&lt;/code&gt; objects, which has an integer &lt;code&gt;scores&lt;/code&gt; field, and we clone &lt;code&gt;A&lt;/code&gt; and 
store the result in an array &lt;code&gt;B&lt;/code&gt;. If we then immediately set &lt;code&gt;A[4].scores&lt;/code&gt; equal to 550, what is the score value of the 
&lt;code&gt;GameEntry&lt;/code&gt; object referenced by &lt;code&gt;B[4]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.3&lt;/strong&gt; Write a short Java method, &lt;code&gt;isMultiple&lt;/code&gt;, that takes two &lt;code&gt;long&lt;/code&gt; values, &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;m&lt;/em&gt;, and returns true if and only if &lt;em&gt;n&lt;/em&gt; is a multiple of &lt;em&gt;m&lt;/em&gt;, that is, $n = mi$ for some integer &lt;em&gt;i&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.4&lt;/strong&gt; Write a short Java method, &lt;code&gt;isEven&lt;/code&gt;, that takes an int i and returns true if and only if i is even. Your method cannot use the multiplication, modulus, or division operators, however.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.5&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of all positive integers less than or equal to n.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.6&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of  all the odd positive integers less than or equal to n.&lt;br /&gt;
&lt;strong&gt;R-1.7&lt;/strong&gt; Write a short Java method that takes an integer n and returns the sum of the squares of all positive integers less than or equal to n.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.8&lt;/strong&gt; Write a short Java method that counts the number of vowel in a given character string.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.9&lt;/strong&gt; Write a short Java method that uses a &lt;code&gt;StringBuilder&lt;/code&gt; instance to remove all the punctuation from a string s storing a sentence, for example, transforming the string “Let’s try, Mike!” to “Lets try Mike”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.10&lt;/strong&gt; Write a Java class, Flower, that has three instance variables of type &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;float&lt;/code&gt;, which respectively represent the name of the flower, its number of petals, and price. Your class must include a constructor method that initializes each variable to an appropriate value, and your class should include methods for setting the value of each type, and getting the value of each type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.11&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 to include a method that updates the credit limit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.12&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 so that it ignores any request to process a negative payment amount.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-1.13&lt;/strong&gt; Modify the declaration of the first for loop in the main method in Code Fragment 1.6 so that its charges will cause exactly one of the three credit cards to attempt to go over its credit limit. Which credit card is it?  &lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;creativity&quot;&gt;Creativity&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;C-1.14&lt;/strong&gt; Write a pseudocode description of a method that reverses an array of n integers, so that the numbers are listed in the opposite order than they were before, and compare this method to an equivalent Java method for doing the same thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.15&lt;/strong&gt; Write a pseudocode description of a method for finding the smallest and largest numbers in an array of integers and compare that to a Java method that would do the same thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.16&lt;/strong&gt; Write a short program that takes as input three integers, a, b, and c, from the Java console and determines if they can be used in a correct arithmetic formula (in the given order), like “a+b = c,” “a = b - c,” or “a ∗ b = c.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.17&lt;/strong&gt; Write a short Java method that takes an array of int values and determines if there is a pair of distinct elements of the array whose product is even.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.18&lt;/strong&gt; The p-norm of a vector v = (v1,v2,…,vn) in n-dimensional space is defined as kvk = qp v1p +v2p +···+vnp. For the special case of p = 2, this results in the traditional Euclidean norm, which represents the length of the vector. For example, the Euclidean norm of a two-dimensional vector with coordinates (4,3) has a Euclidean norm of √42 +32 = √16+9 = √25 = 5. Give an implementation of a method named norm such that norm(v, p) returns the p-norm value of v and norm(v) returns the Euclidean norm of v, where v is represented as an array of coordinates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.19&lt;/strong&gt; Write a Java program that can take a positive integer greater than 2 as input and write out the number of times one must repeatedly divide this number by 2 before getting a value less than 2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.20&lt;/strong&gt; Write a Java method that takes an array of float values and determines if all the numbers are different from each other (that is, they are distinct).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.21&lt;/strong&gt; Write a Java method that takes an array containing the set of all integers in the range 1 to 52 and shuffles it into random order. Your method should output each possible order with equal probability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.22&lt;/strong&gt; Write a short Java program that outputs all possible strings formed by using the characters ‘c’, ‘a’, ‘t’, ‘d’, ‘o’, and ‘g’ exactly once.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.23&lt;/strong&gt; Write a short Java program that takes two arrays a and b of length n storing int values, and returns the dot product of a and b. That is, it returns an array c of length n such that c[i] = a[i]· b[i], for i = 0,…,n - 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.24&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 so that printSummary becomes a nonstatic method, and modify the main method from Code Fragment 1.6 accordingly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-1.25&lt;/strong&gt; Modify the &lt;code&gt;CreditCard&lt;/code&gt; class to add a toString() method that returns a String representation of the card (rather than printing it to the console, as done by printSummary). Modify the main method from Code Fragment 1.6 accordingly to use the standard println command.&lt;/p&gt;

&lt;h3 id=&quot;projects&quot;&gt;Projects&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;P-1.26&lt;/strong&gt; Write a short Java program that takes all the lines input to standard input and writes them to standard output in reverse order. That is, each line is output in the correct order, but the ordering of the lines is reversed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.27&lt;/strong&gt; Write a Java program that can simulate a simple calculator, using the Java console as the exclusive input and output device. That is, each input to the calculator, be it a number, like 12.34 or 1034, or an operator, like + or =, can be done on a
separate line. After each such input, you should output to the Java console what would be displayed on your calculator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.28&lt;/strong&gt; A common punishment for school children is to write out a sentence multiple times. Write a Java stand-alone program that will write out the following sentence one hundred times: “I will never spam my friends again.” Your program should number each of the sentences and it should make eight different random looking typos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.29&lt;/strong&gt; The birthday paradox says that the probability that two people in a room will have the same birthday is more than half, provided n, the number of people in the room, is more than 23. This property is not really a paradox, but many people find it surprising. Design a Java program that can test this paradox by a series of experiments on randomly generated birthdays, which test this paradox for n = 5,10,15,20,…,100.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-1.30&lt;/strong&gt; (For those who know Java graphical user interface methods:) Define a &lt;code&gt;GraphicalTest&lt;/code&gt; class that tests the functionality of the &lt;code&gt;CreditCard&lt;/code&gt; class from Code Fragment 1.5 using text fields and buttons.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/08/15/ds-ch01/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/08/15/ds-ch01/</guid>
        
        <category>Data Structure</category>
        
        
      </item>
    
      <item>
        <title>回顾OCP 1Z0-816认证考试</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;群 OCA/OCP 考试交流QQ群 &lt;strong&gt;157563860&lt;/strong&gt;&lt;br /&gt;
其实这篇文章起源于 Twitter 上以为委瑞内拉小哥问我关于 OCP 考试的问题，我只好写这个作为回应。但中英夹杂，如果是国内读者看起来可能有点难受，改天再更新整理一下。 注意，现在 1Z0-816 考试已经没有了，只有 1Z0-819 考试。 另外前段时间我录了个视频，放在&lt;a href=&quot;https://www.bilibili.com/video/BV1ma4y1p7Dy&quot;&gt;B站小号这里&lt;/a&gt;，讲了一些关于考试的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I started with OCA Java SE 8 Programmer I exam last year, it took me 12 days to prepare the OCA exam. It was relatively easy to pass the OCA exam, but it was much harder to pass the OCP 11 exam. It took me roughly 3 months to get fully prepared for the ultimate 1Z0-816, namely Java SE 11 Programmer II exam, for which response to the Oracle Certified Professional: Java SE 11 Developer certification. This is by far the most difficult Java certification exam from Oracle/Sun, not just because it covers topics such as modules, functional programming, concurrent programming, IO. But also it includes some new objectives, like Java Secure Coding Guideline. For those who plan on taking the Oracle Java Certification exam, I strongly recommend you take a look at the official exam objectives before you start your study plan. Buy a good book, I think Selikoff’s book is great, I use that book for my exam preparation. Study the book chapter by chapter, or by topic, or whatever you want. Be sure to do the exercises, it will help you to consolidate your knowledge. It is also helpful to use flashcards to aid the memorization process, for example,  some core APIs or some syntax rules. Don’t go directly into the quiz without studying the materials thoroughly, that will be just a waste of time and energy. Because that’s very frustrating to see lots of errors. Take your time, start slowly, and gradually level up the difficulty.  Below are some useful references.&lt;/p&gt;

&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;books参考书籍&quot;&gt;Books(参考书籍)&lt;/h3&gt;

&lt;p&gt;I recommend : &lt;a href=&quot;https://www.amazon.com/Oracle-Certified-Professional-Programmer-Study/dp/1119617626/ref=dp_ob_title_bk&quot;&gt;OCP Oracle Certified Professional Java SE 11 Programmer II Study Guide: Exam 1Z0-816 1st Edition&lt;/a&gt; by &lt;a href=&quot;https://www.amazon.com/Scott-Selikoff/e/B00PFTZJ6G/ref=dp_byline_cont_book_1&quot;&gt;Scott Selikoff&lt;/a&gt; (Author), &lt;a href=&quot;https://www.amazon.com/Jeanne-Boyarsky/e/B00PF6JTQK/ref=dp_byline_cont_book_2&quot;&gt;Jeanne Boyarsky&lt;/a&gt; (Author)（This title will be released on July 8, 2020.）&lt;/p&gt;

&lt;p&gt;我建议使用这本书作为考试参考。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.selikoff.net/2019/08/31/my-experience-taking-the-new-java-se-11-programmer-ii-1z0-816-exam/&quot;&gt;Selikoff Java SE 11 experience&lt;/a&gt; 书的作者的考试经验&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;While questions within a topic were relatively straight-forward, the amount of topics you had to know for the 1Z0-816 exam dwarfs the 1Z0-809 exam. Annotations, Security, Local Type Inference, Private/Static Interface Methods, and Modules are completely new.&lt;/p&gt;

  &lt;p&gt;尽管考试相关的主题相对来说是很直接的，但你在 1Z0-816 考试所需要知道的主题内容使得 1Z0-809 相形见绌。注解、安全、局部类型推导，接口的私有/静态方法，以及模块的内容都是全新的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you have time… （有时间还推荐） Java Language Features, Java The Complete Reference, Effective Java&lt;/p&gt;

&lt;h3 id=&quot;mock-exam-software模拟软件&quot;&gt;Mock exam software(模拟软件)&lt;/h3&gt;

&lt;p&gt;I used (我使用的是) &lt;a href=&quot;http://www.enthuware.com/java-certification-mock-exams/oracle-certified-professional/ocp-java-11-exam-ii-1z0-816&quot;&gt;OCP Java 11 - 1Z0-816 Mock Exams Practice Tests/Questions Part 2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;oracle-website-pages官方页面&quot;&gt;Oracle website pages(官方页面)&lt;/h3&gt;

&lt;h4 id=&quot;technical技术相关&quot;&gt;Technical(技术相关)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Secure Coding Guidelines for Java SE&lt;/p&gt;

    &lt;p&gt;(页面已经更新了，排版比较现代了，而且小标题改为 Updated for Java SE 11 而不是 Java SE 13)&lt;br /&gt;
&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/seccodeguide.html&quot;&gt;Secure Coding Guidelines for Java SE&lt;/a&gt;&lt;br /&gt;
Updated for Java SE 11&lt;br /&gt;
Document version: 7.2&lt;br /&gt;
Published: 27 September 2018&lt;br /&gt;
Last updated: 7 May 2019&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Java SE 11 API docs : &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/index.html&quot;&gt;Java® Platform, Standard Edition &amp;amp; Java Development Kit Version 11 API Specification&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jls :  &lt;a href=&quot;https://docs.oracle.com/javase/specs/&quot;&gt;Java SE Specifications&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/annotations/&quot;&gt;Annotations Trail&lt;/a&gt; : Learn something new about annotations since Java 8(学习 Java 8 以来更新的注解)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;About Online Proctored Exam(关于在线考试) &lt;a href=&quot;https://players.brightcove.net/2985902027001/r1ZNvX6Ux_default/index.html?videoId=6151284095001&quot;&gt;Get Ready for your Online Proctored Exam - Oracle Certification(Video)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/oracle/onvue&quot;&gt;Oracle onvue&lt;/a&gt; Where to schedule an exam(考试报名地址  )&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/oracle/op/faqs/&quot;&gt;Online Proctoring FAQs&lt;/a&gt;  常见问题&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://home.pearsonvue.com/Documents/Online-Proctored/online-proctored-policies.aspx&quot;&gt;pearsonvue online-proctored-policies&lt;/a&gt;  在线考试政策&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://education.oracle.com/home&quot;&gt;甲骨文大学&lt;/a&gt;  (Oracle University)主页&lt;/p&gt;

&lt;p&gt;Checkout more info about certification exams(关于认证考试本身的信息，我建议你去Oracle University官方网站看看，考试的信息和认证路径的信息。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://education.oracle.com/java-se-8-programmer-i/pexam_1Z0-808&quot;&gt;OCA 808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/oracle-learning-subscription-eight-quick-tips&quot;&gt;Oracle Learning Subscriptions Eight Quick Tips&lt;/a&gt;   官方贴士&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/Gm1PqdbwBP0&quot;&gt;OnVUE Testing Experience&lt;/a&gt;  一个视频，在线考试的体验&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/oracle-certification-exams-are-more-accessible-than-ever-before&quot;&gt;Oracle Certification Exams Are More Accessible Than Ever Before&lt;/a&gt;  同样是一个关于在线考试的文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/certification/your-guide-to-oracle-certification-testing-anywhere&quot;&gt;Your Guide to Oracle Certification Testing Anywhere&lt;/a&gt;  在线考试文章&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;考试复习大纲1z0-816-exam-objects-in-chinese&quot;&gt;考试复习大纲(1Z0-816 exam objects in Chinese)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Java 基础&lt;/strong&gt;&lt;br /&gt;
创建并使用 &lt;code&gt;final&lt;/code&gt; 类&lt;br /&gt;
创建并使用内部，嵌套，以及匿名类&lt;br /&gt;
创建并使用枚举&lt;br /&gt;
&lt;strong&gt;Java 接口&lt;/strong&gt;&lt;br /&gt;
创建并使用带有默认方法的接口&lt;br /&gt;
创建并使用带有私有方法的接口&lt;br /&gt;
函数式接口与 Lambda 表达式&lt;br /&gt;
定义并编写函数式接口&lt;br /&gt;
创建并使用 Lambda 表达式，包括 Lambda 语句，局部变量作 lambda 参数&lt;br /&gt;
&lt;strong&gt;内置函数式接口&lt;/strong&gt;&lt;br /&gt;
使用 &lt;code&gt;java.util.function&lt;/code&gt; 包里的接口&lt;br /&gt;
使用核心函数式接口，包括 &lt;code&gt;Predicate&lt;/code&gt;, &lt;code&gt;Consumer&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; 和 &lt;code&gt;Supplier&lt;/code&gt;&lt;br /&gt;
使用 &lt;code&gt;java.util.function&lt;/code&gt; 包里基础接口的基本数据类型及二元变式&lt;br /&gt;
&lt;strong&gt;迁移到模块化应用&lt;/strong&gt;&lt;br /&gt;
迁移使用 Java SE 9 以前版本开发的应用到 SE 11，包括自上而下和自下而上迁移方式，将一个 Java SE 8 应用分模块作迁移&lt;br /&gt;
使用 &lt;code&gt;jdeps&lt;/code&gt; 确定依赖关系，并识别解决循环依赖的方法。&lt;br /&gt;
&lt;strong&gt;并发&lt;/strong&gt;&lt;br /&gt;
使用 &lt;code&gt;Runnable&lt;/code&gt;，&lt;code&gt;Callable&lt;/code&gt; 创建工作线程，并使用 &lt;code&gt;ExecutorService&lt;/code&gt; 并发地执行任务&lt;br /&gt;
使用 &lt;code&gt;java.util.concurrent&lt;/code&gt; 包里的容器和类，包括 &lt;code&gt;CyclicBarrier&lt;/code&gt; 和 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;br /&gt;
编写线程安全的代码&lt;br /&gt;
识别线程问题，例如死锁和活锁&lt;br /&gt;
&lt;strong&gt;I/O (基础以及 NIO2)&lt;/strong&gt;&lt;br /&gt;
使用 I/O 流从控制台和文件读写数据&lt;br /&gt;
使用 I/O 流读写文件&lt;br /&gt;
使用序列化读写对象&lt;br /&gt;
使用 &lt;code&gt;Path&lt;/code&gt; 接口操作文件和目录路径&lt;br /&gt;
使用 &lt;code&gt;Files&lt;/code&gt; 类去检查、删除、复制或移动一个文件或目录&lt;br /&gt;
结合 &lt;code&gt;Files&lt;/code&gt; 类使用 Stream API&lt;br /&gt;
&lt;strong&gt;JDBC 数据库应用&lt;/strong&gt;&lt;br /&gt;
使用 JDBC URLs 和 &lt;code&gt;DriverManager&lt;/code&gt; 连接到数据库&lt;br /&gt;
使用 &lt;code&gt;PreparedStatement&lt;/code&gt; 去执行 CRUD 操作&lt;br /&gt;
使用 &lt;code&gt;PreparedStatement&lt;/code&gt; 和 &lt;code&gt;CallableStatement&lt;/code&gt; APIs 去执行数据库操作&lt;br /&gt;
&lt;strong&gt;注解&lt;/strong&gt;&lt;br /&gt;
表述注解的用途以及典型使用模式&lt;br /&gt;
应用注解到类和方法&lt;br /&gt;
描述 JDK 中常用的注解&lt;br /&gt;
声明自定义注解&lt;br /&gt;
异常处理与断言&lt;br /&gt;
使用 try-with-resources 结构&lt;br /&gt;
创建并使用自定义异常类&lt;br /&gt;
使用断言测试不变性&lt;br /&gt;
&lt;strong&gt;泛型与容器&lt;/strong&gt;&lt;br /&gt;
使用包装类，自动装箱和自动拆箱&lt;br /&gt;
用钻石记号和通配符创建并使用泛型类、方法&lt;br /&gt;
描述容器框架并使用主要容器接口&lt;br /&gt;
使用 &lt;code&gt;Comparator&lt;/code&gt; 和 &lt;code&gt;Comparable&lt;/code&gt; 接口&lt;br /&gt;
创建并使用容器的便利方法&lt;br /&gt;
&lt;strong&gt;Java Stream API&lt;/strong&gt;&lt;br /&gt;
描述 Stream 接口和管道&lt;br /&gt;
使用 lambda 表达式和方法引用&lt;br /&gt;
Streams 上的 Lambda 操作&lt;br /&gt;
使用 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt; 和 &lt;code&gt;flatMap&lt;/code&gt; 方法提取 stream 数据&lt;br /&gt;
使用 &lt;code&gt;findFirst&lt;/code&gt;, &lt;code&gt;findAny&lt;/code&gt;, &lt;code&gt;anyMatch&lt;/code&gt;, &lt;code&gt;allMatch&lt;/code&gt; 和 &lt;code&gt;noneMatch&lt;/code&gt; 方法搜索 stream 数据&lt;br /&gt;
使用 &lt;code&gt;Optional&lt;/code&gt; 类&lt;br /&gt;
使用 &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;average&lt;/code&gt; 和 &lt;code&gt;sum&lt;/code&gt; stream 操作执行计算&lt;br /&gt;
使用 lambda 表达式对容器排序&lt;br /&gt;
在 streams 使用 &lt;code&gt;Collectors&lt;/code&gt; ，包括 &lt;code&gt;groupingBy&lt;/code&gt; 和 &lt;code&gt;partitioningBy&lt;/code&gt; 操作&lt;br /&gt;
&lt;strong&gt;模块化应用中的服务&lt;/strong&gt;&lt;br /&gt;
描述服务的组件，包括指令&lt;br /&gt;
设计一个服务类型，使用 &lt;code&gt;ServiceLoader&lt;/code&gt; 加载服务，检查服务的依赖，包括消费者和提供者模块&lt;br /&gt;
&lt;strong&gt;并行 Streams&lt;/strong&gt;&lt;br /&gt;
编写使用并行 streams 的代码&lt;br /&gt;
用 streams 实现分解与归约操作&lt;br /&gt;
&lt;strong&gt;Java SE 应用安全编码&lt;/strong&gt;&lt;br /&gt;
在 Java 应用中预防拒绝服务&lt;br /&gt;
在 Java 应用中保护机密信息&lt;br /&gt;
实现数据一致性准则——注入和包含以及输入校验&lt;br /&gt;
通过限制可访问性和可扩展性保护代码受外部攻击，妥善处理输入校验以及可变性&lt;br /&gt;
安全地构建敏感对象&lt;br /&gt;
保护序列化与反序列化&lt;br /&gt;
&lt;strong&gt;本地化&lt;/strong&gt;&lt;br /&gt;
使用 &lt;code&gt;Locale&lt;/code&gt; 类&lt;br /&gt;
使用资源包&lt;br /&gt;
使用 Java 格式化消息、日期和数字&lt;/p&gt;
</description>
        <pubDate>Sun, 31 May 2020 06:32:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/05/31/Oracle-1Z0-816-exam-review/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/05/31/Oracle-1Z0-816-exam-review/</guid>
        
        <category>Java</category>
        
        <category>Certification</category>
        
        
      </item>
    
      <item>
        <title>Java笔试题1</title>
        <description>&lt;h3 id=&quot;真题1-某知名互联网下载服务提供商软件工程师笔试题&quot;&gt;真题1 某知名互联网下载服务提供商软件工程师笔试题&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一、选择题&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; 访问修饰符作用范围由大到小是（ ）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.private-protected-default-public&lt;br /&gt;
B.public-protected-default-private&lt;br /&gt;
C.private-default-protected-public&lt;br /&gt;
D.public-default-protected-private&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这题没什么好说，当然是选择 &lt;strong&gt;B&lt;/strong&gt; 啦，初学的时候可能有点难记住，不过习惯了就记住了。后来越了解就更容易记住，根本不需要死记硬背。 &lt;code&gt;default&lt;/code&gt; 关键字，表示访问权限的时候，其实新的规范（8以上？）改称为 ‘package private’ 可以理解为包内私有访问权限，所以限制程度就是仅次于私有。接着protected和public容易，因为public肯定是范围最宽（大）的。&lt;br /&gt;
关于类的访问修饰符的作用范围，Java语言规范的 8.1.1 节有：&lt;br /&gt;
The access modifier &lt;code&gt;public&lt;/code&gt; pertains only to top level classes and member classes, not to local classes or anonymous classes.&lt;br /&gt;
The access modifier &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; pertain only to member classes within a directly enclosing class declaration.&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 在Java 语言中，下面接口以键−值对的方式存储对象的是（ ）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.java.util.List&lt;br /&gt;
B.java.util.Map&lt;br /&gt;
C.java.util.Collection&lt;br /&gt;
D.java.util.Set&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选 &lt;strong&gt;B&lt;/strong&gt; 这题也很直接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 以下不是Object 类的方法的是（ ）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.hashCode()&lt;br /&gt;
B.finalize()&lt;br /&gt;
C.notify()&lt;br /&gt;
D.hasNext()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选 &lt;strong&gt;D&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public void change(String str, char ch[]) {
        str = &quot;test ok&quot;;
        ch[0] = 'g';
    }
    public static void main(String args[]) {
      String str = new String(&quot;good&quot;);
      char[] ch = { 'a', 'b', 'c' };
      Test ex = new Test();
      ex.change(str, ch);
      System.out.print(str + &quot; and &quot;);
      System.out.print(ch);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面程序的运行结果是（ ）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A.good and abc&lt;br /&gt;
B.good and gbc&lt;br /&gt;
C.test ok and abc&lt;br /&gt;
D.test ok and gbc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选 &lt;strong&gt;B&lt;/strong&gt; 在 Java 语言中，除了8 种原始的数据类型（分别为 &lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;boolean&lt;/code&gt;）外，其他的类型都是对象，在方法调用的时候，传递的都是引用。引用从本质上来讲也是按值传递，只不过传递的这个值是对象的引用而已，因此，在方法调用的时候，对形参引用所指对象属性值的修改对实参可见。但是对引用值本身的修改对实参是不可见的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、填空题&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; &lt;code&gt;Math.round(12.5)&lt;/code&gt; 的返回值等于（ &lt;strong&gt;13&lt;/strong&gt; ），&lt;code&gt;Math.round(-12.5)&lt;/code&gt; 的返回值等于（ &lt;strong&gt;-12&lt;/strong&gt; ）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;round&lt;/code&gt; 是一个四舍五入的方法，12.5 的小数部分为 0.5，当对其执行 &lt;code&gt;Math.round()&lt;/code&gt; 操作时，结果需要四舍五入，所以，结果为 13；−12.5 的小数部分也为 0.5，当对
其执行 &lt;code&gt;Math.round()&lt;/code&gt; 操作时，结果也需要四舍五入，由于 −12 &amp;gt; −13，因此，结果为 −12。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 有如下程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str1 = &quot;hello world&quot;;
String str2 = &quot;hello&quot; + new String(&quot;world&quot;);
System.out.println(str1 == str2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么程序的运行结果是（ &lt;strong&gt;false&lt;/strong&gt; ）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 在Java 语言中，基本数据类型包括（ 浮点型 float、double ）、字符类型（ char ）、布尔类型 boolean 和 数值类型（byte、short、int、long ）。&lt;br /&gt;
&lt;strong&gt;4.&lt;/strong&gt; 字符串分为两大类：一类是字符串常量（ String ）；另一类是字符串变量（ StringBuffer ）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、简答题&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1.&lt;/strong&gt; 接口和抽象类有什么区别？&lt;/p&gt;

&lt;p&gt;答案：接口（interface）和抽象类（abstract class）是支持抽象类定义的两种机制（注意，该句中前后两个抽象类的意义不一样，前者表示的是一个实体，后者表示的是一个概念）。&lt;br /&gt;
两者具有很大的相似性，甚至有时候是可以互换的。但同时，两者也存在很大的区别。具体而言，接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，如果一个类中包含抽象方法，那么这个类就是抽象类。在Java 语言中，可以通过把类或者类中的某些方法声明为abstract（abstract 只能用来修饰类或者方法，不能用来修饰属性）来表示一个类是抽象类。接口就是指一个方法的集合，接口中的所有方法都没有方法体，在Java 语言中，接口是通过关键字interface 来实现的。包含一个或多个抽象方法的类就必须被声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明为抽象的方法不能包含方法体。在抽象类的子类中，实现方法必须含有相同的或者更低的访问级别（public-&amp;gt;protected-&amp;gt;private）。抽象类在使用的过程中不能被实例化，但是可以创建一个对象使其指向具体子类的一个实例。抽象类的子类为父类中所有的抽象方法提供具体的实现，否则，它们也是抽象类。接口可以被看作是抽象类的变体，接口中所有的方法都是抽象的，可以通过接口来间接地实现多重继承。接口中的成员变量都是static final
类型，由于抽象类可以包含部分方法的实现，所以，在一些场合下抽象类比接口存在更多的优势。接口与抽象类的相同点如下：&lt;br /&gt;
1）都不能被实例化。&lt;br /&gt;
2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。&lt;br /&gt;
接口与抽象类的不同点如下：&lt;br /&gt;
1）接口只有定义，不能有方法的实现，而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。&lt;br /&gt;
2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类，因此，使用接口可以间接地达到多重继承的目的。&lt;br /&gt;
3）接口强调特定功能的实现，其设计理念是“has-a”关系，而抽象类强调所属关系，其设计理念为“is-a”关系。&lt;br /&gt;
4）接口中定义的成员变量默认为public static final，只能够有静态的不能被修改的数据成员，而且，必须给其赋初值，其所有的成员方法都是public、abstract 的，而且只能被这两个关键字修饰。而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法，而且，抽象类中的成员变量默认为default，当然也可以被定义为private、protected 和public，这些成员变量可以在子类中被重新定义，也可以被重新赋值，抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized 和native 等访问修饰符修饰，同时方法必须以分号结尾，并且不带花括号{}。所以，当功能需要累积时，使用抽象类；不需要累积时，使用接口。&lt;br /&gt;
5）接口被运用于实现比较常用的功能，便于日后维护或者添加删除方法，而抽象类更倾向于充当公共类的角色，不适用于日后重新对里面的代码进行修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 实现多线程的方法有哪几种？&lt;/p&gt;

&lt;p&gt;答案：Java 虚拟机（Java Virtual Machine，JVM，是运行所有Java 程序的抽象计算机，是Java 语言的运行环境）允许应用程序并发地运行多个线程。在Java 语言中，多线程的实现一般有以下三种方法：&lt;br /&gt;
1）实现Runnable 接口，并实现该接口的run()方法。&lt;br /&gt;
以下是主要步骤：
① 自定义类并实现Runnable 接口，实现run()方法。&lt;br /&gt;
② 创建Thread 对象，用实现Runnable 接口的对象作为参数实例化该Thread 对象。&lt;br /&gt;
③ 调用Thread 的start()方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 利用递归方法求6!&lt;/p&gt;

&lt;p&gt;答案：本题考查的是递归知识。&lt;/p&gt;

&lt;p&gt;使用递归时，关键问题是要明白递归表达式的含义以及递归的终止条件。&lt;/p&gt;

&lt;p&gt;实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static long fac(int n) {
        if(n &amp;gt; 1)
            return (n * fac(n - 1));
        else
            return 1;
    }
    public static void main(String[] args) {
        System.out.println(fac(6));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序运行的结果为&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;720&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 用Java 语言实现一个观察者模式。&lt;br /&gt;
答案：观察者模式（也被称为发布/订阅模式）提供了避免组件之间紧密耦合的另一种方法，它将观察者和被观察的对象分离开。在该模式中，一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者收到消息后所执行的操作与可观察的对象无关，这种模式使得对象可以相互对话，而不必了解原因。Java 语言与C#语言的事件处理机制就是采用的此种设计模式。例如，用户界面（同一个数据可以有多种不同的显示方式）可以作为观察者，业务数据是被观察者，当数据有变化后会通知界面，界面收到通知后，会根据自己的显示方式修改界面的显示。面向对象设计的一个原则是：系统中的每个类将重点放在某一个功能上，而不是其他方面。一个对象只做一件事情，并且将它做好。观察者模式在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。设计类图如图1 所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/image-20200531042853475.png&quot; alt=&quot;image-20200531042853475&quot; /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;图1👆&lt;/div&gt;

&lt;p&gt;具体的实现代码的继承关系如图2所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/observer-pattern.png&quot; alt=&quot;observer-pattern&quot; /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;图2👆&lt;/div&gt;

&lt;p&gt;下面给出一个观察者模式的示例代码，代码的主要功能是实现天气预报，同样的温度信息可以有多种不同的展示方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public interface Observer {

    // 更新温度
    void update(float temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

import java.util.ArrayList;

public class Whether implements Subject {

    private final ArrayList&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;&amp;gt;();
    private float temperature;

    @Override
    public void registerObserver(Observer o) {
        this.observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        this.observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : this.observers) {
            observer.update(temperature);
        }
    }

    public void whetherChange() {
        this.notifyObservers();
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
        notifyObservers();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public class WhetherDisplay1 implements Observer {

    private float temperature;

    public WhetherDisplay1(Subject whether) {
        whether.registerObserver(this);
    }

    @Override
    public void update(float temp) {
        this.temperature = temp;
        display();
    }

    private void display() {
        System.out.println(&quot;display1****:&quot; + this.temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package io.zwt.observer;

public class WhetherDisplay2 implements Observer {

    private float temperature;

    public WhetherDisplay2(Subject whether) {
        whether.registerObserver(this);
    }

    @Override
    public void update(float temp) {
        this.temperature = temp;
        display();
    }

    private void display() {
        System.out.println(&quot;display1----:&quot; + this.temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 一个有10 亿条记录的文本文件，已按照关键字排好序存储，请设计一个算法，可以从文件中快速查找指定关键字的记录。&lt;/p&gt;

&lt;p&gt;答案: 10 亿条记录对应的数量在 GB 量级,对于普通的计算机来讲,没有这么大的内存空间供使用,因此,无法一次把这些数据信息全部都读到内存中进行处理,需要对问题进行分解,例如把数据分成 100 份,每一份就是 100MB 量级,基本上放入内存无压力了.&lt;/p&gt;

&lt;p&gt;把这 10 亿条记录,均分为 100 份, 把每份的第一条记录关键字和此纪录对应的文件偏移量先扫入内存(类似索引),这里需要磁盘随机 IO 100 次.&lt;/p&gt;

&lt;p&gt;这样可以马上定位出指定关键字所在的记录块,把相应的记录块拿到内存,二分查找即可.&lt;/p&gt;
</description>
        <pubDate>Sun, 10 May 2020 20:02:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/05/10/java-interview-test1/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/05/10/java-interview-test1/</guid>
        
        <category>Java 笔试</category>
        
        
      </item>
    
      <item>
        <title>OCP-1Z0-816模拟测试2回顾</title>
        <description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Given&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Booby {
}
class Dooby extends Booby {
}
class Tooby extends Dooby {
}

public class TestClass {
  Booby b = new Booby();
  Tooby t = new Tooby();
  public void do1(List&amp;lt;? super Dooby&amp;gt; dataList) {
    //1 INSERT CODE HERE
  }
  public void do2(List&amp;lt;? extends Dooby&amp;gt; dataList) {
    //2 INSERT CODE HERE
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the following four statements:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;b = dataList.get(0);&lt;/li&gt;
  &lt;li&gt;t = dataList.get(0);&lt;/li&gt;
  &lt;li&gt;dataList.add(b);&lt;/li&gt;
  &lt;li&gt;dataList.add(t);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What can be inserted in the above code?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 1 and 3 can inserted at //1 and Statements 2 and 4 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Statement 4 can inserted at //1 and Statement 1 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 3 and 4 can inserted at //1 and Statements 1 and 2 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statements 1 and 2 can inserted at //1 and Statements 3 and 4 can be inserted at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Statement 1 can inserted at //1 and Statement 4 can be inserted at //2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;addData1(List&amp;lt;? super Dooby&amp;gt; dataList)&lt;/code&gt;&lt;br /&gt;
This means that dataList is a List whose elements are of a class that is either Dooby or a super class of Dooby. We don’t know which super class of Dooby. Thus, if you try to add any object to dataList, it has to be a assignable to Dooby.&lt;br /&gt;
Thus, &lt;code&gt;dataList.add(b);&lt;/code&gt; will be invalid because b is not assignable to Dooby.&lt;br /&gt;
Further, if you try to take some object out of dataList, that object will be of a class that is either Dooby or a Superclass of Dooby. Only way you can declare a variable that can be assigned the object retrieved from dataList is Object obj. Thus, &lt;code&gt;t = dataList.get(0);&lt;/code&gt; and &lt;code&gt;b = dataList.get(0);&lt;/code&gt; are both invalid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;addData2(List&amp;lt;? extends Dooby&amp;gt; dataList)&lt;/code&gt;&lt;br /&gt;
This means that dataList is a List whose elements are of a class that is either Dooby or a subclass of Dooby. Since we don’t know which subclass of Dooby is the list composed of, there is no way you can add any object to this list.&lt;br /&gt;
If you try to take some object out of dataList, that object will be of a class that is either Dooby or a subclass of Dooby and thus it can be assigned to a variable of class Dooby or its superclass.. Thus, &lt;code&gt;t = dataList.get(0);&lt;/code&gt; is invalid.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;泛型规则（JLS）&lt;/strong&gt;&lt;br /&gt;
A type argument $T_1$ is said to contain another type argument $T_2$, written $T_2 &amp;lt;= T_1$, is the set of types denoted by $T_2$ is provably a subset of the set of types denoted by $T_1$ under the reflexive and transitive closure of the following rules(where $&amp;lt;:$ denotes subtyping($\S4.10$)):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$?\space extends\space T&amp;lt;=\space ?\space extends \space S$ if $T &amp;lt;: S$&lt;/li&gt;
  &lt;li&gt;$?\space extends \space T&amp;lt;=\space ?$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ?\space super \space S$  if $T &amp;lt;: S$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ?$&lt;/li&gt;
  &lt;li&gt;$?\space super \space T&amp;lt;=\space ? \space extends \space Object$&lt;/li&gt;
  &lt;li&gt;$ T&amp;lt;=\space T$&lt;/li&gt;
  &lt;li&gt;$T &amp;lt;= \space ? \space extends \space T$&lt;/li&gt;
  &lt;li&gt;$T &amp;lt;= \space ? \space super \space T$&lt;br /&gt;
&lt;!--more--&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;
Given the following RDBMS table information :&lt;br /&gt;
STUDENT Table&lt;br /&gt;
SID INT Primary Key NAME VARCHAR(50)&lt;br /&gt;
GPA INT&lt;br /&gt;
and the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Statement stmt = connection.createStatement();  
ResultSet rs = stmt.executeQuery(&quot;select SID, NAME,  GPA from STUDENT&quot;);  
while(rs.next()){  
  System.out.println( INSERT CODE HERE );  
}  
connection.close();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What can be inserted in the above code so that it will print the GPA value for each student?  (Assume that items not specified such as import statements and try/catch block are all valid.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getString(2)
    &lt;blockquote&gt;
      &lt;p&gt;The numbering of columns in a ResultSet stars with 1. Therefore, it should be rs.getString(3).&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;rs.getString(3)
    &lt;blockquote&gt;
      &lt;p&gt;Although the value of the GPA field is int, it can still be retrieved using getString().&lt;br /&gt;
Note that if a field is of type VARCHAR and if you try to retrieve the value using say getInt(), it may throw an exception at runtime if the value cannot be parsed into an Integer.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getInt(2)
    &lt;blockquote&gt;
      &lt;p&gt;The numbering of columns in a ResultSet starts with 1. Therefore, it should be rs.getInt(3).&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs.getInteger(2)&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;rs.getInt(“GPA”)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Item {
  private int id;
  private String name;
  public Item(int id, String name) {
    this.id = id;
    this.name = name;
  }
  public Integer getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public String toString() {
    return name;
  }
}

public class Test {
  public static void main(String[] args) {
    List&amp;lt;Item&amp;gt; l = Arrays.asList(
          new Item(1, &quot;Screw&quot;),
          new Item(2, &quot;Nail&quot;),
          new Item(3, &quot;Bolt&quot;)
    );
    l.stream()
    // INSERT CODE HERE
    .forEach(System.out::print);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options can be inserted in the above code independent of each other, so that the code will print BoltNailScrew?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;.sorted((a, b)-&amp;gt;a.getId().compareTo(b.getId()))
    &lt;blockquote&gt;
      &lt;p&gt;This option creates a Comparator using a lambda expression that compares two Item objects for their id attribute. Syntactically, this option is correct but we need to sort by name instead of id.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;.sorted(Comparator.comparing(a-&amp;gt;a.getName())).map((i)-&amp;gt;i.getName())
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;This option uses Comparator’s comparing method that accepts a function that extracts a Comparable sort key, and returns a Comparator that compares by that sort key. Note that this is helpful only if the type of the object returned by the function implements Comparable. Here, it returns a String, which does implement Comparable and so it is ok.&lt;/li&gt;
        &lt;li&gt;Although the map part is not required because Item class overrides the toString method to print the name anyway, it is valid.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;.map((i)-&amp;gt;i.getName())
    &lt;blockquote&gt;
      &lt;p&gt;Just mapping the Items to their names will not help because we need to sort the elements as well.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;.map((i)-&amp;gt;i.getName()).sorted()
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;The call to map converts the stream of Items to a stream of Strings.&lt;/li&gt;
        &lt;li&gt;The call to sorted() sorts the stream of String by their natural order, which is what we want here.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; ls = Arrays.asList(3,4,6,9,2,5,7);
System.out.println(ls.stream().reduce(Integer.MIN_VALUE, (a, b)-&amp;gt;a&amp;gt;b?a:b)) //1
System.out.println(ls.stream().max(Integer::max).get()); //2
System.out.println(ls.stream().max(Integer::compare).get()); //3
System.out.println(ls.stream().max((a, b)-&amp;gt;a&amp;gt;b?a:b)); //4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the above statements will print 9?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;1 and 4&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2 and 3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;1 and 3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;2,3, and 4&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;All of them.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The code will print:&lt;/p&gt;

&lt;p&gt;9&lt;br /&gt;
3&lt;br /&gt;
9&lt;br /&gt;
Optional[3]&lt;/p&gt;

&lt;p&gt;You need to understand the following points to answer this question:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The reduce method needs a BinaryOperator. This interface is meant to consume two arguments and produce one output. It is applied repeatedly on the elements in the stream until only one element is left. The first argument is used to provide an initial value to start the process. (If you don’t pass this argument, a different reduce method will be invoked and that returns an Optional object. )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The Stream.max method requires a Comparator. All you need to implement this interface using a lambda expression is a reference to any method that takes two arguments and returns an int. The name of the method doesn’t matter. That is why it is possible to pass the reference of Integer’s max method as an argument to Stream’s max method. However, Integer.max works very differently from Integer.compare. The max method returns the maximum of two numbers while the compare method returns a difference between two numbers. Therefore, when you pass Integer::max to Stream’s max, you will not get the correct maximum element from the stream. That is why //2 will compile but will not work correctly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//4 is basically same as //2. It will not work correctly for the same reason.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String[] params() default {&quot;&quot;};
    String date() default &quot;&quot;;
    int depth() default 10;
    String value() ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) x) -&amp;gt;{ System.out.println(x);});&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is possible to annotate lambda parameters but to do that the type of the lambda parameter must be specified.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) var x) -&amp;gt;{ System.out.println(x);});&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Normally, when a lambda express requires only a single parameter, you don’t need to specify its type because it can be inferred by the compiler. However, in that case, you cannot apply an annotation to it. To be able to apply an annotation and to get the benefit of type inferencing, you can specify the type of the variable as var.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;(); al.forEach((@DebugInfo(&quot;lambda&quot;) Integer x) -&amp;gt;System.out.println(x));&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo( &quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Since there is only one element in the @DebugInfo annotation that does not have a default value and since its name is value, you can pass a value for this element directly without specifying the name.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = @DebugInfo(&quot;lambda&quot;)( a, b)-&amp;gt; a+b;&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The annotation is not placed correctly. You can do something like this: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) Integer a, Integer b)-&amp;gt; a+b;&lt;/code&gt; or &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda1&quot;) Integer a, @DebugInfo(&quot;lambda1&quot;) Integer b)-&amp;gt; a+b;&lt;/code&gt; or even this: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) var a, var b)-&amp;gt; a+b;&lt;/code&gt;  But you cannot do: &lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt; bin = ( @DebugInfo(&quot;lambda&quot;) var a, Integer b)-&amp;gt; a+b;&lt;/code&gt; because you cannot mix var and explicit types in lambda.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo( date=new Date(), value=&quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Value of an element must be a constant expression. So, new Date() is not a valid value for date element.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;br /&gt;
Which of the following method implementations will write a boolean value to the underlying stream?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw){ boolean bval = true;     pw.writeBoolean(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;PrintWriter does not have write  methods such as writeInt, writeBoolean, WriteLong. It has overloaded print methods for writing various primitives.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) throws IOException{     boolean bval = true; pw.write(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;PrintWriter does not have write(boolean ) method. It does have write(String), write(int ), write(char[] ) methods. It also has write(char[] buf, int off, int len) and write(String buf, int off, int len) methods that let you write a portion of the input buf.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) throws IOException{     boolean bval = true;  pw.print(bval); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Although the throws IOException clause is not required here, it is not invalid.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) { boolean bval = true;     pw.print(bval); }&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public void usePrintWriter(PrintWriter pw) { boolean bval = true;     pw.println(bval); }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Explanation&lt;br /&gt;
Remember that none of PrintWriter’s print or write methods throw I/O exceptions (although some of its constructors may). This is unlike other streams, where you need to include exception handling (i.e. a try/catch or throws clause) when you use the stream.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;10.&lt;/strong&gt;&lt;br /&gt;
Consider the following code fragment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void myMethod(int x)  //Specify throws clause here
{
    try{
        if(x == 0){
            throw new ClassNotFoundException();
        }
        else throw new NoSuchFieldException();
    }catch(RuntimeException e){
        throw e;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following is a valid throws clause for the above method?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;No throws clause is necessary.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;throws ClassNotFoundException, NoSuchFieldException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;throws ClassNotFoundException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;throws NoSuchFieldException&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;throws Exception&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;ClassNotFoundException&lt;/code&gt; and &lt;code&gt;NoSuchFieldException&lt;/code&gt; are checked exceptions and are thrown when you use Java reflection mechanism to load a class and access its fields. For example:&lt;br /&gt;
&lt;code&gt;Class c = Class.forName(&quot;test.MyClass&quot;);&lt;/code&gt; //may throw ClassNotFoundException&lt;br /&gt;
&lt;code&gt;java.lang.reflect.Field f = c.getField(&quot;someField&quot;);&lt;/code&gt; //may throw NoSuchFieldException&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;11.&lt;/strong&gt;&lt;br /&gt;
Which of the following are correct definitions of a repeatable annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public @interface Meal{ String value(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;For an annotation to be repeatable it must be defined with @Repeatable meta-annotation.&lt;br /&gt;
@Repeatable requires the name of the container annotation class. It cannot be empty. For example, @Repeatable(Meals.class)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@Repeatable(Meals.class) public @interface Meal { int id() default 0; } public @interface Meals{ Meal[] meals(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The name of the Meal[] array should be value, not meals.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;public @interface Meals{ Meal[] value(); String course() default &quot;maincourse&quot;; } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String name(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The value of the &lt;code&gt;@Repeatable&lt;/code&gt; meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type. It is possible to use other elements in the container annotation but they must have default values.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;public @interface Meals{ Meal[] value(); String course(); } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String value(); }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;It is possible to use other elements in the container annotation but they must have default values. So, String course(); should be changed to something like String course() default “maincourse”;&lt;br /&gt;
The reason for this restriction is simple. Java allows you to use the contained annotation and omit the container annotation. But internally, the container does create the container annotation and if there is no default value for any element of the container annotation, the compiler will not be able to supply its value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;
To make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write &lt;code&gt;@Meal(name=&quot;sandwich&quot;)&lt;/code&gt; but, internally, Java converts it to &lt;code&gt;@Meals(@Meal(name=&quot;sandwich&quot;))&lt;/code&gt;. If you apply two such annotations, for example:&lt;br /&gt;
&lt;code&gt;@Meal(name=&quot;sandwich&quot;)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;the compiler will convert them to: &lt;code&gt;@Meals({@Meal(name=&quot;sandwich&quot;), @Meal(name=&quot;fries&quot;) })&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A container annotation is also an annotation and just like any other annotation, it can be used independently. It can have other elements as well. For example, you can use the &lt;code&gt;@Meals&lt;/code&gt; annotation like this:&lt;br /&gt;
&lt;code&gt;@Meals(value={@Meal(name=&quot;sandwich&quot;), @Meal(name=&quot;fries&quot;) }, course=&quot;starter&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Remember that values of a repeated annotations are not additive. So, for example, you cannot expect &lt;code&gt;@Meal(id=1)&lt;/code&gt; and &lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt; to combine automatically to &lt;code&gt;@Meal(id=1, name=&quot;fries&quot;)&lt;/code&gt;. Since id is defined using a default value but name is not, &lt;code&gt;@Meal(name=&quot;fries&quot;)&lt;/code&gt; is valid but &lt;code&gt;@Meal(id=1)&lt;/code&gt; is not valid.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;12.&lt;/strong&gt;
Your application is packaged in myapp.jar and depends on a jar named datalayer.jar, which in turn depends on mysql-connector-java-8.0.11.jar. The following packages exist in these jars:&lt;/p&gt;

&lt;p&gt;myapp.jar:   com.abc.myapp&lt;br /&gt;
datalayer.jar: com.abc.datalayer&lt;br /&gt;
mysql-connector-java-8.0.11.jar:  com.mysql.jdbc&lt;/p&gt;

&lt;p&gt;You want to use bottom up approach for migrating your app to a modular app. Which of the following is required before you can do this?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Mysql driver jar and datalayer.jar must first be converted into modular jars.
    &lt;blockquote&gt;
      &lt;p&gt;In this case, mysql-connector-java-8.0.11.jar would have to become modular first, then datalayer.jar.&lt;br /&gt;
In the top down approach, on the other hand, you would directly make myapp.jar modular by including a module-info and adding requires datalayer; clause. You would create an automatic module for datalayer.jar by simply placing it on module-path (instead of classpath). You would leave mysql jar on the classpath so that datalayer could access it.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;datalayer.jar must first be converted into modular jar. The mysql jar need not be converted.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The mysql jar must first be converted into modular jar. The datalayer.jar need not be converted.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Neither datalayer nor mysql driver need to be converted into modular jars.&lt;br /&gt;
&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Bottom Up Approach for modularzing an application&lt;/strong&gt;&lt;br /&gt;
While modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in A.jar directly uses a class from B.jar, and a class in B.jar directly uses a class from C.jar, you need to first modularize C.jar and then B.jar before you can modularize A.jar.&lt;br /&gt;
Thus, bottom up approach is possible only when the dependent libraries are modularized already.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;14.&lt;/strong&gt;
Given:&lt;br /&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; ls = Arrays.asList(1, 2, 3);&lt;/code&gt;&lt;br /&gt;
Which of the following options will compute the sum of all Integers in the list correctly?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = ls.stream().sum();
    &lt;blockquote&gt;
      &lt;p&gt;There no sum method in Stream. There is one in IntStream and DoubleStream.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;double sum = ls.stream().reduce(0, (a,b)-&amp;gt; a+b);
    &lt;blockquote&gt;
      &lt;p&gt;The reduce method performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;double sum = ls.stream().mapToInt(x-&amp;gt;x).sum();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = 0; ls.stream().forEach(a-&amp;gt;{sum=sum+a;});
    &lt;blockquote&gt;
      &lt;p&gt;This code is almost correct but for the fact that only final local variables can be used in a lambda expression. Here, the code is trying to use sum and sum is not final. Effectively final means that even though it is not declared as final, it is not assigned any value anywhere else after the first assignment. That compiler determines that this variable never changes and consider it as final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;double sum = 0; ls.stream().peek(x-&amp;gt;{sum=sum+x;}).forEach(y-&amp;gt;{});
    &lt;blockquote&gt;
      &lt;p&gt;This has the same problem as above. sum is not final or effectively final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
It is important that you go through the JavaDoc API description of the three flavors of reduce method given here: You should read about the three flavors of reduce method given here: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&quot;&gt;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;15.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Book{
    private String title;
    private Double price;
    public Book(String title, Double price){
        this.title = title;
        this.price = price;
    }
    //accessor methods not shown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will the following code print when compiled and run?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Book b1 = new Book(&quot;Java in 24 hrs&quot;, null);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;DoubleSupplier ds1 = b1::getPrice;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;System.out.println(b1.getTitle()+&quot; &quot;+ds1.getAsDouble());&lt;/code&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs null&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs 0.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Java in 24 hrs&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will throw a NullPointerException.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile.
    &lt;blockquote&gt;
      &lt;p&gt;There is no problem with the code.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;java.util.function.DoubleSupplier&lt;/code&gt;(and other similar Suppliers such as IntSupplier and LongSupplier) is a functional interface with the functional method named &lt;code&gt;getAsDouble&lt;/code&gt;. The return type of this method is a primitive double (not &lt;code&gt;Double&lt;/code&gt;). Therefore, if your lambda expression for this function returns a &lt;code&gt;Double&lt;/code&gt;, it will automatically be converted into a double because of auto-unboxing. However, if your expression returns a null, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;19.&lt;/strong&gt;
What will the following code print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.Optional;
public class NewClass {
    public static Optional&amp;lt;String&amp;gt; getGrade(int marks){
        Optional&amp;lt;String&amp;gt; grade = Optional.empty();
        if(marks&amp;gt;50){
            grade = Optional.of(&quot;PASS&quot;);
        }
        else {
            grade.of(&quot;FAIL&quot;);
        }
        return grade;
    }
    public static void main(String[] args) {
        Optional&amp;lt;String&amp;gt; grade1 = getGrade(50);
        Optional&amp;lt;String&amp;gt; grade2 = getGrade(55);
        System.out.println(grade1.orElse(&quot;UNKNOWN&quot;));
        if(grade2.isPresent()){
            grade2.ifPresent(x-&amp;gt;System.out.println(x));
        }else{
            System.out.println(grade2.orElse(&quot;Empty&quot;));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;UNKNOWN PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[UNKNOWN] PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[UNKNOWN] Optional[PASS]&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;FAIL PASS&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Optional[FAIL] OPTIONAL[PASS]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You should go through the following article about java.util.Optional:&lt;br /&gt;
&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&quot;&gt;http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are a few important things you need to know about Optional class:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Optional has a static method named &lt;code&gt;of(T t)&lt;/code&gt; that returns an Optional object containing the value passed as argument. It will throw &lt;code&gt;NullPointerException&lt;/code&gt; if you pass &lt;code&gt;null&lt;/code&gt;. If you want to avoid &lt;code&gt;NullPointerException&lt;/code&gt;, you should use &lt;code&gt;Optional.ofNullable(T t)&lt;/code&gt; method. This will return &lt;code&gt;Optional.empty&lt;/code&gt; if you pass &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You cannot change the contents of Optional object after creation. Optional does not have a set method. Therefore, &lt;code&gt;grade.of&lt;/code&gt;, although technically correct, will not actually change the Optional object referred to by grade. It will return a new Optional object containing the passed argument.&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;orElse&lt;/code&gt; method returns the actual object contained inside the Optional or the argument passed to this method if the Optional is empty. It does not return an Optional object. Therefore, &lt;code&gt;print(grade1.orElse(&quot;UNKNOWN&quot;))&lt;/code&gt; will print UNKNOWN and not Optional[UNKNOWN].&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isPresent()&lt;/code&gt; returns true if the Optional contains a value, false otherwise.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ifPresent(Consumer)&lt;/code&gt; executes the &lt;code&gt;Consumer&lt;/code&gt; object with the value if the Optional contains a value. Not that it is the value contained in the Optional that is passed to the &lt;code&gt;Consumer&lt;/code&gt; and not the Optional itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;21.&lt;/strong&gt;
Consider the following method exposed by a utility class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static String getOptions(final String propName) {
                return AccessController.doPrivileged(
                    new PrivilegedAction&amp;lt;String&amp;gt;() {
                        public String run() {
                            return System.getProperty(propName);
                        }
                    }
                );
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It has been decided to give appropriate permission in the security file for this code. Identify correct statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It violates secure coding guidelines for invoking privileged actions.
    &lt;blockquote&gt;
      &lt;p&gt;As per Guideline 9-3 / ACCESS-3: “Safely invoke java.security.AccessController.doPrivileged”, the given code should retrieve a system property using a hardcoded value instead of passing user input directly to the OS. In the given code, the user can potentially wreck the application by requesting illformated or mischievous property name. Since the code is privileged, the call may cause unwanted impact directly on the OS.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It violates secure coding guidelines for exposing static methods.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It violates secure coding guidelines for validating inputs.
    &lt;blockquote&gt;
      &lt;p&gt;Ideally, it should validate whether the property name for which the value is requested is valid or not.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It violates secure coding guidelines for protecting confidential information.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;22.&lt;/strong&gt;
Which of the following statements are true regarding the try-with-resources statement?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources are closed in the same order of their creation.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources may not be closed properly if the code in the try block throws an exception for which there is no catch block.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Resources may not be closed properly if the code in the catch block throws an exception.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;catch and finally blocks are executed after the resources opened in the try blocks are closed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to know the following points regarding try-with-resources statement for the exam:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable.&lt;br /&gt;
&lt;strong&gt;2.&lt;/strong&gt; AutoCloseable has only one method - public void close() throws Exception.&lt;br /&gt;
&lt;strong&gt;3.&lt;/strong&gt; Resources are closed at the end of the try block and before any catch or finally block.&lt;br /&gt;
&lt;strong&gt;4.&lt;/strong&gt; Resources are not even accessible in the catch or finally block. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(Device d = new Device())
{
   d.read();
}finally{
   d.close(); //This will not compile because d is not accessible here.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Device d = new Device();
try(d){ //valid since Java 9
  ...
}finally{
   d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Resources are closed in the reverse order of their creation.&lt;br /&gt;
&lt;strong&gt;6.&lt;/strong&gt; Resources are closed even if the code in the try block throws an exception.&lt;br /&gt;
&lt;strong&gt;7.&lt;/strong&gt; java.lang.AutoCloseable’s &lt;code&gt;close()&lt;/code&gt; throws &lt;code&gt;Exception&lt;/code&gt; but java.io.Closeable’s &lt;code&gt;close()&lt;/code&gt; throws &lt;code&gt;IOException&lt;/code&gt;.&lt;br /&gt;
&lt;strong&gt;8.&lt;/strong&gt; If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;23.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {
    static Path p1 = Paths.get(&quot;c:\\finance\\data\\reports\\daily\\pnl.txt&quot;);  
    public static void main(String[] args) {
        System.out.println(p1.subpath(0, 2));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;finance\data&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;finance\data\&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\finance\data\reports&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c:\finance\data&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c:\finance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember the following points about &lt;code&gt;Path.subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indexing starts from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not considered as the beginning.&lt;/li&gt;
  &lt;li&gt;name at beginIndex is included but name at endIndex is not.&lt;/li&gt;
  &lt;li&gt;paths do not start or end with .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, in case of “c:\finance\data\reports\daily\pnl.txt”, name at 0 is &lt;em&gt;finance&lt;/em&gt; and name at 2 is &lt;em&gt;reports&lt;/em&gt;. However, since the name at endIndex is excluded, &lt;code&gt;subpath(0, 2)&lt;/code&gt; will correspond to finance\data.&lt;/p&gt;

&lt;p&gt;The following is the API description for this method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;br /&gt;
Returns a relative Path that is a subsequence of the name elements of this path.&lt;br /&gt;
The beginIndex and endIndex parameters specify the subsequence of name elements. The name that is closest to the root in the directory hierarchy has index 0. The name that is farthest from the root has index count-1. The returned Path object has the name elements that begin at beginIndex and extend to the element at index endIndex-1.&lt;/p&gt;

&lt;p&gt;Parameters:&lt;br /&gt;
beginIndex - the index of the first element, inclusive&lt;br /&gt;
endIndex - the index of the last element, exclusive&lt;br /&gt;
Returns:&lt;br /&gt;
a new Path object that is a subsequence of the name elements in this Path&lt;br /&gt;
Throws:&lt;br /&gt;
IllegalArgumentException - if beginIndex is negative, or greater than or equal to the number of elements. If endIndex is less than or equal to beginIndex, or larger than the number of elements.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;24.&lt;/strong&gt;
Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class AssertErrorTest
{
   public void robustMethod(int[] intArray) throws AssertionError
   {
      int[] newIA = //get new array by processing intArray
      assert newIA != intArray;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following declarations of robustMethod(int[] intArray) are valid in a subclass of the above class?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray)&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;public void robustMethod(int[] intArray) throws Exception
    &lt;blockquote&gt;
      &lt;p&gt;Exception is in a different branch of Exceptions than AssertionError.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;public void robustMethod(int[] intArray) throws Throwable
    &lt;blockquote&gt;
      &lt;p&gt;Throwable is a super class of AssertionError so it cannot be thrown from the subclass’s overriding method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray) throws Error
    &lt;blockquote&gt;
      &lt;p&gt;Error is also a superclass of AssertionError but any Error or any RuntimeException can be thrown without having to declare them in the throws clause.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;public void robustMethod(int[] intArray) throws RuntimeException&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This questions tests two concepts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;An overriding method must not throw any new or broader checked exceptions than the ones declared in the overridden method. This means, the overriding method can only throw the exceptions or the subclasses of the exceptions declared in the overridden method. It can throw any subclass of Error or RuntimeException as well because it is not mandatory to declare Errors and RuntimeExceptions in the throws clause. An overriding method may also choose not to throw any exception at all.&lt;/li&gt;
  &lt;li&gt;AssertionError is a subclass of Error.&lt;br /&gt;
Therefore, option 1, 4, and 5 are valid.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;25.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String sentence = &quot;Life is a box of chocolates, Forrest. You never know what you're gonna get.&quot;; //1
Optional&amp;lt;String&amp;gt; theword = Stream.of(sentence.split(&quot;[ ,.]&quot;)).anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;)); //2
System.out.println(theword.get()); //3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following statements are correct?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print gonna.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get if lines //2 and //3 are changed to: &lt;code&gt;String theword = Stream.of(sentence.split(&quot;[,.]&quot;)).anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;));&lt;/code&gt; //2 &lt;code&gt;System.out.println(theword.get());&lt;/code&gt; //3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It may print either gonna or get if lines //2 and //3 are changed to: &lt;code&gt;Optional&amp;lt;String&amp;gt; theword = Stream.of(sentence.split(&quot;[,.]&quot;)).parallel().anyMatch(w-&amp;gt;w.startsWith(&quot;g&quot;));&lt;/code&gt; //2 &lt;code&gt;System.out.println(theword.get());&lt;/code&gt; //3&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will fail to compile.
    &lt;blockquote&gt;
      &lt;p&gt;anyMatch returns a boolean and not an Optional. Therefore, //2 will not compile.&lt;br /&gt;
The expression Stream.of(sentence.split(“[,.]”)).anyMatch(w-&amp;gt;w.startsWith(“g”)); will actually just return true.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;anyMatch&lt;/code&gt; returns a boolean and not an Optional. Therefore, //2 will not compile.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;27.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  Connection con = DriverManager.getConnection(dbURL);
  con.setAutoCommit(false);
  String updateString =
        &quot;update SALES &quot; +
        &quot;set T_AMOUNT = 100 where T_NAME = 'BOB'&quot;;
  Statement stmt = con.createStatement();
  stmt.executeUpdate(updateString);
  //INSERT CODE HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What statement can be added to the above code so that the update is committed to the database?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;con.setAutoCommit(true);&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;con.commit(true);
    &lt;blockquote&gt;
      &lt;p&gt;commit() does not take any parameter.&lt;br /&gt;
FYI, there are two flavors of rollback() - one does not take any argument and another one takes a java.sql.Savepoint as an argument.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt.commit();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;con.setRollbackOnly(false)
    &lt;blockquote&gt;
      &lt;p&gt;There is no such method in Connection.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Node code is necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This is a trick question. Since auto-commit has been disabled in the given code (by calling &lt;code&gt;c.setAutoCommit(false)&lt;/code&gt;), you have to explicitly commit the transaction to commit the changes to the database. The regular way to do this is to call &lt;code&gt;con.commit()&lt;/code&gt;. Notice that commit method does not take any arguments.&lt;/p&gt;

&lt;p&gt;Another way is to utilize the side effect of changing the auto-commit mode of the connection. If the &lt;code&gt;setAutoCommit&lt;/code&gt; method is called during a transaction and the auto-commit mode is changed, the transaction is committed. If &lt;code&gt;setAutoCommit&lt;/code&gt; is called and the auto-commit mode is not changed, the call is a no-op. In this question, &lt;code&gt;con.setAutoCommit(true)&lt;/code&gt; changes the auto-commit mode of the connection from &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and therefore this call commits the changes.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;28.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {
    static Path p1 = Paths.get(&quot;c:\\a\\b\\c&quot;);
    public static String getValue(){
        String x = p1.getName(1).toString();
        String y = p1.subpath(1,2).toString();
        return x+&quot; : &quot;+y;
    }
    public static void main(String[] args) {
        System.out.println(getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;\b:\b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b\c\&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;a:a\b&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;b:b\c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember the following points about &lt;code&gt;Path.subpath(int beginIndex, int endIndex)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indexing starts from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not considered as the beginning.&lt;/li&gt;
  &lt;li&gt;name at beginIndex is included but name at endIndex is not.&lt;/li&gt;
  &lt;li&gt;paths do not start or end with .&lt;br /&gt;
Thus, if your path is “c:\a\b\c”,&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;subpath(1,1) will cause IllegalArgumentException to be thrown.&lt;br /&gt;
subpath(1,2) will correspond to b.&lt;br /&gt;
subpath(1,3) will correspond to b/c.&lt;/p&gt;

&lt;p&gt;Remember the following 4 points about Path.getName() method :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Indices for path names start from 0.&lt;/li&gt;
  &lt;li&gt;Root (i.e. c:) is not included in path names.&lt;/li&gt;
  &lt;li&gt;\ is NOT a part of a path name.&lt;/li&gt;
  &lt;li&gt;If you pass a negative index or a value greater than or equal to the number of elements, or this path has zero name elements, java.lang.IllegalArgumentException is thrown. It DOES NOT return null.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, for example, If your Path is “c:\code\java\PathTest.java”,&lt;br /&gt;
p1.getRoot()  is c:\  ((For Unix based environments, the root is usually / ).&lt;br /&gt;
p1.getName(0) is code&lt;br /&gt;
p1.getName(1) is java&lt;br /&gt;
p1.getName(2) is PathTest.java&lt;br /&gt;
p1.getName(3) will cause IllegalArgumentException to be thrown.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;29.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String value() default &quot;&quot;;
    String[] params();
    String date();
    int depth() default 10;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo(date = &quot;2019&quot;, params = &quot;index&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The date element is defined as String. So, it doesn’t really have to be a date. Any string value will be valid.&lt;br /&gt;
params is defined as a String[]. So, you can either use a single string such as used in this option or a String array such as params={“index”} or params={“index1”, “whatever”} or even params={}.&lt;br /&gt;
value and depth elements have default values so, the value for these elements can be omitted.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo(date = &quot;2019-1-1&quot;, params = { null }) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;You cannot set an annotation element (or its values, if it is an array) to null.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;code&gt;@DebugInfo(depth = 10, date = &quot;01/01/2019&quot;, params = {&quot;index&quot;}, value=&quot;applyLogic&quot;) static final String s = null;&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;The order of values for the elements is not important.&lt;/li&gt;
        &lt;li&gt;Since @Target annotation is not specified in the definition of @DebugInfo, it will be assumed that @DebugInfo is applicable to all place where annotations can be used.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo({&quot;index&quot;}, &quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Names of the elements cannot be omitted when there are more than one values. Even when there is only one value, the name of the element can be omitted only if the name of the element is value.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;code&gt;@DebugInfo(&quot;value&quot;, params={&quot;index&quot;}, date=&quot;01/01/2019&quot;) void applyLogic(int index){ }&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;You cannot omit the name of any element, if you are specifying values for more than one element. So, you must write value=”value” instead of just “value”.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;30.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String qr = &quot;insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)&quot;;
String[] tickers = {&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You are trying to initialize the STOCK table and for that you need to insert one row for each of the ticker value in the tickers array. Each row has to be initialized with the same values except the ID and TICKER columns, which are different for each row. The ID column is defined as AUTO_INCREMENT and so you need to pass only 0 for this column.&lt;/p&gt;

&lt;p&gt;Which of the following code snippets would you use?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;for(String ticker: tickers)
try(PreparedStatement ps = c.preparedStatement(qr);) {
  ps.setInt(1,0);
  ps.setString(2, ticker);
  ps.setDouble(3, 0.0);
  ps.setString(4, &quot;NYSE&quot;);
  ps.executeUpdate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This will close the PreparedStatement after each insert. This is very inefficient.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(PreparedStatement ps = c.prepareStatement(qr);)
{
  for(String ticker: tickers) {
    ps.setInt(1, 0);
    ps.setString(2, ticker);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    ps.executeUpdate()；
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is better than option 1 but there is no need to set the values for ID, LTP, and EXCHANGE columns in every iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try(PreparedStatement ps = c.prepareStatement(qr);)
{
    ps.setInt(1, 0);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    for(String ticker: tickers) {
      ps.setString(2, ticker);
      ps.executeUpdate()；
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;All of the options will insert the required rows in the table, however, this option is most suitable because it is the most efficient of all. A PreparedStatement remembers the values once you set them until you close it. So, there is no need to reset the values for ID, LTP, and EXCHANGE columns if they are not changing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;for(String ticker: tickers)
try(Statement s = c.createStatement(qr);)
{
  s.executeUpdate(&quot;insert into STOCK (ID, TICKER, LTP, EXCHANGE ) values (0, '&quot;+ticker+&quot;', 0.0, 'NYSE')&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This option is as bad as option 1 in terms of performance. Further, it does not offer protection from SQL injection either.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;31.&lt;/strong&gt;
Given that Book is a valid class with appropriate constructor and getTitle and getPrice methods that return a String and a Double respectively, what can be inserted at //1 and //2 so that it will print the price of all the books having a title that starts with “A”?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Book&amp;gt; books = Arrays.asList(
        new Book(&quot;Atlas Shrugged&quot;, 10.0),
        new Book(&quot;Freedom at Midnight&quot;, 5.0),
        new Book(&quot;Gone with the wind&quot;, 5.0)
);

Map&amp;lt;String, Double&amp;gt; bookMap = //1 INSERT CODE HERE
//2 INSERT CODE HERE
bookMap.forEach(func);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.steam().collect(Collectors.toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;String, Double&amp;gt; func = (a, b) -&amp;gt; {
  if(a.startsWith(&quot;A&quot;)) {
    System.out.println(b);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The first line generates a &lt;code&gt;Map&amp;lt;String, Double&amp;gt;&lt;/code&gt; from the List using Stream’s collect method. The &lt;code&gt;Collectors.toMap&lt;/code&gt; method uses two functions to get two values from each element of the stream.  The value returned by the first function is used as a key and the value returned by the second function is used as a value to build the resulting &lt;code&gt;Map&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;The &lt;code&gt;forEach&lt;/code&gt; method of a &lt;code&gt;Map&lt;/code&gt; requires a &lt;code&gt;BiConsumer&lt;/code&gt;. This function is invoked for each entry, that is each key-value pair, in the map. The first argument of this function is the key and the second is the value.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;String, Double&amp;gt; func = (a, b) -&amp;gt; {
  if(a.startsWith(&quot;A&quot;)) {
    System.out.println(b);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;toMap is not a valid method in Stream.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
BiConsumer&amp;lt;Map.Entry&amp;gt; func = (b)-&amp;gt; {
  if(b.getKey().startsWith(&quot;A&quot;)) {
    System.out.println(b.getValue());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;toMap is not a valid method in Stream.&lt;/li&gt;
    &lt;li&gt;BiConsumer requires two generic types and two arguments.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;books.stream().collect(Collectors.toMap((b-&amp;gt;b.getTitle()), b-&amp;gt;b.getPrice()));
// and
Consumer&amp;lt;Map.Entry&amp;lt;String, Double&amp;gt;&amp;gt; func = (e)-&amp;gt; {
  if(e.getKey().startsWith(&quot;A&quot;)) {
    System.out.println(e.getValue());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The implementation of Consumer is technically correct. However, the forEach method requires a BiConsumer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;33.&lt;/strong&gt;
NOTE: If you are not from a Computer Science background, this question will seem very complicated and almost unanswerable. Further, this has more to do with understanding of an algorithm than assertions. Unfortunately, we have seen similar question in the real exam. If you get such a question in your exam, our suggestion is to just mark it and move on. Attempt it only at the end if you have time.&lt;/p&gt;

&lt;p&gt;Given the following code that implements a sorting algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void mysort(int[] values){
    int n = values.length;
    for(int i = 1; i&amp;lt;n; i++){  

        //1
        int temp = values[i];
        int j = i-1;
        while( (j&amp;gt;-1) &amp;amp;&amp;amp; values[j]&amp;gt;temp){
            values[j+1] = values[j];
            j--;

            //2
        }
        //3
        values[j+1] = temp;

        //4
    }
    //5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test the working of this code, you want to assert that the elements are partially sorted in the middle of the sorting process using this statement:&lt;br /&gt;
&lt;code&gt;assert j&amp;lt;0 || values[j]&amp;lt;=values[j+1];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where can this statement be put?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //1.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //3.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;At //4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;At //5.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The basic idea behind this algorithm is to determine the right place of an element of among the elements that appear before it in the input array. If a list contains only 1 element, then the list is always already sorted. So, the first top level iteration starts with the second element. In this iteration, the second element is put in the correct position considering just the first two elements. Thus, at the end of the first iteration, first two elements will be sorted. The process is continued till the last element is put in its right place.&lt;/p&gt;

&lt;p&gt;Try to run the above code Step by Step in an editor. Observe the values of the variables.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;38.&lt;/strong&gt;
What will the following code print when run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  LocalDate d = LocalDate.now();
  DateFormat df = new DateFormat(DateFormat.LONG);
  System.out.println(df.format(d));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print current date in LONG format.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print the number of milliseconds since 1 Jan 1970.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will not compile.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will throw an exception at runtime.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;java.text.DateFormat&lt;/code&gt; class provides several static getXXXInstance methods. The following are the important methods that you need to know for the exam:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static DateFormat getDateInstance()&lt;/code&gt;&lt;br /&gt;
          Get a default date/time formatter that uses the SHORT style for both the date and the time.&lt;br /&gt;
&lt;code&gt;static DateFormat getDateInstance(int style)&lt;/code&gt;&lt;br /&gt;
          Gets the date formatter with the given formatting style for the default locale.&lt;br /&gt;
&lt;code&gt;static DateFormat getDateInstance(int style, Locale aLocale)&lt;/code&gt;&lt;br /&gt;
          Gets the date formatter with the given formatting style for the given locale.&lt;br /&gt;
&lt;code&gt;static DateFormat getInstance()&lt;/code&gt;&lt;br /&gt;
          Get a default date/time formatter that uses the default style for both the date and the time.&lt;/p&gt;

&lt;p&gt;Note that valid styles values are : &lt;code&gt;DateFormat.DEFAULT&lt;/code&gt;, &lt;code&gt;DateFormat.FULL&lt;/code&gt;, &lt;code&gt;DateFormat.LONG&lt;/code&gt;, &lt;code&gt;DateFormat.MEDIUM&lt;/code&gt;, and &lt;code&gt;DateFormat.SHORT&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;44.&lt;/strong&gt;
Assuming that STOCK table exists and is empty, what will the following code snippet print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String qr = &quot;insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)&quot;;
try(PreparedStatement ps =  c.prepareStatement(qr);)
{
    ps.setInt(1, 111);
    ps.setString(2, &quot;APPL&quot;);
    ps.setDouble(3, 0.0);
    ps.setString(4, &quot;NYSE&quot;);
    int i = ps.executeUpdate();  //1
    System.out.println(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile due to error at //1.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print 0.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will print 1.
    &lt;blockquote&gt;
      &lt;p&gt;executeUpdate returns the number of rows that have been affected by the query. If you execute a query that, for example, causes updates to 10 existing rows, executeUpdate would return 10. Here, 1 row has been inserted and so it will return 1.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print 4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print -1.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;45.&lt;/strong&gt;
Given that a method named Double getPrice(String id) exists and may potentially return null, about which of the following options can you be certain that a run time exception will not be thrown?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optional.of method throws NullPointerException if you try to create an Optional with a null value. If you expect the argument to be null, you should use Optional.ofNullable method, which returns an empty Optional if the argument is null.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.ofNullable(getPrice(&quot;1111&quot;));  
Double x = price.orElse(getPrice(&quot;2222&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.ofNullable(getPrice(&quot;1111&quot;));  
Double y = price.orElseGet(()-&amp;gt;getPrice(&quot;333&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optional’s &lt;code&gt;orElseGet&lt;/code&gt; method takes a &lt;code&gt;java.util.function.Supplier&lt;/code&gt; function as an argument and invokes that function to get a value if the Optional itself is empty. Just like the orElse method, this method does not throw any exception even if the Supplier returns null. It does, however, throw a NullPointerException if the &lt;code&gt;Optional&lt;/code&gt; is empty and the supplier function itself is null.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;), 10.0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This will not compile because Optional.of takes only one argument.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; price = Optional.of(getPrice(&quot;1111&quot;));  
Double z = price.orElseThrow(()-&amp;gt;new RuntimeException(&quot;Bad Code&quot;));  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code&gt;orElseThrow&lt;/code&gt; method takes a &lt;code&gt;Supplier&lt;/code&gt; function that returns an &lt;code&gt;Exception&lt;/code&gt;. This method is useful when you want to throw a custom exception in case the Optional is empty.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;46.&lt;/strong&gt;
Whi of the following are correct definitions of a repeatable annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable
public @interface Author {
  int id() default 0;
  String name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;@Repeatable requires the name of the container class. It cannot be empty. For example, @Repeatable(Authors.class)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable(List.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Repeatable(List&amp;lt;Author&amp;gt;)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public @interface Authors {
  Author[] value();
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The value of the @Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Authors {
  Author[] values;
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Authors {
  List&amp;lt;Author&amp;gt; authors;
}
@Repeatable(Authors.class)
public @interface Author {
  int id() default 0;
  String name();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;48.&lt;/strong&gt;
Which of the following is correct regarding a HashSet?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Elements are stored in a sorted order.
    &lt;blockquote&gt;
      &lt;p&gt;TreeSet does that.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It is immutable.
    &lt;blockquote&gt;
      &lt;p&gt;No, you can add/remove elements to/from it.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It only keeps unique elements.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Elements can be accessed using a unique key.
    &lt;blockquote&gt;
      &lt;p&gt;HashSet is a Set not a Map.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
public class HashSet extends AbstractSet implements Set, Cloneable, Serializable&lt;/p&gt;

&lt;p&gt;This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;50.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public @interface Authors{
   Author[] value();
}
@Repeatable(Authors.class)
public @interface Author {
    int id() default 0;
    String value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct usages of the above annotations.&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(1, &quot;bob&quot;)
@Author(2, &quot;alice&quot;)
public class Sample {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use name=value format for element values because more than one values are being specified.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Authors(@Author(&quot;bob&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;To make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write @Author(“bob”) but, internally, Java converts it to @Authors(@Author(“bob”)).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Authors(@Author(&quot;bob&quot;))
@Authors(@Author(&quot;alice&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The @Author annotation is repeatable, @Authors is not!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Authors(@Author(&quot;alice&quot;))
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Author(1)
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The two annotations are different. Their values are not additive. So, while @Author(“bob”) is valid @Author(1) is not because it does not include a value for the value element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Author(&quot;bob&quot;)
@Author(id=1, value=null)
void someMethod(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;@Author(id=1, value=null) is invalid because you cannot set an element value to null. The value must be a constant non-null value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;54.&lt;/strong&gt;
Given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;RandomAccessFile raf = new RandomAccessFile(&quot;c:\\temp\\test.txt&quot;, &quot;rwd&quot;);
raf.writeChars(&quot;hello&quot;);
raf.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following statements are correct?&lt;br /&gt;
(Assuming that the code has appropriate security permissions.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;If the file test.txt does not exist, an attempt will be made to create it.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt does not exist, an exception will be thrown.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt exists, an exception will be thrown.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt, it will be overwritten and all the existing data will be lost.
    &lt;blockquote&gt;
      &lt;p&gt;Only the initial 5 characters (i.e. 10 bytes) of the file will be overwritten. Any existing data beyond 10 bytes will be left untouched.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;If the file test.txt exists, the given characters will be appended to the end of the existing data.
    &lt;blockquote&gt;
      &lt;p&gt;When you open the file, the pointer is at the first position. So the given characters will be written at the beginning of the file.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
The permitted values for the access mode and their meanings are:&lt;/p&gt;

&lt;p&gt;“r”: Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown.&lt;br /&gt;
“rw”: Open for reading and writing. If the file does not already exist then an attempt will be made to create it.&lt;br /&gt;
“rws”: Open for reading and writing, as with “rw”, and also require that every update to the file’s content or metadata be written synchronously to the underlying storage device.&lt;br /&gt;
“rwd”: Open for reading and writing, as with “rw”, and also require that every update to the file’s content be written synchronously to the underlying storage device.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;55.&lt;/strong&gt;
Given the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title
{
    MR(&quot;Mr. &quot;), MRS(&quot;Mrs. &quot;), MS(&quot;Ms. &quot;);
    private String title;
    private Title(String s){
    title = s;
    }
    public String format(String first, String last){
    return title+&quot; &quot;+first+&quot; &quot;+last;
    }
}

//INSERT CODE HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify valid code snippets ..&lt;/p&gt;

&lt;p&gt;(Assume that Title is accessible wherever required.)&lt;br /&gt;
&lt;strong&gt;You had to select 4 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println(Title.format(&quot;Rob&quot;, &quot;Miller&quot;));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot call format method directly on Title because format is not a static method. You must call it on Title instances. For example, Title.MR.format().&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    System.out.println(MR.format(&quot;Rob&quot;, &quot;Miller&quot;));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;It must be Title.MR.format(“Rob”, “Miller”).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2 extends Ttile
{
  DR(&quot;Dr. &quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;An enum cannot extend another enum or class. It may implement an interface though.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class TestClass {
  void someMethod()
  {
    Title.DR dr = new Title.DR(&quot;Dr. &quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Enum constants cannot be instantiated/created using the new keyword.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 6&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 7&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t = Title.MR;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 8&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;enum Title2
{
  DR;
  private Title t = Title.MR;
  public String format(String s) { return t.format(s, s); };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to know the following facts about enums:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.&lt;/li&gt;
  &lt;li&gt;An enum is implicitly final, which means you cannot extend it.&lt;/li&gt;
  &lt;li&gt;You cannot extend an enum from another enum or class because an enum implicitly extends &lt;code&gt;java.lang.Enum&lt;/code&gt;. But an enum can implements interfaces.&lt;/li&gt;
  &lt;li&gt;Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because &lt;code&gt;java.lang.Enum&lt;/code&gt; makes it final.&lt;/li&gt;
  &lt;li&gt;Compiler provides an enum with two public static methods automatically - &lt;code&gt;values()&lt;/code&gt; and &lt;code&gt;valueOf(String)&lt;/code&gt;. The &lt;code&gt;values()&lt;/code&gt; method returns an array of its constants and &lt;code&gt;valueOf()&lt;/code&gt; method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;By default, an enum’s toString() prints the enum name but you can override it to print anything you want.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following are a few more important facts about java.lang.Enum which you should know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It implements &lt;code&gt;java.lang.Comparable&lt;/code&gt; (thus, an enum can be added to sorted collections such as &lt;code&gt;SortedSet&lt;/code&gt;, &lt;code&gt;TreeSet&lt;/code&gt;, and &lt;code&gt;TreeMap&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;It has a method &lt;code&gt;ordinal()&lt;/code&gt;, which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.&lt;/li&gt;
  &lt;li&gt;It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;57.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;module abc.print{
   requires org.pdf;
   provides org.pdf.Print with com.abc.print.PrintImpl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct statements about the above module.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;org.pdf.Print must be an interface.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;org.pdf.Print must be an interface or an abstract class.
    &lt;blockquote&gt;
      &lt;p&gt;Ideally, Print should be an interface or an abstract class but there is no such technical restriction. As per JLS Section 7.7.4: The service must be a class type, an interface type, or an annotation type. It is a compile-time error if a provides directive specifies an enum type as the service.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;com.abc.print.PrintImpl must have a no-args constructor.
    &lt;blockquote&gt;
      &lt;p&gt;This is not necessary. It could also have a provider method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;com.abc.print.PrintImpl must implement(or extend) org.pdf.Print.
    &lt;blockquote&gt;
      &lt;p&gt;This is not necessary. If PrintImpl has a provider method, then that method could return any sub-type of Print. PrintImpl does not have to be a sub-type of Print.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;None of the above are correct.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Here are the rules for a service provider:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If a service provider explicitly declares a public constructor with no formal parameters, or implicitly declares a public default constructor, then that constructor is called the provider constructor.&lt;/li&gt;
  &lt;li&gt;If a service provider explicitly declares a public static method called provider with no formal parameters, then that method is called the provider method.&lt;/li&gt;
  &lt;li&gt;If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the provides directive; or a compile-time error occurs.&lt;/li&gt;
  &lt;li&gt;While a service provider that is specified by a provides directive must be declared in the current module, its provider method may have a return type that is declared in another module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service.&lt;/li&gt;
  &lt;li&gt;If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the provides directive, or a compile-time error occurs.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;58.&lt;/strong&gt;
Which of the following statements are correct regarding synchronization and locks?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A thread shares the intrinsic lock of an object with other threads between the time the threads enter a synchronized method and exit the method.
    &lt;blockquote&gt;
      &lt;p&gt;Just the opposite is true. An intrinsic lock is never shared. Once a thread acquires an intrinsic lock, it owns the lock exclusively until it releases the lock.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;When a synchronized method ends with a checked exception, the intrinsic lock held by the thread is released automatically.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;A thread will retain the intrinsic lock if the return from a synchronized method is caused due to an uncaught unchecked exception.
    &lt;blockquote&gt;
      &lt;p&gt;The intrinsic lock is released when the method ends. Irrespective of how it ends.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Every object has an intrinsic lock associated with it and that lock is automatically acquired by a thread when it executes a method on that object.
    &lt;blockquote&gt;
      &lt;p&gt;A thread acquires the intrinsic lock of an object when it enters synchronized method on that object or when it enter a synchronized block that uses that object. The lock is not acquired when a thread enters a non-synchronized method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Please go through this link that explains synchronization and intrinsic locks. You will find questions in the exam that use statements given in this trail: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;59.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.Serializable;
class Booby{
    int i; public Booby(){ i = 10; System.out.print(&quot;Booby&quot;); }
}
class Dooby extends Booby implements Serializable {
    int j; public Dooby(){ j = 20; System.out.print(&quot;Dooby&quot;); }
}
class Tooby extends Dooby{
    int k; public Tooby(){ k = 30; System.out.print(&quot;Tooby&quot;); }
}
public class TestClass {
  public static void main(String[] args) throws Exception{
    Tooby t = new Tooby();
    t.i = 100;
    ObjectOutputStream oos  = new ObjectOutputStream(new FileOutputStream(&quot;c:\\temp\\test.ser&quot;));
    oos.writeObject(t); oos.close();
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;c:\\temp\\test.ser&quot;));
    t = (Tooby) ois.readObject();ois.close();
    System.out.println(t.i+&quot; &quot;+t.j+&quot; &quot;+t.k);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby 100 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby Dooby Tooby 10 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Booby Dooby Tooby Booby 10 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby 0 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby 100 20 30&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Booby Dooby Tooby Booby Dooby Tooby 100 20 30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Objects of a class that is not marked Serializable cannot be serialized. In this question, class Booby does not implement Serializable and so, its objects cannot be serialized. Class Dooby implements Serializable and since Tooby extends Dooby, it is Serializable as well.&lt;/p&gt;

&lt;p&gt;Now, when you serialize an object of class Tooby, only the data members of Dooby and Tooby will be serialized. Data members of Booby will not be serialized. Thus, the value of i (which is 100) at the time of serialization will not be saved in the file.&lt;/p&gt;

&lt;p&gt;When reading the object back (i.e. deserializing), the constructors of serializable classes are not called. Their data members are set directly from the values present in serialized data. Constructor for unserializable classes is called. Thus, in this case, constructors of Tooby and Dooby are not called but the constructor of Booby is called. Therefore, i is set in the constructor to 10 and j and k are set using the data from the file to 20 and 30 respectively.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;60.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.TYPE)
public @interface DBTable {
  public String value();
  public String[] primarykey();
  public String surrogateKey() default &quot;id&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify correct usages of the above annotation.&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;person&quot;, primarykey={&quot;name&quot;})
interface Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use value=”person” because you are specifying values for more than one elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(value=&quot;person&quot; primarykey={&quot;name&quot;})
interface Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;person&quot;, {&quot;name&quot;}, &quot;pid&quot;)
class Person {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Must use elementName=elementValue format for specifying element values because you are specifying values for more than one element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(value=&quot;DAYS&quot;, primarykey=&quot;name&quot;)
enum DAYS {
  MON, TUE, WED, THU, FRI, SAT, SUN;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since the target of @DBTable annotation is specified as ElementType.TYPE, this annotation can be used on a class, an interface, or an enum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DBTable(&quot;DAYS&quot;, {&quot;name&quot;})
enum DAYS {
  MON, TUE, WED, THU, FRI, SAT, SUN;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
There are two rules that you need to remember while specifying values for annotation elements:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;You can omit the element name while specifying a value only when the name of the element is value and only when you are specifying just one value. In other words, if you are specifying values for more than one elements, you need to use the elementName=elementValue format for each element. The order of the elements is not important.&lt;/li&gt;
  &lt;li&gt;If an element expects an array, you can specify the values by enclosing them in { }. But if you want to specify an array of length 1, you may omit the { }.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;62.&lt;/strong&gt;
What will the following code fragment print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Path p1 = Paths.get(&quot;x\\y&quot;);
Path p2 = Paths.get(&quot;z&quot;);
Path p3 = p1.relativize(p2);
System.out.println(p3);

&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;x\y\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + \x\y\z =&amp;gt; x\y\x\y\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + \z =&amp;gt; x\y\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;..\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + ..\z =&amp;gt; x\z&lt;br /&gt;
This is not same as z&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;..\..\z
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
x\y + ..\..\z =&amp;gt; x + ..\z =&amp;gt; z&lt;br /&gt;
This is what we want. So this is the correct answer.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;A “..” implies parent folder, therefore imagine that you are taking off one “..” from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.&lt;br /&gt;
For example, .. appended to y makes it y\.., which cancels out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, “a/c” relativize “a/b”  is “../b” because “/a/c/../b” is “/a/b” Notice that  “c/..” cancel out.&lt;/p&gt;

&lt;p&gt;Please go through the following description of relativize() method, which explains how it works in more detail.&lt;/p&gt;

&lt;p&gt;Note that in Java 11, the paths are first normalized before relativizing.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path relativize(Path other)&lt;/code&gt;&lt;br /&gt;
Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is “/a/b” and the given path is “/a/b/c/d” then the resulting relative path would be “c/d”.&lt;/p&gt;

&lt;p&gt;Where this path and the given path do not have a root component, then a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;A relative path cannot be constructed if only one of the paths have a root component.&lt;/p&gt;

&lt;p&gt;Where both paths have a root component then it is implementation dependent if a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;If this path and the given path are equal then an empty path is returned.&lt;/p&gt;

&lt;p&gt;For any two normalized paths p and q, where q does not have a root component,
p.relativize(p.resolve(q)).equals(q)&lt;/p&gt;

&lt;p&gt;When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is “/a/b” and the given path is “/a/x” then the resulting relative path may be “../x”. If “b” is a symbolic link then is implementation dependent if “a/b/../x” would locate the same file as “/a/x”.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;63.&lt;/strong&gt;
What will the following code fragment print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Path p1 = Paths.get(&quot;\\personal\\readme.txt&quot;);
Path p2 = Paths.get(&quot;\\index.html&quot;);
Path p3 = p1.relativize(p2);
System.out.println(p3);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + \index.html =&amp;gt;\personal\readme.txt\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;\personal\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + \personal\index.html =&amp;gt;\personal\readme.txt\personal\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;personal\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe what happens when you append this path to p1:&lt;br /&gt;
\personal\readme.txt + personal\index.html =&amp;gt;\personal\readme.txt\personal\index.html&lt;br /&gt;
This is not same as \index.html&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;..\..\index.html
    &lt;blockquote&gt;
      &lt;p&gt;Observe that if you append this path to p1, you will get p2. Therefore, this is the right answer.&lt;br /&gt;
p1 + ....\index.html&lt;br /&gt;
=&amp;gt;\personal\readme.txt + ....\index.html&lt;br /&gt;
=&amp;gt;\personal + ..\index.html&lt;br /&gt;
=&amp;gt;\index.html&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;A “..” implies parent folder, therefore imagine that you are taking off one “..” from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.&lt;br /&gt;
For example, .. appended to personal makes it personal.., which cancels out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
You need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, “a/c” relativize “a/b”  is “../b” because “/a/c/../b” is “/a/b” Notice that  “c/..” cancel out.&lt;/p&gt;

&lt;p&gt;Note that in Java 11, the paths are first normalized before computing relativizing.&lt;/p&gt;

&lt;p&gt;Please go through the following description of relativize() method, which explains how it works in more detail.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public Path relativize(Path other)&lt;/code&gt;&lt;br /&gt;
Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is “/a/b” and the given path is “/a/b/c/d” then the resulting relative path would be “c/d”.&lt;/p&gt;

&lt;p&gt;Where this path and the given path do not have a root component, then a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;A relative path cannot be constructed if only one of the paths have a root component.&lt;/p&gt;

&lt;p&gt;Where both paths have a root component then it is implementation dependent if a relative path can be constructed.&lt;/p&gt;

&lt;p&gt;If this path and the given path are equal then an empty path is returned.&lt;/p&gt;

&lt;p&gt;For any two normalized paths p and q, where q does not have a root component,
p.relativize(p.resolve(q)).equals(q)&lt;/p&gt;

&lt;p&gt;When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is “/a/b” and the given path is “/a/x” then the resulting relative path may be “../x”. If “b” is a symbolic link then is implementation dependent if “a/b/../x” would locate the same file as “/a/x”.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;65.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Boiler{
    public void boil();
    private static void log(String msg){ //1
       System.out.println(msg);
    }
    public static void shutdown(){
        log(&quot;shutting down&quot;);
    }
}
interface Vaporizer extends Boiler{  
    public default void vaporize(){
        boil();
        System.out.println(&quot;Vaporized!&quot;);
    }
}
public class Reactor implements Vaporizer{
    public void boil() {
        System.out.println(&quot;Boiling...&quot;);
    }

    public static void main(String[] args) {
        Vaporizer v =  new Reactor(); //2
        v.vaporize(); //3
        v.shutdown(); //4
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;Boiling...
Vaporized!
shutting down
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Compilation failure at //1.
    &lt;blockquote&gt;
      &lt;p&gt;Since Java 9, an interface is allowed to have private (but not protected) static as well as instance methods. Fields of an interface are still always implicitly public, static, and final.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Compilation failure at //2.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Compilation failure at //4.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 5&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;If code at //4 is changed to Vaporizer.shutdown();, it will print  Boiling...
Vaporized!
shutting down
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Definition of interface Vaporizer will cause compilation to fail.
    &lt;blockquote&gt;
      &lt;p&gt;Definition of interface Vaporizer is fine.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Remember that static method of an interface can only be accessed by using the name of that interface. i.e. &lt;code&gt;Boiler.shutdown()&lt;/code&gt; in this case. This is unlike a static method of a class, which can be accessed using a subclass name or a variable name as well.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;66.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DebugInfo {
    String value();
    String[] params();
    String date();
    int depth();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following options correctly uses the above annotation?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date = &quot;2019&quot;, depth = 10, params = &quot;index&quot;)
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The date element is defined as String. So, it doesn’t really have to be a date. Any string value will be valid. params is defined as a &lt;code&gt;String[]&lt;/code&gt;. So, you can either use a single string such as used in this option or a String array such as &lt;code&gt;params={&quot;index&quot;}&lt;/code&gt; or &lt;code&gt;params={&quot;index1&quot;, &quot;whatever&quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date = &quot;01/01/2019&quot;, depth = &quot;10&quot;, params = &quot;index&quot; )
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;em&gt;depth&lt;/em&gt; is defined as &lt;code&gt;int&lt;/code&gt;, you can’t pass “10”, You must pass 10 (i.e. without double quotes.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date=&quot;01/01/2019&quot;, depth=&quot;10&quot;, params = {&quot;index&quot;})
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;em&gt;depth&lt;/em&gt; is defined as &lt;code&gt;int&lt;/code&gt;, you can’t pass “10”, You must pass 10 (i.e. without double quotes.)&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@DebugInfo(value=&quot;applyLogic&quot;, date=&quot;01/01/2019&quot;)
@DebugInfo(depth = 10, params = {&quot;index&quot;})
void applyLogic(int index) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since @DebugInfo is not annotated with @Repeatable, you can use this annotation only once at any place.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;69.&lt;/strong&gt;
Identify the correct statements about the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;
class Person {
    private static int count = 0;
    private String id = &quot;0&quot;; private String interest;
    public Person(String interest){ this.interest = interest; this.id = &quot;&quot; + ++count; }
    public String getInterest(){ return interest;     }
    public void setInterest(String interest){ this.interest = interest; }
    public String toString(){ return id; }
}

public class StudyGroup
{
    String name = &quot;MATH&quot;;
    TreeSet&amp;lt;Person&amp;gt; set = new TreeSet&amp;lt;Person&amp;gt;();
    public void add(Person p) {
      if(name.equals(p.getInterest())) set.add(p);
    }

    public static void main(String[] args) {
      StudyGroup mathGroup = new StudyGroup();
      mathGroup.add(new Person(&quot;MATH&quot;));
      System.out.println(&quot;A&quot;);
      mathGroup.add(new Person(&quot;MATH&quot;));
      System.out.println(&quot;B&quot;);
      System.out.println(mathGroup.set);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print : A, B, and then the contents of mathGroup.set.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will compile with a warning.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will NOT throw an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;It will compile without warning but will throw an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will only print : A&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will print : A and B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
Note that &lt;code&gt;TreeSet&lt;/code&gt; is an ordered set that keeps its elements in a sorted fashion. When you call the &lt;code&gt;add()&lt;/code&gt; method, it immediately compares the element to be added to the existing elements and puts the new element in its appropriate place. Thus, the foremost requirement of a &lt;code&gt;TreeSet&lt;/code&gt; is that the elements must either implement &lt;code&gt;Comparable&lt;/code&gt; interface (which has the &lt;code&gt;compareTo(Object) method)&lt;/code&gt; and they must also be mutually comparable or the &lt;code&gt;TreeSet&lt;/code&gt; must be created with by passing a &lt;code&gt;Comparator&lt;/code&gt; (which has a &lt;code&gt;compare(Object, Object)&lt;/code&gt; method). For example, you might have two classes \\\A\\\ and \\\B\\\ both implementing &lt;code&gt;Comparable&lt;/code&gt; interface. But if their &lt;code&gt;compareTo()&lt;/code&gt; method does not work with both the types, you cannot add both type of elements in the same &lt;code&gt;TreeSet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this question, &lt;code&gt;Person&lt;/code&gt; class does not implement &lt;code&gt;Comparable&lt;/code&gt; interface. Ideally, when you add the first element, since there is nothing to compare this element to, there should be no exception. But when you add the second element, &lt;code&gt;TreeSet&lt;/code&gt; tries to compare it with the existing element, thereby throwing &lt;code&gt;ClassCastException&lt;/code&gt; because they don’t implement &lt;code&gt;Comparable&lt;/code&gt; interface. However, this behavior was changed in the &lt;code&gt;TreeSet&lt;/code&gt; implementation recently and it throws a &lt;code&gt;ClassCastException&lt;/code&gt; when you add the first element itself.&lt;/p&gt;

&lt;p&gt;The compiler knows nothing about this requirement of &lt;code&gt;TreeSet&lt;/code&gt; since it is an application level requirement and not a language level requirement. So the program compiles fine without any warning.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;70.&lt;/strong&gt;
java.util.Locale allows you to do which of the following?&lt;br /&gt;
&lt;strong&gt;You had to select 2 options&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country specific formatting for fonts.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country and language specific for HTML pages.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Provide country and language specific formatting for Dates.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Provide country specific formatting for Currencies.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Provide country and language specific formatting for properties files.
    &lt;blockquote&gt;
      &lt;p&gt;The objective of Localization is not to format properties files but to format the data that is displayed to the user in country/language specific manner. Resource Bundles, which are nothing but appropriately named properties files, are used along with the &lt;code&gt;Locale&lt;/code&gt; (i.e. country and language) information to format &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Currencies&lt;/code&gt;, and text messages in Locale specific manner.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;73.&lt;/strong&gt;
Identify valid statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocal = System.getDefaultLocale();
    &lt;blockquote&gt;
      &lt;p&gt;There is no such method in System class.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocale = Locale.getDefaultLocale();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = Locale.getDefault();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = Locale.US;
    &lt;blockquote&gt;
      &lt;p&gt;Locale class has several static constants for standard country locales.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Locale myLocale = Locale.getInstance();
    &lt;blockquote&gt;
      &lt;p&gt;There is no getInstance() method in Locale.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Locale myLocale = new Locale(“ru”, “RU”);
    &lt;blockquote&gt;
      &lt;p&gt;You don’t have to worry about the actual values of the language and country codes. Just remember that both are two lettered codes and country codes are always upper case.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;74.&lt;/strong&gt;
Consider the following classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Boo {
    public Boo(){ System.out.println(&quot;In Boo&quot;); }
}
class BooBoo extends Boo {
    public BooBoo(){ System.out.println(&quot;In BooBoo&quot;); }
}

class Moo extends BooBoo implements Serializable {
    int moo = 10; { System.out.println(&quot;moo set to 10&quot;); }
    public Moo(){ System.out.println(&quot;In Moo&quot;); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the following code was executed and the file moo1.ser was created successfully:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  Moo moo = new Moo();
  moo.moo = 20;
  FileOutputStream fos = new FileOutputStream(&quot;c:\\temp\\moo1.ser&quot;);
  ObjectOutputStream os = new ObjectOutputStream(fos);
  os.writeObject(moo);
  os.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, the following code was executed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;  FileInputStream fis = new FileInputStream(&quot;c:\\temp\\moo1.ser&quot;);
  ObjectInputStream is = new ObjectInputStream(fis);
  Moo moo = (Moo) is.readObject();
  is.close();
  System.out.println(moo.moo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which of the following will be a part of the output of the second piece of code?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;In Boo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;In BooBoo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;In Moo&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;10&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;20&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;moo set to 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
During deserialization, the constructor of the class (or any static or instance blocks) is not executed. However, if the super class does not implement Serializable, its constructor is called. So here, &lt;code&gt;BooBoo&lt;/code&gt; and &lt;code&gt;Boo&lt;/code&gt; are not Serializable. So, their constructor is invoked.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;75.&lt;/strong&gt;
What will the following code print when compiled and run?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.*;

interface Birdie {
    void fly();
}

class Dino implements Birdie {
    public void fly(){ System.out.println(&quot;Dino flies&quot;); }
    public void eat(){ System.out.println(&quot;Dino eats&quot;);}
}

class Bino extends Dino {
    public void fly(){ System.out.println(&quot;Bino flies&quot;); }
    public void eat(){ System.out.println(&quot;Bino eats&quot;);}
}

public class TestClass {
    public static void main(String[] args)    {
       List&amp;lt;Birdie&amp;gt; m = new ArrayList&amp;lt;&amp;gt;();
       m.add(new Dino());
       m.add(new Bino());
       for(Birdie b : m) {
    b.fly();
    b.eat();
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dino flies
Dino eats
Bino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Bino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dino flies
Bino eats
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;The code will not compile.
    &lt;blockquote&gt;
      &lt;p&gt;Note that in the for loop b has been declared to be of type Birdie. But Birdie doesn’t define the method eat(), so the compiler will not allow b.eat() even though the actual class of the object referred to by b does have an eat() method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Exception at run time.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;76.&lt;/strong&gt;
Consider the following program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.FileReader;
import java.io.FileWriter;

public class ClosingTest {
    public static void main(String[] args) throws Exception {
        try(FileReader fr = new FileReader(&quot;c:\\temp\\license.txt&quot;);
            FileWriter fw = new FileWriter(&quot;c:\\temp\\license2.txt&quot;) )
        {
            int x = -1;
            while( (x = fr.read()) != -1){
                fw.write(x);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identify the correct statements.&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The FileWriter object will always be closed before the FileReader object.
    &lt;blockquote&gt;
      &lt;p&gt;Resources are closed automatically at the end of the try block in reverse order of their creation.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The order of the closure of the FileWriter and FileReader objects is platform dependent and should not be relied upon.
    &lt;blockquote&gt;
      &lt;p&gt;The order is defined. They are always closed in the reverse order.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The FileWriter object will not be closed if an exception is thrown while closing the FileReader object.
    &lt;blockquote&gt;
      &lt;p&gt;The close method is called on all the resources one by one even if any resource throws an exception in its close method.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;This is not a fail safe approach to managing resources because in certain situations one or both of the resources may be left open after the end of the try block.
    &lt;blockquote&gt;
      &lt;p&gt;This is the right approach. The close method will be called automatically on all the resources that were opened even if any exception is thrown any where.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;77.&lt;/strong&gt;
Given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Book{
    private String title;
    private double price;
    public Book(String title, double price){
        this.title = title;
        this.price = price;
    }
    //getters/setters not shown
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What will the following code print?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Book&amp;gt; books = Arrays.asList(new Book(&quot;Thinking in Java&quot;, 30.0),
                                 new Book(&quot;Java in 24 hrs&quot;, 20.0),
                                 new Book(&quot;Java Recipies&quot;, 10.0));
double averagePrice = books.stream().filter(b-&amp;gt;b.getPrice()&amp;gt;10)
        .mapToDouble(b-&amp;gt;b.getPrice())
        .average().getAsDouble();
System.out.println(averagePrice);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will not compile.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;It will thrown an exception at runtime.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;0.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;25.0&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
This is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition &lt;code&gt;b.getPrice()&amp;gt;10&lt;/code&gt;, which means only two elements are left in the stream, second, it maps each &lt;code&gt;Book&lt;/code&gt; element to a double using the mapping function &lt;code&gt;b.getPrice()&lt;/code&gt;, which means, the stream now contains two doubles - &lt;em&gt;20.0&lt;/em&gt; and &lt;em&gt;30.0&lt;/em&gt;. Finally, the &lt;code&gt;average()&lt;/code&gt; method computes the average of all the elements. Therefore, the code will print &lt;em&gt;25.0&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition &lt;code&gt;b.getPrice()&amp;gt;10&lt;/code&gt;, which means only two elements are left in the stream, second, it maps each &lt;code&gt;Book&lt;/code&gt; element to a double using the mapping function &lt;code&gt;b.getPrice()&lt;/code&gt;, which means, the stream now contains two doubles - &lt;em&gt;20.0&lt;/em&gt; and &lt;em&gt;30.0&lt;/em&gt;. Finally, the &lt;code&gt;average()&lt;/code&gt; method computes the average of all the elements. Therefore, the code will print &lt;em&gt;25.0&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;79.&lt;/strong&gt;
Your group has an existing application (reports.jar) that uses a library (analytics.jar) from another group in your company. Both - the application and the library - use a JDBC driver packaged in ojdbc8.jar.&lt;/p&gt;

&lt;p&gt;Which of the following options describes the steps that will be required to modularize your application?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;option 1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert analytics.jar and ojdbc8.jar into automatic modules  
2. Convert reports.jar into a named module.  
3. Add requires clauses for analytics and ojdbc8 in reports.jar in its module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 2&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Modularize analytics.jar and ojdbc8.jar into modules by adding module-info.java to these jars. 2. Convert reports.jar into a named module. 3. Add requires clauses for all packages contained in analytics.jar and ojdbc8.jar that are directly referred to by classes in reports.jar in its module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 3&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert reports.jar into a named module. 2. Add requires clauses for analytics and ojdbc8 modules in reports.jar in its module-info.java. 3. Use analytics.jar and ojdbc8.jar as unnamed modules.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;option 4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;1. Convert ojdbc8.jar into automatic module. 2. Convert analytics.jar into a named module by adding module-info.java to it. In this module-info, export all packages that are used by reports.jar and add requires clauses for all packages of ojdbc.jar that are used by analytics.jar. 3. Convert reports.jar into a named module. Add requires clause for analytics module in reports's module-info.java.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
If a module directly uses classes from another jar, then that jar has to be converted into a module (either named or automatic).&lt;/p&gt;

&lt;p&gt;So, if you want to modularize reports.jar, then analytics.jar and ojdbc8.jar must also be converted into a module. Since these two jars are not controlled by you, they can be converted into automatic modules.&lt;/p&gt;

&lt;p&gt;module-info for reports.jar must have requires clauses for the two automatic modules (whose names will be analytics and ojdbc8).&lt;/p&gt;

&lt;p&gt;Since an automatic module is allowed to access classes from all other modules, nothing special needs to be done for analytics.jar. It will be able to access all classes from ojdbc.jar.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;80.&lt;/strong&gt;
Which of the given options if put at //1 will correctly instantiate objects of various classes defined in the following code?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class TestClass
{
   public class A{
   }
   public static class B {
   }
   public static void main(String args[]){
      class C{
      }
      //1
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;new TestClass().new A();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass().new B();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass.A();
    &lt;blockquote&gt;
      &lt;p&gt;A is not static. So on outer instance of TestClass is necessary.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;new C();&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;new TestClass.C();&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
class A is not static inner class of &lt;code&gt;TestClass&lt;/code&gt;. So it cannot exist without an outer instance of &lt;code&gt;TestClass&lt;/code&gt;. So, option 1 is the right way to instantiate it. class B is static inner class and can be instantiated like this: &lt;code&gt;new TestClass.B()&lt;/code&gt;. But &lt;code&gt;new TestClass().new B()&lt;/code&gt; is not correct.&lt;br /&gt;
Although not related to this question, unlike popular belief, anonymous class can never be static. Even if created in a static method.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;81.&lt;/strong&gt;
Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Statement stmt = null;
try(Connection c = DriverManager.getConnection(&quot;jdbc:derby://localhost:1527/sample&quot;, &quot;app&quot;, &quot;app&quot;))
{
    stmt = c.createStatement();
    ResultSet rs = stmt.executeQuery(&quot;select * from STUDENT&quot;);
    while(rs.next()){
        System.out.println(rs.getString(1));
    }

}
catch(SQLException e){
    System.out.println(&quot;Exception &quot;+e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which objects can be successfully used to query the database after the try block ends without any exception?&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;c&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;rs&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;stmt as well c&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;None of them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;br /&gt;
There are a few things to note in the question:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Once a &lt;code&gt;Connection&lt;/code&gt; object is closed, you cannot access any of the subsequent objects such as &lt;code&gt;Statement&lt;/code&gt; and &lt;code&gt;ResultSet&lt;/code&gt; that are retrieved from that &lt;code&gt;Connection&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The references declared in the try block (in this case, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;ResultSet&lt;/code&gt;) are not visible outside the try block. Not even in the catch block.&lt;/li&gt;
  &lt;li&gt;When a resource is created in the try-with-resources block ( in this case, c), it is closed at the end of the try block irrespective of whether there is an exception in the try block or not.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Based on the above, it is easy to see that only stmt is visible after the try block but it cannot be successfully used because the &lt;code&gt;Connection&lt;/code&gt; object from which it was retrieved has already been closed.&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Mar 2020 12:20:00 +0000</pubDate>
        <link>https://blog.zwt.io/2020/03/28/ocp-mock-test2-review/</link>
        <guid isPermaLink="true">https://blog.zwt.io/2020/03/28/ocp-mock-test2-review/</guid>
        
        <category>Java</category>
        
        <category>1Z0-816</category>
        
        <category>认证考试</category>
        
        
      </item>
    
  </channel>
</rss>
